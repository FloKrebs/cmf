<!-- HTML header for doxygen 1.8.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<title>cmf: $title</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <span id="projectlogo"><img alt="cmf - the catchment modelling framework" src="cmf-logo-klein.png"/></span>
  <span style="padding-left: 2em;">
   <span id="projectname">cmf
   &#160;<span id="projectnumber">1.2.1a0</span>
   </span>
   <span id="projectbrief">The Catchment Modelling Framework</span>
  </span>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="contents">
<div class="textblock"><h1>Semi distributed models in CMF</h1>
<p>Creating a lumped and a semi distributed model in CMF can be handled relatively similar. The main difference is that a lumped model contains only one cell, while a semi distributed model contains several cells (one for every subatchment). This leads to a more difficult construction and parametrization of the semi distributed model. The most straightforward way to adress this, is to split the code in severall classes. The main model class calls all the other classes and has the interface to Spotpy (or handles the manual calibration). The second class is a kind of template for a cell. In this class all CMF elements which are the same for all subcatchments are defined. This class inherits then to the classes of the several subcatchments. In those classes for the subcatchments all CMF elements are added which are different to the other subcatchments. This is also a good place to add the weather data for the subcatchments.</p>
<p>Important: In lumped models with a cell area other than 1000 m² and especially in semi distributed models, where every cell has another size, some parameters need to be adjusted for the size of the cell. Examples would be V0 in the PowerLaw or ETV1 in the evapotranspiration.</p>
<p>Following is a example how one might construct a semi distributed model. The example allows the user to choose the amount of cells in the model. All cells here use the same data and parameters. This would have to be changed for other usage.</p>
<p>The model itself and its driving data are attached to this site.</p>
<div class="fragment"><div class="line"># -*- coding: utf-8 -*-</div><div class="line">&quot;&quot;&quot;</div><div class="line">Created on Jan 09 10:39 2018</div><div class="line">@author(s): Florian U. Jehn</div><div class="line">&quot;&quot;&quot;</div><div class="line"></div><div class="line">import datetime</div><div class="line">import cmf</div><div class="line">import spotpy</div><div class="line">from spotpy.parameter import Uniform</div><div class="line">import os</div><div class="line">import numpy as np</div><div class="line">import pandas as pd</div><div class="line"></div><div class="line"></div><div class="line">class ScalingTester:</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    A class to determine how CMF handles different amounts of cells. To test</div><div class="line">    this the same model structure is run as a 1, 2, 4 and 8 cell layout. Each</div><div class="line">    cell has the same structure and parameters.</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    # Catchment area km²</div><div class="line">    area = 562.41</div><div class="line"></div><div class="line">    # General storage parameter</div><div class="line">    V0_L1 = Uniform(10, 300)</div><div class="line">    V0_L2 = Uniform(10, 300)</div><div class="line"></div><div class="line">    # ET parameter</div><div class="line">    fETV1 = Uniform(0.01, 1, doc=&#39;if V&lt;fETV1*V0, water uptake stress for &#39;</div><div class="line">                    &#39;plants starts [%]&#39;)</div><div class="line">    fETV0 = Uniform(0, 0.9, doc=&#39;if V&lt;fETV0*fETV1*V0, plants die of drought &#39;</div><div class="line">                                &#39;[%]&#39;)</div><div class="line"></div><div class="line">    # Outflow parameters</div><div class="line">    tr_L1_out = Uniform(0.1, 200, doc=&#39;Residence time of water in storage &#39;</div><div class="line">                                      &#39;when &#39;</div><div class="line">                    &#39;V=V0 [days]&#39;)</div><div class="line">    tr_L1_L2 = Uniform(0.1, 200)</div><div class="line">    tr_L2_out = Uniform(0.1, 200)</div><div class="line"></div><div class="line">    beta_L1_out = Uniform(0.5, 4, doc=&quot;Exponent for scaling the outflow[]&quot;)</div><div class="line">    beta_L1_L2 = Uniform(0.5, 4)</div><div class="line">    beta_L2_out = Uniform(0.4, 4)</div><div class="line"></div><div class="line"></div><div class="line">    # Snow parameters</div><div class="line">    snow_meltrate = Uniform(3, 10, doc=&quot;Meltrate of the snow [[(mm*degC)/day]&quot;)|    snow_melt_temp = Uniform(0, 3.5, doc=&quot;Temperature at which the snow [degC]]&quot;</div><div class="line">                             &quot;melts&quot;)</div><div class="line"></div><div class="line">    # Canopy Parameters</div><div class="line">    LAI = Uniform(1, 12, doc=&quot;Leaf Area Index&quot;)</div><div class="line">    CanopyClosure = Uniform(0.1, 0.9, doc=&quot;Closure of the Canopy [%]&quot;)</div><div class="line"></div><div class="line">    def __init__(self, begin=None, end=None, num_cells=None):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        Initializes the model.</div><div class="line"></div><div class="line">        :param begin: Start year for the calibration</div><div class="line">        :param end: Stop year</div><div class="line">        :param num_cells: Number of cells used for this layout</div><div class="line">        :return: None</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        self.dbname = &quot;scaling_tester_num_cells_&quot; + str(num_cells)</div><div class="line"></div><div class="line">        # load driver data</div><div class="line">        self.data = DataProvider(&quot;fulda_kaemmerzell_climate_79_89.csv&quot;)</div><div class="line">        # Create cells and project</div><div class="line">        self.project, self.outlet = self.create_project()</div><div class="line">        self.num_cells = num_cells</div><div class="line">        self.cells = self.create_cells()</div><div class="line"></div><div class="line">        # Add the data and set the parameters with random value, so the</div><div class="line">        # complete structure can be described.</div><div class="line">        self.data.add_stations(self.project)</div><div class="line">        self.begin = begin or self.data.begin</div><div class="line">        self.end = end or self.data.end</div><div class="line">        self.setparameters()</div><div class="line"></div><div class="line">    def create_project(self):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        Creates and CMF project with an outlet and other basic stuff and</div><div class="line">        returns it.</div><div class="line">        :return: cmf project and cmf outlet</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        # Use only a single thread, that is better for a calibration run and</div><div class="line">        # for small models</div><div class="line">        cmf.set_parallel_threads(1)</div><div class="line"></div><div class="line">        # make the project</div><div class="line">        p = cmf.project()</div><div class="line"></div><div class="line">        # make the outlet</div><div class="line">        outlet = p.NewOutlet(&quot;outlet&quot;, 10, 0, 0)</div><div class="line">        return p, outlet</div><div class="line"></div><div class="line">    def create_cells(self):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        Creates a &#39;num_cells&#39; amount of cells for the project</div><div class="line">        :return:</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        # Adjust the cellsize to the amount of cells</div><div class="line">        area = self.area / self.num_cells</div><div class="line">        # Create all the cells!</div><div class="line">        cells = []</div><div class="line">        for num in range(self.num_cells):</div><div class="line">            cells.append(CellTemplate(self.project, self.outlet, area,</div><div class="line">                                      num))</div><div class="line">        return cells</div><div class="line"></div><div class="line">    def setparameters(self, par=None):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        Sets the parameters for all cells seperately</div><div class="line">        :return:</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        # Create tje parameters</div><div class="line">        par = par or spotpy.parameter.create_set(self)</div><div class="line">        # Call all cells</div><div class="line">        for cell in self.cells:</div><div class="line">            cell.set_parameters(par)</div><div class="line"></div><div class="line">    def runmodel(self):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        Runs the models and saves the results.</div><div class="line"></div><div class="line">        :return: Simulated discharge</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        solver = cmf.CVodeIntegrator(self.project, 1e-9)</div><div class="line"></div><div class="line">        # Result timeseries</div><div class="line">        res_q = cmf.timeseries(self.begin, cmf.day)</div><div class="line"></div><div class="line">        try:</div><div class="line">            # Start solver and calculate in daily steps</div><div class="line">            for t in solver.run(self.data.begin, self.end, cmf.day):</div><div class="line">                res_q.add(self.outlet.waterbalance(t))</div><div class="line">        except RuntimeError:</div><div class="line">            return np.array(self.data.Q[</div><div class="line">                            self.data.begin:self.data.end + datetime.timedelta(</div><div class="line">                                days=1)])*np.nan</div><div class="line"></div><div class="line">        return res_q</div><div class="line"></div><div class="line">    def simulation(self, vector=None):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        Sets the parameters of the model and starts a run</div><div class="line">        :return: np.array with runoff in mm/day</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        self.setparameters(vector)</div><div class="line">        result_q = self.runmodel()</div><div class="line">        result_q /= 86400</div><div class="line">        return np.array(result_q[self.begin:self.end])</div><div class="line"></div><div class="line">    def evaluation(self):</div><div class="line">        &quot;&quot;&quot;Returns the evaluation data&quot;&quot;&quot;</div><div class="line">        return np.array(self.data.Q[self.begin:self.end])</div><div class="line"></div><div class="line">    def objectivefunction(self, simulation, evaluation):</div><div class="line">        &quot;&quot;&quot;Calculates the objective function&quot;&quot;&quot;</div><div class="line">        return spotpy.objectivefunctions.nashsutcliffe(evaluation, simulation)</div><div class="line"></div><div class="line"></div><div class="line">class CellTemplate:</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    Template, which provides</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    def __init__(self, project, outlet, area, cell_num):</div><div class="line">        self.project = project</div><div class="line">        self.outlet = outlet</div><div class="line">        self.area = area</div><div class="line">        self.cell = self.project.NewCell(cell_num, 0, 0, area * 1e6)</div><div class="line">        self.basic_set_up()</div><div class="line"></div><div class="line">    def basic_set_up(self):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        Creates the basic storages, that are to be connected in set_parameters.</div><div class="line">        :return:</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        # Add layers</div><div class="line">        self.cell.add_layer(2.0)</div><div class="line">        self.cell.add_layer(4.0)</div><div class="line">        # Install a connection for the ET</div><div class="line">        cmf.HargreaveET(self.cell.layers[0], self.cell.transpiration)</div><div class="line">        # Add Snow</div><div class="line">        self.cell.add_storage(&quot;Snow&quot;, &quot;S&quot;)</div><div class="line">        cmf.Snowfall(self.cell.snow, self.cell)</div><div class="line">        # Create a storage for Interception</div><div class="line">        self.cell.add_storage(&quot;Canopy&quot;, &quot;C&quot;)</div><div class="line"></div><div class="line">    def set_parameters(self, par):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        Sets the parameters for a cell instance</div><div class="line">        :param par: Object with all parameters</div><div class="line">        :return: None</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        c = self.cell</div><div class="line">        out = self.outlet</div><div class="line"></div><div class="line">        # Scale to the cellsize</div><div class="line">        V0_L1 = (par.V0_L1 / 1000) * self.area * 1e6</div><div class="line">        V0_L2 = (par.V0_L2 / 1000) * self.area * 1e6</div><div class="line"></div><div class="line">        # Set uptake stress</div><div class="line">        ETV1 = par.fETV1 * V0_L1</div><div class="line">        ETV0 = par.fETV0 * ETV1</div><div class="line">        c.set_uptakestress(cmf.VolumeStress(ETV1, ETV0))</div><div class="line"></div><div class="line">        # Connect layer and outlet</div><div class="line">        cmf.PowerLawConnection(c.layers[0], out, Q0=V0_L1 / par.tr_L1_out,</div><div class="line">                               V0=V0_L1,</div><div class="line">                               beta=par.beta_L1_out)</div><div class="line"></div><div class="line">        cmf.PowerLawConnection(c.layers[[0],|c.layers[1]], Q0=(V0_L1 /</div><div class="line">                                                            par.tr_L1_L2),</div><div class="line">                               V0=V0_L1, beta=par.beta_L1_L2)</div><div class="line">        cmf.PowerLawConnection(c.layers[1], out, Q0=V0_L2 / par.tr_L2_out,</div><div class="line">                               V0=V0_L2,</div><div class="line">                               beta=par.beta_L2_out)</div><div class="line"></div><div class="line">        # Snow</div><div class="line">        cmf.SimpleTindexSnowMelt(c.snow, c.layers[0], c,</div><div class="line">                                 rate=par.snow_meltrate)</div><div class="line">        cmf.Weather.set_snow_threshold(par.snow_melt_temp)</div><div class="line"></div><div class="line">        # Split the rainfall in interception and throughfall</div><div class="line">        cmf.Rainfall(c.canopy, c, False, True)</div><div class="line">        cmf.Rainfall(c.surfacewater, c, True, False)</div><div class="line"></div><div class="line">        # Make an overflow for the interception storage</div><div class="line">        cmf.RutterInterception(c.canopy, c.surfacewater, c)</div><div class="line"></div><div class="line">        # Transpiration from the plants is added</div><div class="line">        cmf.CanopyStorageEvaporation(c.canopy, c.evaporation, c)</div><div class="line"></div><div class="line">        # Sets the paramaters for interception</div><div class="line">        c.vegetation.LAI = par.LAI</div><div class="line"></div><div class="line">        # Defines how much throughfall there is (in %)</div><div class="line">        c.vegetation.CanopyClosure = par.CanopyClosure</div><div class="line"></div><div class="line"></div><div class="line">class DataProvider:</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    Holds the forcing and calibration data</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    def __init__(self, file_name):</div><div class="line">        # Load data from file using numpy magic</div><div class="line">        data = pd.read_csv(file_name, encoding=&quot;ISO-8859-1&quot;, sep=&quot;;&quot;)</div><div class="line">        # Delete first row, as it only contains the units</div><div class="line">        data = data.iloc[1:]</div><div class="line">        data = data.dropna(axis=0)</div><div class="line"></div><div class="line">        def bstr2date(bs):</div><div class="line">            &quot;&quot;&quot;</div><div class="line">            Helper function to convert date byte string to datetime object</div><div class="line">            &quot;&quot;&quot;</div><div class="line">            return datetime.datetime.strptime(bs, &#39;%d.%m.%Y&#39;)</div><div class="line"></div><div class="line">        # Get begin, step and end from the date column</div><div class="line">        self.begin = bstr2date(data[[&quot;date&quot;].iloc[0])|        self.step = bstr2date(data[&quot;date&quot;]].iloc[1]) - self.begin</div><div class="line">        self.end = bstr2date(data[&quot;date&quot;].iloc[-1])</div><div class="line"></div><div class="line">        # Read in the data</div><div class="line">        self.P = cmf.timeseries.from_sequence(self.begin, self.step,</div><div class="line">                                              data[&quot;Prec&quot;])</div><div class="line">        self.T = cmf.timeseries.from_sequence(self.begin, self.step,</div><div class="line">                                              data[&quot;tmean&quot;])</div><div class="line">        self.Tmin = cmf.timeseries.from_sequence(self.begin, self.step,</div><div class="line">                                                 data[&quot;tmin&quot;])</div><div class="line">        self.Tmax = cmf.timeseries.from_sequence(self.begin, self.step,</div><div class="line">                                                 data[&quot;tmax&quot;])</div><div class="line">        self.Q = cmf.timeseries.from_sequence(self.begin, self.step,</div><div class="line">                                              data[&quot;Q&quot;])</div><div class="line"></div><div class="line">    def add_stations(self, project):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        Creates a rainstation and a meteo station for the cmf project</div><div class="line">        :param project: A cmf.project</div><div class="line">        :return: rainstation, meteo</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        rainstation = project.rainfall_stations.add(&#39;Kaemmerzell avg&#39;, self.P,</div><div class="line">                                                    (0, 0, 0))</div><div class="line"></div><div class="line">        project.use_nearest_rainfall()</div><div class="line"></div><div class="line">        # Temperature data</div><div class="line">        meteo = project.meteo_stations.add_station(&#39;Kaemmerzell avg&#39;,</div><div class="line">                                                   (0, 0, 0))</div><div class="line">        meteo.T = self.T</div><div class="line">        meteo.Tmin = self.Tmin</div><div class="line">        meteo.Tmax = self.Tmax</div><div class="line"></div><div class="line">        project.use_nearest_meteo()</div><div class="line">        return rainstation, meteo</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &#39;__main__&#39;:</div><div class="line">    # Get sampler</div><div class="line">    from spotpy.algorithms import lhs as Sampler</div><div class="line"></div><div class="line">    # Check if we are running on a supercomputer or local</div><div class="line">    parallel = &#39;mpi&#39; if &#39;OMPI_COMM_WORLD_SIZE&#39; in os.environ else &#39;seq&#39;</div><div class="line"></div><div class="line">    # Run the models</div><div class="line">    runs = 100</div><div class="line">    num_cells = [[1,|2, 4, 8]]</div><div class="line">    results = {}</div><div class="line">    for num in num_cells:</div><div class="line">        # Create the model</div><div class="line">        model = ScalingTester(num_cells=num)</div><div class="line">        print(cmf.describe(model.project))</div><div class="line">        # Create the sampler</div><div class="line">        sampler = Sampler(model, parallel=parallel, dbname=model.dbname,</div><div class="line">                          dbformat=&#39;csv&#39;, save_sim=False)</div><div class="line"></div><div class="line">        sampler.sample(runs)</div><div class="line">        results[str(num)] = sampler.status.objectivefunction</div><div class="line"></div><div class="line">    for key, value in results.items():</div><div class="line">        print(&quot;The model with {} cell(s) has a best NS of {}&quot;.format(</div><div class="line">                                                                    key,</div><div class="line">                                                                    value))</div></div><!-- fragment --><p>author: florianjehn, version: 4 Fri Jan 12 14:02:19 2018 </p>
</div></div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
<div>&copy 2008-2017 by 
<a class="el" href="http://www.uni-giessen.de/hydro/kraft"> Philipp Kraft</a> and
<a class="el" href="http://www.uni-giessen.de/hydro"> 
Institute of Landscape Ecology and Resources Management,University of Gie&szlig;en</a>
</h3></td>
<td>Generated: Fri Apr 6 2018 11:42:05</td>
</tr></table>
</small></address>
</body>
</html>
