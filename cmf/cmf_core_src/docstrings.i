
// File: index.xml

// File: classcmf__core_1_1_adsorption.xml
%feature("docstring") cmf_core::Adsorption "

Abstract class to use adsorption process for tracers on surfaces.  Use
the derived classes to use a certain isotherm  C++ includes:
adsorption.h ";

%feature("docstring")  cmf_core::Adsorption::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::Adsorption::copy "def copy(self,
args, kwargs)

copy(Adsorption self, real m=-1) -> Adsorption  virtual Adsorption*
copy(real m=-1) const =0  returns a copy of the Adsorption object.  If
the adsorption is depending on the sorbent mass, you can give a
positive value for the sorbent mass m. If the value is not given or
negative, m is used from the original object. ";

%feature("docstring")  cmf_core::Adsorption::freesolute "def
freesolute(self, args, kwargs)

freesolute(Adsorption self, real xt, real V) -> real  virtual real
freesolute(real xt, real V) const =0  Returns the mass of dissolved
tracer as a function of the total tracer mass in the solute storage
and the water volume.  Parameters: -----------  xt:   :math:`x_t` the
total tracer mass in the storage  V:   :math:`V m^3` the water volume
in the storage  :math:`x_f` the dissolved mass of the tracer ";

%feature("docstring")  cmf_core::Adsorption::totalsolute "def
totalsolute(self, args, kwargs)

totalsolute(Adsorption self, real xf, real V) -> real  virtual real
totalsolute(real xf, real V) const =0  Returns the total mass of the
tracer from the dissolved concetration in tracer unit/m3.  Parameters:
-----------  xf:   :math:`x_f` the dissolved tracer mass in the
storage  V:   :math:`V m^3` the water volume in the storage
:math:`x_t` the total mass of the tracer ";


// File: classcmf_1_1water_1_1_adsorption.xml
%feature("docstring") cmf::water::Adsorption "

Abstract class to use adsorption process for tracers on surfaces.

Use the derived classes to use a certain isotherm

C++ includes: adsorption.h ";

%feature("docstring")  cmf::water::Adsorption::~Adsorption "virtual
~Adsorption() ";

%feature("docstring")  cmf::water::Adsorption::copy "virtual
Adsorption* copy(real m=-1) const =0

returns a copy of the Adsorption object.

If the adsorption is depending on the sorbent mass, you can give a
positive value for the sorbent mass m. If the value is not given or
negative, m is used from the original object. ";

%feature("docstring")  cmf::water::Adsorption::freesolute "virtual
real freesolute(real xt, real V) const =0

Returns the mass of dissolved tracer as a function of the total tracer
mass in the solute storage and the water volume.

Parameters:
-----------

xt:   :math:`x_t` the total tracer mass in the storage

V:   :math:`V m^3` the water volume in the storage

:math:`x_f` the dissolved mass of the tracer ";

%feature("docstring")  cmf::water::Adsorption::totalsolute "virtual
real totalsolute(real xf, real V) const =0

Returns the total mass of the tracer from the dissolved concetration
in tracer unit/m3.

Parameters:
-----------

xf:   :math:`x_f` the dissolved tracer mass in the storage

V:   :math:`V m^3` the water volume in the storage

:math:`x_t` the total mass of the tracer ";


// File: classcmf_1_1atmosphere_1_1aerodynamic__resistance.xml
%feature("docstring") cmf::atmosphere::aerodynamic_resistance "

Abstract class. Child classes can be used to calculate aerodynamic
resistances against turbulent heat fluxes.

C++ includes: meteorology.h ";

%feature("docstring")
cmf::atmosphere::aerodynamic_resistance::~aerodynamic_resistance "virtual ~aerodynamic_resistance() ";

%feature("docstring")
cmf::atmosphere::aerodynamic_resistance::get_aerodynamic_resistance "virtual void get_aerodynamic_resistance(double &r_ag, double &r_ac,
cmf::math::Time t) const =0

aerodynamic resistance from ground to atmosphere (r_ag) and from
canopy to atmosphere (r_ac) ";


// File: classcmf__core_1_1aerodynamic__resistance.xml
%feature("docstring") cmf_core::aerodynamic_resistance "

Abstract class. Child classes can be used to calculate aerodynamic
resistances against turbulent heat fluxes.  C++ includes:
meteorology.h ";

%feature("docstring")  cmf_core::aerodynamic_resistance::__init__ "def __init__(self, args, kwargs) ";

%feature("docstring")
cmf_core::aerodynamic_resistance::get_aerodynamic_resistance "def
get_aerodynamic_resistance(self, args, kwargs)

get_aerodynamic_resistance(aerodynamic_resistance self, double & r_ag,
double & r_ac, Time t)  virtual void get_aerodynamic_resistance(double
&r_ag, double &r_ac, cmf::math::Time t) const =0  aerodynamic
resistance from ground to atmosphere (r_ag) and from canopy to
atmosphere (r_ac) ";


// File: classcmf_1_1draw_1_1cellmap_1_1_animator.xml
%feature("docstring") cmf::draw::cellmap::Animator "";

%feature("docstring")  cmf::draw::cellmap::Animator::__init__ "def
__init__(self, cells, solver, start, end, step)

:param cells: A sequence of cmf Cells, can be a project :param solver:
A cmf solver Eg. cmf.CVodeDense() :param start: Start time :param end:
End time :param step: Time step ";

%feature("docstring")  cmf::draw::cellmap::Animator::__call__ "def
__call__(self, args, kwargs) ";

%feature("docstring")  cmf::draw::cellmap::Animator::draw "def
draw(self, frame=None) ";


// File: classcmf__core_1_1aquifer.xml
%feature("docstring") cmf_core::aquifer "

A class to represent large groundwater storages, not bounded to the
usual horizontal discretization scheme, the Cell.  Naturally aquifers
are connected with aquifer_Darcy or kinematic_wave connections. As a
boundary condition for a cell based soil water system, aquifers are
used as a right hand side node of percolation connections.  Basic head
( :math:`\\\\\\\\Psi`) / volume ( :math:`V`) relation:   .. math::
\\\\\\\\Psi =     z_{base} + \\\\\\\\frac {V}{A \\\\\\\\Phi}
:math:`\\\\\\\\Psi` water head in m  :math:`z_{base}` base height of
the aquifer  :math:`V` volume of stored water in m3  :math:`A` Base
area of the aquifer in m2  :math:`\\\\\\\\Phi` Porosity, or more
general, :math:`\\\\\\\\frac{dV_{bulk}}{dV_{H_2O}}`  C++ includes:
groundwater.h ";

%feature("docstring")  cmf_core::aquifer::__init__ "def
__init__(self, args)

__init__(cmf::upslope::aquifer self, project p, point position, real
area, real thickness, real porosity, real K=1e-4) -> aquifer
__init__(cmf::upslope::aquifer self, cell_vector cells, real
thickness, real porosity, real K=1e-4) -> aquifer
aquifer(cmf::upslope::cell_vector &cells, real thickness, real
porosity, real K=1e-4)  Creates an aquifer below a collection of
cells.  Parameters: -----------  cells:  The cells above the aquifer.
The area of the aquifer equals the area of the cells, and the upper
boundary equals the soildepth of the lowest cell  thickness:  The
thickness of the aquifer in m  porosity:  Porosity of the aquifer  K:
Conductivity of the aquifer in m/day. If the conductivity should be
anisotropic, change the x,y and z values of the member K ";

%feature("docstring")  cmf_core::aquifer::__call__ "def
__call__(self, args, kwargs)

__call__(flux_node self, Time t) -> real ";

%feature("docstring")  cmf_core::aquifer::__eq__ "def __eq__(self,
args, kwargs)

__eq__(flux_node self, flux_node other) -> bool ";

%feature("docstring")  cmf_core::aquifer::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(WaterStorage self, solute X) -> SoluteStorage ";

%feature("docstring")  cmf_core::aquifer::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::aquifer::cast "def cast(args,
kwargs)

cast(cmf::water::flux_node::ptr for_cast) ->
cmf::upslope::aquifer::ptr ";

%feature("docstring")  cmf_core::aquifer::conc "def conc(self, args,
kwargs)

conc(flux_node self, Time t, solute Solute) -> real  virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const
Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf_core::aquifer::conc "def conc(self, args)

conc(WaterStorage self, solute _Solute) -> real conc(WaterStorage
self, Time t, solute _Solute) -> real conc(WaterStorage self, solute
_Solute, real NewConcetration)  void conc(const cmf::water::solute
&_Solute, real NewConcetration)  Sets a new concentration. ";

%feature("docstring")  cmf_core::aquifer::connected_nodes "def
connected_nodes(self) ";

%feature("docstring")  cmf_core::aquifer::connection_to "def
connection_to(self, args, kwargs)

connection_to(flux_node self, flux_node target) -> flux_connection
cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)  Returns the connection between this and target. ";

%feature("docstring")  cmf_core::aquifer::create "def create(args,
kwargs)

create(project _project, real initial_state=0.0, real scale=1.0) ->
std::shared_ptr< cmf::water::WaterStorage > ";

%feature("docstring")  cmf_core::aquifer::dxdt "def dxdt(self, args,
kwargs)

dxdt(StateVariable self, Time time) -> real  virtual real dxdt(const
cmf::math::Time &time)=0  Returns the derivate of the state variable
at time time. ";

%feature("docstring")  cmf_core::aquifer::flux3d_to "def
flux3d_to(self, args, kwargs)

flux3d_to(flux_node self, flux_node target, Time t) -> point
cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf_core::aquifer::flux_to "def flux_to(self,
args, kwargs)

flux_to(flux_node self, flux_node target, Time t) -> real  real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)
Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf_core::aquifer::fluxes "def fluxes(self, t)
";

%feature("docstring")  cmf_core::aquifer::from_node "def
from_node(args, kwargs)

from_node(cmf::water::flux_node::ptr node) -> std::shared_ptr<
cmf::water::WaterStorage > ";

%feature("docstring")  cmf_core::aquifer::get_3d_flux "def
get_3d_flux(self, args, kwargs)

get_3d_flux(flux_node self, Time t) -> point  cmf::geometry::point
get_3d_flux(cmf::math::Time t)  Returns the sum of all flux vectors.
";

%feature("docstring")  cmf_core::aquifer::get_abs_errtol "def
get_abs_errtol(self, args, kwargs)

get_abs_errtol(aquifer self, real rel_errtol) -> real  virtual real
get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf_core::aquifer::get_K "def get_K(self,
args, kwargs)

get_K(aquifer self, point direction) -> real  virtual real
get_K(cmf::geometry::point direction) const  Returns the conductivity
in m/day for a specific direction.  Takes account for anisotropy   ..
math::       \\\\\\\\|K\\\\\\\\|(d) =
\\\\\\\\frac{d}{\\\\\\\\|d\\\\\\\\|} \\\\\\\\bullet K ";

%feature("docstring")  cmf_core::aquifer::get_states "def
get_states(self, args, kwargs)

get_states(StateVariableOwner self) -> StateVariableList  virtual
StateVariableList get_states()=0  Add the state variables, owned by an
object derived from StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf_core::aquifer::is_connected "def
is_connected(self, args, kwargs)

is_connected(StateVariable self, StateVariable other) -> bool  virtual
bool is_connected(const cmf::math::StateVariable &other) const ";

%feature("docstring")  cmf_core::aquifer::is_empty "def
is_empty(self, args, kwargs)

is_empty(flux_node self) -> double  virtual double is_empty() const
Returns true if the node has no water. ";

%feature("docstring")  cmf_core::aquifer::is_storage "def
is_storage(self, args, kwargs)

is_storage(flux_node self) -> bool  virtual bool is_storage() const
true, if this is a waterstorage ";

%feature("docstring")  cmf_core::aquifer::RecalcFluxes "def
RecalcFluxes(self, args, kwargs)

RecalcFluxes(flux_node self, Time t) -> bool  virtual bool
RecalcFluxes(cmf::math::Time t)  Pure flux_nodes do not influence
fluxes, therefore no recalculation of fluxes is required by flux_node.
WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf_core::aquifer::remove_connection "def
remove_connection(self, args, kwargs)

remove_connection(flux_node self, cmf::water::flux_node::ptr To) ->
bool  bool remove_connection(cmf::water::flux_node::ptr To)  Remove
the connection. ";

%feature("docstring")  cmf_core::aquifer::Solute "def Solute(self,
args)

Solute(WaterStorage self, solute _Solute) -> SoluteStorage
Solute(WaterStorage self, solute _Solute) -> SoluteStorage  const
SoluteStorage& Solute(const cmf::water::solute _Solute) const ";

%feature("docstring")  cmf_core::aquifer::to_string "def
to_string(self, args, kwargs)

to_string(StateVariable self) -> std::string  virtual std::string
to_string() const =0 ";

%feature("docstring")  cmf_core::aquifer::to_string "def
to_string(self, args, kwargs)

to_string(flux_node self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::aquifer::waterbalance "def
waterbalance(self, args, kwargs)

waterbalance(flux_node self, Time t, flux_connection Without=None) ->
real  real waterbalance(cmf::math::Time t, const flux_connection
*Without=0) const  Returns the sum of all fluxes (positive and
negative) at time t.  Single fluxes can be excluded from the
calculation  Parameters: -----------  t:  Time of the query  Without:
A flux_connection that is excluded from the waterbalance (e.g. to
prevent closed circuits) ";


// File: classcmf_1_1upslope_1_1aquifer.xml
%feature("docstring") cmf::upslope::aquifer "

A class to represent large groundwater storages, not bounded to the
usual horizontal discretization scheme, the Cell.

Naturally aquifers are connected with aquifer_Darcy or kinematic_wave
connections. As a boundary condition for a cell based soil water
system, aquifers are used as a right hand side node of percolation
connections.

Basic head ( :math:`\\\\Psi`) / volume ( :math:`V`) relation: 

.. math::

     \\\\Psi =
    z_{base} + \\\\frac {V}{A \\\\Phi} 

:math:`\\\\Psi` water head in m

:math:`z_{base}` base height of the aquifer

:math:`V` volume of stored water in m3

:math:`A` Base area of the aquifer in m2

:math:`\\\\Phi` Porosity, or more general, :math:`\\\\frac{dV_{bulk}}{dV_{H_2O}}`

C++ includes: groundwater.h ";

/*  Overrides of flux_node  */

%feature("docstring")  cmf::upslope::aquifer::RecalcFluxes "virtual
bool RecalcFluxes(cmf::math::Time t)

Pure flux_nodes do not influence fluxes, therefore no recalculation of
fluxes is required by flux_node.

WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf::upslope::aquifer::is_empty "virtual
double is_empty() const

Returns true if the node has no water. ";

%feature("docstring")  cmf::upslope::aquifer::to_string "virtual
std::string to_string() const ";

%feature("docstring")  cmf::upslope::aquifer::aquifer "aquifer(cmf::project &p, cmf::geometry::point position, real area,
real thickness, real porosity, real K=1e-4)

Creates an aquifer at a certain position.

Parameters:
-----------

p:  Project, this aquifer belongs to

position:  Position of the aquifer center (x and y) and the aquifer
top (z)

area:  Area of the aquifer

thickness:  Mean thickness of the aquifer in m

porosity:  Mean porositiy of the aquifer

K:  Conductivity of the aquifer in m/day. If the conductivity should
be anisotropic, change the x,y and z values of the member K ";

%feature("docstring")  cmf::upslope::aquifer::aquifer "aquifer(cmf::upslope::cell_vector &cells, real thickness, real
porosity, real K=1e-4)

Creates an aquifer below a collection of cells.

Parameters:
-----------

cells:  The cells above the aquifer. The area of the aquifer equals
the area of the cells, and the upper boundary equals the soildepth of
the lowest cell

thickness:  The thickness of the aquifer in m

porosity:  Porosity of the aquifer

K:  Conductivity of the aquifer in m/day. If the conductivity should
be anisotropic, change the x,y and z values of the member K ";

%feature("docstring")  cmf::upslope::aquifer::add_connected_states "virtual void add_connected_states(cmf::math::StateVariable::list
&states) ";

%feature("docstring")  cmf::upslope::aquifer::conc "real conc(const
cmf::water::solute &_Solute) const

Returns the concentration of the given solute. ";

%feature("docstring")  cmf::upslope::aquifer::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute) const

Returns the current WaterQuality (concentration of all solutes) ";

%feature("docstring")  cmf::upslope::aquifer::conc "void conc(const
cmf::water::solute &_Solute, real NewConcetration)

Sets a new concentration. ";

%feature("docstring")  cmf::upslope::aquifer::connection_to "cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::upslope::aquifer::dxdt "virtual real
dxdt(const cmf::math::Time &time) ";

%feature("docstring")  cmf::upslope::aquifer::flux3d_to "cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf::upslope::aquifer::flux_to "real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf::upslope::aquifer::get_3d_flux "cmf::geometry::point get_3d_flux(cmf::math::Time t)

Returns the sum of all flux vectors. ";

%feature("docstring")  cmf::upslope::aquifer::get_abs_errtol "virtual
real get_abs_errtol(real rel_errtol) ";

%feature("docstring")  cmf::upslope::aquifer::get_abs_errtol "virtual
real get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf::upslope::aquifer::get_base_height "real
get_base_height() const

Returns the base height of the aquifer in m a.s.l. ";

%feature("docstring")  cmf::upslope::aquifer::get_connections "cmf::water::connection_list get_connections() const ";

%feature("docstring")  cmf::upslope::aquifer::get_K "virtual real
get_K(cmf::geometry::point direction) const

Returns the conductivity in m/day for a specific direction.

Takes account for anisotropy 

.. math::

     \\\\|K\\\\|(d) =
    \\\\frac{d}{\\\\|d\\\\|} \\\\bullet K

";

%feature("docstring")  cmf::upslope::aquifer::get_potential "virtual
real get_potential() const

Returns the water potential of the node in m waterhead.

The base class water storage always returns the height of the location
";

%feature("docstring")  cmf::upslope::aquifer::get_project "cmf::project& get_project() const

Returns the project, this node is part of. ";

%feature("docstring")  cmf::upslope::aquifer::get_state "real
get_state() const ";

%feature("docstring")
cmf::upslope::aquifer::get_state_variable_content "char
get_state_variable_content() const

A character indicating the integrated variable (either 'V' for Volume
or 'h' for head) ";

%feature("docstring")  cmf::upslope::aquifer::get_states "cmf::math::StateVariableList get_states()

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf::upslope::aquifer::get_top_height "real
get_top_height() const

Returns the top height of the aquifer in m a.s.l. ";

%feature("docstring")  cmf::upslope::aquifer::get_volume "virtual
real get_volume() const

Returns the volume of water in this storage in m3 ";

%feature("docstring")  cmf::upslope::aquifer::is_connected "virtual
bool is_connected(const cmf::math::StateVariable &other) const

Returns True if this waterstorage is effected by another state. ";

%feature("docstring")  cmf::upslope::aquifer::is_storage "virtual
bool is_storage() const

Returns true, since this is a storage. ";

%feature("docstring")  cmf::upslope::aquifer::remove_connection "bool
remove_connection(cmf::water::flux_node::ptr To)

Remove the connection. ";

%feature("docstring")  cmf::upslope::aquifer::set_potential "virtual
void set_potential(real new_potential)

Sets the potential of this flux node. ";

%feature("docstring")  cmf::upslope::aquifer::set_state "void
set_state(real newState) ";

%feature("docstring")
cmf::upslope::aquifer::set_state_variable_content "void
set_state_variable_content(char content)

A character indicating the integrated variable (either 'V' for Volume
or 'h' for head) ";

%feature("docstring")  cmf::upslope::aquifer::set_volume "virtual
void set_volume(real newwatercontent)

Sets the volume of water in this storage in m3 ";

%feature("docstring")  cmf::upslope::aquifer::Solute "SoluteStorage&
Solute(const cmf::water::solute _Solute)

Returns the water quality of the water storage. ";

%feature("docstring")  cmf::upslope::aquifer::Solute "const
SoluteStorage& Solute(const cmf::water::solute _Solute) const ";

%feature("docstring")  cmf::upslope::aquifer::waterbalance "real
waterbalance(cmf::math::Time t, const flux_connection *Without=0)
const

Returns the sum of all fluxes (positive and negative) at time t.

Single fluxes can be excluded from the calculation

Parameters:
-----------

t:  Time of the query

Without:  A flux_connection that is excluded from the waterbalance
(e.g. to prevent closed circuits) ";


// File: classcmf__core_1_1aquifer___darcy.xml
%feature("docstring") cmf_core::aquifer_Darcy "

Lateral darcy flow between aquifer objects.    .. math::
v_{Darcy}=K_{1,2}\\\\\\\\nabla\\\\\\\\Psi     .. math::      q =
v_{Darcy} w     \\\\\\\\Delta z  C++ includes: groundwater.h ";

%feature("docstring")  cmf_core::aquifer_Darcy::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::aquifer_Darcy self, cmf::upslope::aquifer::ptr
left, cmf::water::flux_node::ptr right, real width) -> aquifer_Darcy
aquifer_Darcy(aquifer::ptr left, cmf::water::flux_node::ptr right,
real width)  Creates a new Darcy flow connection between two aquifers,
or an aquifer and another node acting as Dirichlet boundary condition.
Parameters: -----------  left:  One aquifer  right:  Another aquifer,
or a flux node that can be interpreted as an Dirichlet boundary width:
Width of the connection ";

%feature("docstring")  cmf_core::aquifer_Darcy::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::aquifer_Darcy::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::aquifer_Darcy::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::aquifer_Darcy::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::aquifer_Darcy::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::aquifer_Darcy::conc "def conc(self,
args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::aquifer_Darcy::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::aquifer_Darcy::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::aquifer_Darcy::get_tracer_filter "def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::aquifer_Darcy::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::aquifer_Darcy::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::aquifer_Darcy::q "def q(self, args,
kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::aquifer_Darcy::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::aquifer_Darcy::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::aquifer_Darcy::set_tracer_filter "def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::aquifer_Darcy::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::aquifer_Darcy::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1aquifer___darcy.xml
%feature("docstring") cmf::upslope::aquifer_Darcy "

Lateral darcy flow between aquifer objects.



.. math::

    v_{Darcy}=K_{1,2}\\\\nabla\\\\Psi 



.. math::

    q = v_{Darcy} w
    \\\\Delta z

C++ includes: groundwater.h ";

%feature("docstring")  cmf::upslope::aquifer_Darcy::aquifer_Darcy "aquifer_Darcy(aquifer::ptr left, cmf::water::flux_node::ptr right,
real width)

Creates a new Darcy flow connection between two aquifers, or an
aquifer and another node acting as Dirichlet boundary condition.

Parameters:
-----------

left:  One aquifer

right:  Another aquifer, or a flux node that can be interpreted as an
Dirichlet boundary

width:  Width of the connection ";

%feature("docstring")  cmf::upslope::aquifer_Darcy::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")  cmf::upslope::aquifer_Darcy::exchange_target "void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")  cmf::upslope::aquifer_Darcy::get_ptr "ptr
get_ptr() const ";

%feature("docstring")  cmf::upslope::aquifer_Darcy::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::aquifer_Darcy::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")  cmf::upslope::aquifer_Darcy::get_tracer_filter
"real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")  cmf::upslope::aquifer_Darcy::get_tracer_filter
"real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::aquifer_Darcy::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::upslope::aquifer_Darcy::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::aquifer_Darcy::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::aquifer_Darcy::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::upslope::aquifer_Darcy::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")  cmf::upslope::aquifer_Darcy::set_tracer_filter
"void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")  cmf::upslope::aquifer_Darcy::set_tracer_filter
"void set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf::upslope::aquifer_Darcy::short_string "virtual std::string short_string() const ";

%feature("docstring")  cmf::upslope::aquifer_Darcy::to_string "virtual std::string to_string() const ";


// File: classcmf_1_1upslope_1_1connections_1_1_base_macro_flow.xml
%feature("docstring") cmf::upslope::connections::BaseMacroFlow "";

%feature("docstring")  cmf::upslope::connections::BaseMacroFlow::conc
"real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::BaseMacroFlow::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::upslope::connections::BaseMacroFlow::get_ptr "ptr get_ptr()
const ";

%feature("docstring")
cmf::upslope::connections::BaseMacroFlow::get_target "flux_node::ptr
get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::BaseMacroFlow::get_target "flux_node::ptr
get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::BaseMacroFlow::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::BaseMacroFlow::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::BaseMacroFlow::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::BaseMacroFlow::left_node "flux_node::ptr
left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::connections::BaseMacroFlow::q "real q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::BaseMacroFlow::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::BaseMacroFlow::right_node "flux_node::ptr
right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::BaseMacroFlow::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::BaseMacroFlow::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::BaseMacroFlow::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::BaseMacroFlow::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_base_macro_flow.xml
%feature("docstring") cmf_core::BaseMacroFlow "

Proxy of C++ cmf::upslope::connections::BaseMacroFlow class. ";

%feature("docstring")  cmf_core::BaseMacroFlow::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::BaseMacroFlow::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::BaseMacroFlow::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::BaseMacroFlow::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::BaseMacroFlow::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::BaseMacroFlow::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::BaseMacroFlow::conc "def conc(self,
args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::BaseMacroFlow::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::BaseMacroFlow::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::BaseMacroFlow::get_tracer_filter "def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::BaseMacroFlow::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::BaseMacroFlow::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::BaseMacroFlow::q "def q(self, args,
kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::BaseMacroFlow::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::BaseMacroFlow::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::BaseMacroFlow::set_tracer_filter "def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::BaseMacroFlow::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::BaseMacroFlow::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf__core_1_1_b_d_f2.xml
%feature("docstring") cmf_core::BDF2 "

An order 2 BDF-Method with fixed-point iteration and variable step
size.  Derived from Roussel C. and Roussel M. (2003) \"Generic Object-
Oriented Differential Equation Integrators\", C/C++ User Journal, Nov.
2003,http://www.ddj.com/cpp/184401724?pgno=8 and  Eckert S., Baaser
H., Gross D. and Scherf O. (2004) \"A BDF2 integration method with
step size control for elasto-plasticity\", Computational Mechanics 34,
377 - 386, DOI: 10.1007/s00466-004-0581-1  Most important function:
Integrate  C++ includes: bdf2.h ";

%feature("docstring")  cmf_core::BDF2::__init__ "def __init__(self,
args)

__init__(cmf::math::BDF2 self, real epsilon=1e-9, Time tStepMin) ->
BDF2 __init__(cmf::math::BDF2 self, StateVariableOwner states, real
epsilon=1e-9, Time tStepMin) -> BDF2 __init__(cmf::math::BDF2 self,
Integrator templ) -> BDF2  BDF2(const Integrator &templ)  Constructs a
new BDF2 integrator.  Parameters: -----------  templ:  Template to be
used to construct a BDF2 method ";

%feature("docstring")  cmf_core::BDF2::__call__ "def __call__(self,
t, dt=None, reset=False)

Advances the integration until `t`  A shortcut to .integrate_until
Parameters ---------- t : cmf.Time     The time step to advance to. If
t < current time, the solver will     advance to self.t + t dt :
cmf.Time, optional     The timestep for the integration. If not given
try to integrate in one step reset : bool, optional     If True, the
solver will perform a reset before starting  Returns ------- cmf.Time
The new time stamp ";

%feature("docstring")  cmf_core::BDF2::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(Integrator self, long position) ->
cmf::math::StateVariable::ptr ";

%feature("docstring")  cmf_core::BDF2::__len__ "def __len__(self,
args, kwargs)

__len__(Integrator self) -> size_t ";

%feature("docstring")  cmf_core::BDF2::__repr__ "def __repr__(self)
";

%feature("docstring")  cmf_core::BDF2::add_single_state "def
add_single_state(self, args, kwargs)

add_single_state(Integrator self, cmf::math::StateVariable::ptr state)
virtual void add_single_state(cmf::math::StateVariable::ptr state)
Adds a single state variable to the integrator. ";

%feature("docstring")  cmf_core::BDF2::add_states "def
add_states(self, args, kwargs)

add_states(Integrator self, StateVariableOwner stateOwner)  virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)  Add state
variables from a StateVariableOwner. ";

%feature("docstring")  cmf_core::BDF2::copy "def copy(self, args,
kwargs)

copy(Integrator self) -> Integrator  virtual Integrator* copy() const
=0  Polymorphic copy constructor. ";

%feature("docstring")  cmf_core::BDF2::get_dt "def get_dt(self, args,
kwargs)

get_dt(Integrator self) -> Time  cmf::math::Time get_dt() const
Returns the last time step. ";

%feature("docstring")  cmf_core::BDF2::get_dxdt "def get_dxdt(self,
args, kwargs)

get_dxdt(Integrator self, Time time) -> cmf::math::num_array
cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf_core::BDF2::get_error_position "def
get_error_position(self, args, kwargs)

get_error_position(BDF2 self) -> int  int get_error_position() const
Returns the position of the biggest error. ";

%feature("docstring")  cmf_core::BDF2::get_state "def get_state(self,
args, kwargs)

get_state(Integrator self, ptrdiff_t position) -> real  real
get_state(ptrdiff_t position) const  Returns the statevariable at
position Simplifies the assessment of state variables. ";

%feature("docstring")  cmf_core::BDF2::get_states "def
get_states(self, args)

get_states(Integrator self) -> cmf::math::num_array
get_states(Integrator self) -> StateVariableList  StateVariableList
get_states()  gets the state variables of the integrator ";

%feature("docstring")  cmf_core::BDF2::get_t "def get_t(self, args,
kwargs)

get_t(Integrator self) -> Time  cmf::math::Time get_t() const  Returns
the current model time. ";

%feature("docstring")  cmf_core::BDF2::integrate "def integrate(self,
args, kwargs)

integrate(Integrator self, Time t_max, Time dt) -> int  virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)=0  Integrates the
vector of state variables.  Parameters: -----------  t_max:  To stop
the model (if running in a model framework) at time steps of value
exchange e.g. full hours, the next value exchange time can be given
dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf_core::BDF2::integrate_until "def
integrate_until(self, args, kwargs)

integrate_until(Integrator self, Time t_max, Time dt, bool
reset=False)  void integrate_until(cmf::math::Time t_max,
cmf::math::Time dt=Time(), bool reset=false)  Integrates the vector of
state variables until t_max.  Parameters: -----------  t_max:   Time,
the solver should run to  dt:   Time step (may be omitted)  reset:  If
true, solver is reseted before integration starts ";

%feature("docstring")  cmf_core::BDF2::reset "def reset(self, args,
kwargs)

reset(Integrator self)  virtual void reset()  Resets any saved history
(for multistep methods) ";

%feature("docstring")  cmf_core::BDF2::run "def run(self, start=None,
end=None, step=day *1, max_errors=0, reset=False)

Returns an iterator over the timesteps start..end  **Examples:**  >>>
solver=cmf.CVodeIntegrator(...) >>> for t in solver.run(solver.t,
solver.t + cmf.week, cmf.h): >>>    print(t, solver[0].state) or with
list comprehension >>> states = [solver[0].state for t in
solver.run(solver.t, solver.t + cmf.week, cmf.h)]  Parameters
---------- start : cmf.Time, optional Start time for the solver
iteration end : cmf.Time, optional End time of the iteration step :
cmf.Time, optional Step size for the integration max_errors: int
Number of tolerated errors. If >0, up to these number of runtime
errors will be saved with their time and the integration proceeds
after a reset of the solver. Some systems operate with values close to
their physical limits and inifinite values in the integration can
easily occur. For these kind of systems set max_errors to eg. 10. A
larger number of errors should be eliminated usually. reset: bool If
True, the solver performs a `reset` at every time step  Yields ------
cmf.Time      the actual timestep ";

%feature("docstring")  cmf_core::BDF2::set_state "def set_state(self,
args, kwargs)

set_state(Integrator self, ptrdiff_t position, real newState)  void
set_state(ptrdiff_t position, real newState)  Simplifies the
assessment of state variables. ";

%feature("docstring")  cmf_core::BDF2::set_t "def set_t(self, args,
kwargs)

set_t(Integrator self, Time val)  void set_t(cmf::math::Time val) Sets
the current model time. ";

%feature("docstring")  cmf_core::BDF2::size "def size(self, args,
kwargs)

size(Integrator self) -> size_t  size_t size() const  returns the
number of state variables ";


// File: classcmf_1_1math_1_1_b_d_f2.xml
%feature("docstring") cmf::math::BDF2 "

An order 2 BDF-Method with fixed-point iteration and variable step
size.

Derived from Roussel C. and Roussel M. (2003) \"Generic Object-
Oriented Differential Equation Integrators\", C/C++ User Journal, Nov.
2003,http://www.ddj.com/cpp/184401724?pgno=8 and

Eckert S., Baaser H., Gross D. and Scherf O. (2004) \"A BDF2
integration method with step size control for elasto-plasticity\",
Computational Mechanics 34, 377 - 386, DOI: 10.1007/s00466-004-0581-1

Most important function: Integrate

C++ includes: bdf2.h ";

/*  Internal data storages  */

/*  Gear functions: The following functions evaluate the Gear formulas
of specified order, loading the results into compareStates.  */

/*  Accuracy parameters  */

/*  model time  */

%feature("docstring")  cmf::math::BDF2::get_t "cmf::math::Time
get_t() const

Returns the current model time. ";

%feature("docstring")  cmf::math::BDF2::set_t "void
set_t(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::BDF2::get_dt "cmf::math::Time
get_dt() const

Returns the last time step. ";

/*  Integrate  */

%feature("docstring")  cmf::math::BDF2::integrate_until "void
integrate_until(cmf::math::Time t_max, cmf::math::Time dt=Time(), bool
reset=false)

Integrates the vector of state variables until t_max.

Parameters:
-----------

t_max:   Time, the solver should run to

dt:   Time step (may be omitted)

reset:  If true, solver is reseted before integration starts ";

%feature("docstring")  cmf::math::BDF2::BDF2 "BDF2(real epsilon=1e-9,
cmf::math::Time tStepMin=cmf::math::timespan(10))

Constructs a new BDF2 integrator.

Parameters:
-----------

epsilon:  relative error tolerance per time step (default=1e-9)

tStepMin:  minimum time step (default=10s) ";

%feature("docstring")  cmf::math::BDF2::BDF2 "BDF2(cmf::math::StateVariableOwner &states, real epsilon=1e-9,
cmf::math::Time tStepMin=cmf::math::timespan(10))

Constructs a new Gears_var_Step.

Parameters:
-----------

states:  States to be added to the solver

epsilon:  relative error tolerance per time step (default=1e-9)

tStepMin:  minimum time step (default=10s) ";

%feature("docstring")  cmf::math::BDF2::BDF2 "BDF2(const Integrator
&templ)

Constructs a new BDF2 integrator.

Parameters:
-----------

templ:  Template to be used to construct a BDF2 method ";

%feature("docstring")  cmf::math::BDF2::add_single_state "virtual
void add_single_state(cmf::math::StateVariable::ptr state)

Adds a single state variable to the integrator. ";

%feature("docstring")  cmf::math::BDF2::add_states "void
add_states(cmf::math::StateVariableOwner &stateOwner)

Add state variables from a StateVariableOwner. ";

%feature("docstring")  cmf::math::BDF2::add_values_to_states "void
add_values_to_states(const num_array &operands)

Adds the values in operands to the current states. ";

%feature("docstring")  cmf::math::BDF2::copy "virtual Integrator*
copy() const

Polymorphic copy constructor. ";

%feature("docstring")  cmf::math::BDF2::copy_dxdt "void
copy_dxdt(Time time, num_array &destination, real factor=1) const

Copies the derivatives at time step \"time\" to a numeric vector using
use_OpenMP.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Vector to be overwritten by the results

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::BDF2::copy_dxdt "void
copy_dxdt(Time time, real *destination, real factor=1) const

Copies the derivatives at time step \"time\" to an preallocated c
array.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Allocated c array

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::BDF2::copy_states "void
copy_states(num_array &destination) const

Copies the states to a numeric vector using use_OpenMP. ";

%feature("docstring")  cmf::math::BDF2::copy_states "void
copy_states(real *destination) const ";

%feature("docstring")  cmf::math::BDF2::get_dxdt "cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf::math::BDF2::get_error_position "int
get_error_position() const

Returns the position of the biggest error. ";

%feature("docstring")  cmf::math::BDF2::get_state "real
get_state(ptrdiff_t position) const

Returns the statevariable at position Simplifies the assessment of
state variables. ";

%feature("docstring")  cmf::math::BDF2::get_states "cmf::math::num_array get_states() const ";

%feature("docstring")  cmf::math::BDF2::get_states "StateVariableList
get_states()

gets the state variables of the integrator ";

%feature("docstring")  cmf::math::BDF2::integrate "int
integrate(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

Integrates the vector of state variables.

if :math:`t_{max}-t_{now}\\\\leq 2h_n` then :math:`h_{n+1}= t_{max}-t_{now}`
else :math:`h_{n+1}= 2h_n`

Uses pastStatesArray to store :math:`y_n,y_{n-1}`

if more than one step is taken start iterating:  :math:`y_{n+1}^i=\\\\frac{1}{1+2\\\\rho }\\\\left( (\\\\rho +1)^{2}y_{n}-\\\\rho ^{2}y_{n-1}+(\\\\rho +1)h\\\\frac{dy}{dt}(y_{n+1}^{i-1},t_{n+1} \\\\right), y_{n+1}^0=y_n`
with :math:`\\\\rho = \\\\frac{h_{n+1}}{h_n}`

until :math:`y_{n+1}^{i} - y_{n+1}^{i-1} \\\\leq \\\\ \\\\|\\\\epsilon + \\\\epsilon y_{n+1}\\\\|_{\\\\infty}`

If too many iterations are needed, or the error is rising, repeat
iteration with :math:`h_{n+1} = \\\\frac{h_{n+1}}{2}`

Parameters:
-----------

MaxTime:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

TimeStep:  Takes the proposed timestep, ignored by this solver ";

%feature("docstring")  cmf::math::BDF2::reset "virtual void reset()

Resets any saved history (for multistep methods) ";

%feature("docstring")  cmf::math::BDF2::set_state "void
set_state(ptrdiff_t position, real newState)

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::BDF2::set_states "void
set_states(const num_array &newStates)

Copies the new states to the actual states. ";

%feature("docstring")  cmf::math::BDF2::set_states "void
set_states(real *newStates) ";

%feature("docstring")  cmf::math::BDF2::size "size_t size() const

returns the number of state variables ";


// File: classcmf__core_1_1bidirectional__kinematic__exchange.xml
%feature("docstring") cmf_core::bidirectional_kinematic_exchange "

A conceptual flux between two storages that can be positive as well as
negative.  The state of the right node is not monitored, hence
negative volumes of the right node can occur! Deprecated Behaviour
unclear, will be removed   .. math::       q = q_{spill}^*-q_{suc}^*
\\\\\\\\\\\\\\\\ q_{spill}^* =     q_{spill}
\\\\\\\\left(\\\\\\\\frac{V-V_{spill,min}}{V_{spill,min}}\\\\\\\\right)^{\\\\\\\\beta_{spill}}
\\\\\\\\\\\\\\\\ q_{suc}^* = q_{suc}
\\\\\\\\left(\\\\\\\\frac{V_{suc,max}-V}{V_{suc,max}}\\\\\\\\right)^{\\\\\\\\beta_{suc}}
where:  :math:`q` is the flow to the target  :math:`q_{spill}^*` is
the actual spill flow to the target  :math:`q_{spill}` is the spill
flow at :math:`V = 2V_{spill}`  :math:`q_{suc}^*` is the actual
suction flow from the target  :math:`q_{suc}` is the sucked flow from
the target when :math:`V=0.0`  :math:`\\\\\\\\beta` is a shape forming
exponent for spill and suction flow.  C++ includes:
simple_connections.h ";

%feature("docstring")
cmf_core::bidirectional_kinematic_exchange::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::water::bidirectional_kinematic_exchange self,
cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr
target, real Vminspill, real Vmaxsuc, real qspill, real qsuc, real
beta_spill, real beta_suc) -> bidirectional_kinematic_exchange
bidirectional_kinematic_exchange(WaterStorage::ptr source,
flux_node::ptr target, real Vminspill, real Vmaxsuc, real qspill, real
qsuc, real beta_spill, real beta_suc)  Creates a kinematic wave
connection.  Parameters: -----------  source:  Water storage from
which the water flows out. Flux is a function of source.volume target:
Target node (boundary condition or storage). Does not influence the
strength of the flow  Vmaxsuc:  Suction starts below this threshold
volume of source  Vminspill:  Spilling starts above this threshold
volume of source  qspill:  Spill flow at 2*Vminspill in m3/day  qsuc:
Suction flow at V=0 m3  beta_suc:  beta_spill: Exponent for spill /
suction flow ";

%feature("docstring")
cmf_core::bidirectional_kinematic_exchange::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")
cmf_core::bidirectional_kinematic_exchange::__eq__ "def __eq__(self,
args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")
cmf_core::bidirectional_kinematic_exchange::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")
cmf_core::bidirectional_kinematic_exchange::__iter__ "def
__iter__(self) ";

%feature("docstring")
cmf_core::bidirectional_kinematic_exchange::__repr__ "def
__repr__(self) ";

%feature("docstring")
cmf_core::bidirectional_kinematic_exchange::conc "def conc(self,
args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::bidirectional_kinematic_exchange::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf_core::bidirectional_kinematic_exchange::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::bidirectional_kinematic_exchange::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")
cmf_core::bidirectional_kinematic_exchange::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")
cmf_core::bidirectional_kinematic_exchange::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::bidirectional_kinematic_exchange::q "def q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")
cmf_core::bidirectional_kinematic_exchange::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")
cmf_core::bidirectional_kinematic_exchange::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::bidirectional_kinematic_exchange::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf_core::bidirectional_kinematic_exchange::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")
cmf_core::bidirectional_kinematic_exchange::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1water_1_1bidirectional__kinematic__exchange.xml
%feature("docstring") cmf::water::bidirectional_kinematic_exchange "

A conceptual flux between two storages that can be positive as well as
negative.

The state of the right node is not monitored, hence negative volumes
of the right node can occur! Deprecated Behaviour unclear, will be
removed 

.. math::

     q = q_{spill}^*-q_{suc}^* \\\\\\\\ q_{spill}^* =
    q_{spill}
    \\\\left(\\\\frac{V-V_{spill,min}}{V_{spill,min}}\\\\right)^{\\\\beta_{spill}}
    \\\\\\\\ q_{suc}^* = q_{suc}
    \\\\left(\\\\frac{V_{suc,max}-V}{V_{suc,max}}\\\\right)^{\\\\beta_{suc}}
    

where:  :math:`q` is the flow to the target

:math:`q_{spill}^*` is the actual spill flow to the target

:math:`q_{spill}` is the spill flow at :math:`V = 2V_{spill}`

:math:`q_{suc}^*` is the actual suction flow from the target

:math:`q_{suc}` is the sucked flow from the target when :math:`V=0.0`

:math:`\\\\beta` is a shape forming exponent for spill and suction flow.

C++ includes: simple_connections.h ";

%feature("docstring")
cmf::water::bidirectional_kinematic_exchange::bidirectional_kinematic_exchange
"bidirectional_kinematic_exchange(WaterStorage::ptr source,
flux_node::ptr target, real Vminspill, real Vmaxsuc, real qspill, real
qsuc, real beta_spill, real beta_suc)

Creates a kinematic wave connection.

Parameters:
-----------

source:  Water storage from which the water flows out. Flux is a
function of source.volume

target:  Target node (boundary condition or storage). Does not
influence the strength of the flow

Vmaxsuc:  Suction starts below this threshold volume of source

Vminspill:  Spilling starts above this threshold volume of source

qspill:  Spill flow at 2*Vminspill in m3/day

qsuc:  Suction flow at V=0 m3

beta_suc:  beta_spill:  Exponent for spill / suction flow ";

%feature("docstring")
cmf::water::bidirectional_kinematic_exchange::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::water::bidirectional_kinematic_exchange::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::water::bidirectional_kinematic_exchange::get_ptr "ptr get_ptr()
const ";

%feature("docstring")
cmf::water::bidirectional_kinematic_exchange::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::water::bidirectional_kinematic_exchange::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::water::bidirectional_kinematic_exchange::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::bidirectional_kinematic_exchange::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::water::bidirectional_kinematic_exchange::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::water::bidirectional_kinematic_exchange::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::water::bidirectional_kinematic_exchange::q
"real q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::water::bidirectional_kinematic_exchange::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::water::bidirectional_kinematic_exchange::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::water::bidirectional_kinematic_exchange::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::bidirectional_kinematic_exchange::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::water::bidirectional_kinematic_exchange::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::water::bidirectional_kinematic_exchange::to_string "virtual
std::string to_string() const ";


// File: classcmf_1_1math_1_1root__finding_1_1_bisect.xml
%feature("docstring") cmf::math::root_finding::Bisect "";

%feature("docstring")  cmf::math::root_finding::Bisect::Bisect "Bisect(double tolerance=1e-12, unsigned int max_iterations=1000) ";

%feature("docstring")  cmf::math::root_finding::Bisect::f "virtual
double f(double) const =0 ";


// File: classcmf_1_1math_1_1root__finding_1_1_brents_method.xml
%feature("docstring") cmf::math::root_finding::BrentsMethod "";

%feature("docstring")
cmf::math::root_finding::BrentsMethod::BrentsMethod "BrentsMethod(double tolerance=1e-12, unsigned int max_iterations=1000)
";

%feature("docstring")  cmf::math::root_finding::BrentsMethod::f "virtual double f(double) const =0 ";


// File: classcmf_1_1upslope_1_1_brooks_corey_retention_curve.xml
%feature("docstring") cmf::upslope::BrooksCoreyRetentionCurve "

Provides the use of the Brooks-Corey retention curve.



.. math::

     W(\\\\theta) &=& \\\\frac{\\\\theta -
    \\\\theta_r}{\\\\theta_s - \\\\theta_r} \\\\\\\\ K(W) &=& K_{sat}
    W^{2b+3} \\\\\\\\ \\\\Psi(W) &=& \\\\Psi_X
    \\\\left(\\\\frac{W}{W_X}\\\\right)^{-b} \\\\\\\\ W(\\\\Psi) &=&
    {\\\\left( \\\\frac{\\\\Psi_X}{\\\\Psi}\\\\right)
    }^{\\\\frac{1}{b}}\\\\ W_X 

 where:  :math:`K` is the
conductivity in :math:`\\\\frac m{day}`

:math:`W` is the wetness (Volume of soil water per volume of pores)

:math:`b` is the shape of the retention curve (usually between 4 (sand) and
14 (clay))

:math:`\\\\Psi(W)` is the matric potential in :math:`m H_2O` at wetness W

:math:`\\\\Psi_X` is a matric potential at a known wetness in :math:`m H_2O`

:math:`W_X` is the wetness with a known matric potential for dynamic changes
with depth, exponential decays of porosity and saturated conductivity
are used The decay function is: :math:`v(d)=v(0) (1+a)^{-d}`, where v is
the value ( :math:`K_{sat},\\\\Phi`), d is the depth in m and a is the
fractional decay per m. E.g. 0.1 means the value has in 1 m depth 90%
of the value at the surface

C++ includes: RetentionCurve.h ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::BrooksCoreyRetentionCurve "BrooksCoreyRetentionCurve(real ksat=15, real porosity=0.5, real _b=5,
real theta_x=0.2, real psi_x=pF_to_waterhead(2.5), real
porosity_decay=0)

Creates a brooks corey retention curve.

Parameters:
-----------

ksat:  Saturated conductivity :math:`\\\\frac{m}{day}`

porosity:   :math:`\\\\frac{m^3 Pores}{m^3 Soil}`

_b:  Shape of the retention curve (if you do not know how to
parameterize this, take a look at the other constructor)

theta_x:   :math:`\\\\theta_X` Water content at a specific suction pressure

psi_x:  Suction pressure for :math:`\\\\theta_X` in m water column, use the
conversion functions pF_to_waterhead, pressure_to_waterhead to convert
pressure in to waterhead height (default pF=2.5)

porosity_decay:  Relative decay of porosity with depth, e.g. 0.1 means
conductivity gets 10% smaller per meter ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::~BrooksCoreyRetentionCurve "virtual ~BrooksCoreyRetentionCurve() ";

%feature("docstring")  cmf::upslope::BrooksCoreyRetentionCurve::copy "virtual BrooksCoreyRetentionCurve* copy() const ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::Diffusivity "virtual real
Diffusivity(real wetness) const

Returns the Diffusivity of the soil.

Not implemented for all retention curves. Diffusivity is used by
MACROlikeMacroMicroExchange ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::Diffusivity "cmf::math::num_array Diffusivity(cmf::math::num_array &wetness) ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::dPsiM_dW "virtual real
dPsiM_dW(real wetness) const ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::dPsiM_dW "cmf::math::num_array dPsiM_dW(const cmf::math::num_array &wetness)
const ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::FillHeight "real
FillHeight(real lowerDepth, real Area, real Volume) const

Returns the thickness of a soil column with a certain pore volume. ";

%feature("docstring")  cmf::upslope::BrooksCoreyRetentionCurve::get_b
"real get_b() const

Retention curve shape parameter. ";

%feature("docstring")  cmf::upslope::BrooksCoreyRetentionCurve::K "cmf::math::num_array K(const cmf::math::num_array &wetness) const ";

%feature("docstring")  cmf::upslope::BrooksCoreyRetentionCurve::K "virtual real K(real wetness) const

Returns the conductivity in m/day at a certain depth and water
content. ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::MatricPotential "cmf::math::num_array MatricPotential(const cmf::math::num_array
&wetness) const ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::MatricPotential "real
MatricPotential(real wetness) const

Returns the suction pressure in m, use conversion functions
waterhead_to_pressure and waterhead_to_pF fro conversions. ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::Porosity "real Porosity(real
depth) const

real (Porosity) ";

%feature("docstring")  cmf::upslope::BrooksCoreyRetentionCurve::set_b
"void set_b(real new_b) ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::SetPorosity "void
SetPorosity(real porosity, real porosity_decay=0)

Sets the porosity (Volume of pores per volume of soil) and the
exponential porosity decline with depth. ";

%feature("docstring")  cmf::upslope::BrooksCoreyRetentionCurve::theta
"virtual real theta(real wetness) const

returns the water content :math:`theta` for a given wetness ";

%feature("docstring")  cmf::upslope::BrooksCoreyRetentionCurve::theta
"cmf::math::num_array theta(const cmf::math::num_array &wetness)
const ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::Transmissivity "real
Transmissivity(real upperDepth, real lowerDepth, real theta) const ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::VoidVolume "real
VoidVolume(real upperDepth, real lowerDepth, real Area) const

Returns the pore volume in a region of a soil column.

If there is a porosity decay, the void volume is the integral of
porosity over depth times area ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::Wetness "cmf::math::num_array Wetness(const cmf::math::num_array &suction)
const ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::Wetness "real Wetness(real
suction) const

returns the wetness (volumetric water content per pore space) at a
given suction pressure ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::Wetness_eff "virtual real
Wetness_eff(real wetness, real pF_r=4.2) const

Returns the effective wetness, using a residual pF value 

.. math::

    w_{eff}
    =
    \\\\frac{w_{act}-w\\\\left(pF_r\\\\right)}{1-w\\\\left(pF_r\\\\right)}

.
";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::Wetness_pF "real
Wetness_pF(real pF) const

returns the volumetric water content at a given pF value ";

%feature("docstring")
cmf::upslope::BrooksCoreyRetentionCurve::Wetness_pF "cmf::math::num_array Wetness_pF(const cmf::math::num_array &pF) const
";


// File: classcmf__core_1_1_brooks_corey_retention_curve.xml
%feature("docstring") cmf_core::BrooksCoreyRetentionCurve "

Provides the use of the Brooks-Corey retention curve.    .. math::
W(\\\\\\\\theta) &=& \\\\\\\\frac{\\\\\\\\theta -
\\\\\\\\theta_r}{\\\\\\\\theta_s - \\\\\\\\theta_r} \\\\\\\\\\\\\\\\
K(W) &=& K_{sat}     W^{2b+3} \\\\\\\\\\\\\\\\ \\\\\\\\Psi(W) &=&
\\\\\\\\Psi_X     \\\\\\\\left(\\\\\\\\frac{W}{W_X}\\\\\\\\right)^{-b}
\\\\\\\\\\\\\\\\ W(\\\\\\\\Psi) &=&     {\\\\\\\\left(
\\\\\\\\frac{\\\\\\\\Psi_X}{\\\\\\\\Psi}\\\\\\\\right)
}^{\\\\\\\\frac{1}{b}}\\\\\\\\ W_X    where:  :math:`K` is the
conductivity in :math:`\\\\\\\\frac m{day}`  :math:`W` is the wetness
(Volume of soil water per volume of pores)  :math:`b` is the shape of
the retention curve (usually between 4 (sand) and 14 (clay))
:math:`\\\\\\\\Psi(W)` is the matric potential in :math:`m H_2O` at
wetness W  :math:`\\\\\\\\Psi_X` is a matric potential at a known
wetness in :math:`m H_2O`  :math:`W_X` is the wetness with a known
matric potential for dynamic changes with depth, exponential decays of
porosity and saturated conductivity are used The decay function is:
:math:`v(d)=v(0) (1+a)^{-d}`, where v is the value (
:math:`K_{sat},\\\\\\\\Phi`), d is the depth in m and a is the
fractional decay per m. E.g. 0.1 means the value has in 1 m depth 90%
of the value at the surface  C++ includes: RetentionCurve.h ";

%feature("docstring")  cmf_core::BrooksCoreyRetentionCurve::__init__ "def __init__(self, args, kwargs)

__init__(cmf::upslope::BrooksCoreyRetentionCurve self, real ksat=15,
real porosity=0.5, real _b=5, real theta_x=0.2, real psi_x, real
porosity_decay=0) -> BrooksCoreyRetentionCurve
BrooksCoreyRetentionCurve(real ksat=15, real porosity=0.5, real _b=5,
real theta_x=0.2, real psi_x=pF_to_waterhead(2.5), real
porosity_decay=0)  Creates a brooks corey retention curve. Parameters:
-----------  ksat:  Saturated conductivity
:math:`\\\\\\\\frac{m}{day}`  porosity:   :math:`\\\\\\\\frac{m^3
Pores}{m^3 Soil}`  _b:  Shape of the retention curve (if you do not
know how to parameterize this, take a look at the other constructor)
theta_x:   :math:`\\\\\\\\theta_X` Water content at a specific suction
pressure  psi_x:  Suction pressure for :math:`\\\\\\\\theta_X` in m
water column, use the conversion functions pF_to_waterhead,
pressure_to_waterhead to convert pressure in to waterhead height
(default pF=2.5)  porosity_decay:  Relative decay of porosity with
depth, e.g. 0.1 means conductivity gets 10% smaller per meter ";

%feature("docstring")  cmf_core::BrooksCoreyRetentionCurve::__repr__ "def __repr__(self) ";

%feature("docstring")  cmf_core::BrooksCoreyRetentionCurve::__str__ "def __str__(self) ";

%feature("docstring")  cmf_core::BrooksCoreyRetentionCurve::copy "def
copy(self, args, kwargs)

copy(BrooksCoreyRetentionCurve self) -> BrooksCoreyRetentionCurve
virtual BrooksCoreyRetentionCurve* copy() const ";

%feature("docstring")
cmf_core::BrooksCoreyRetentionCurve::CreateFrom2Points "def
CreateFrom2Points(args, kwargs)

CreateFrom2Points(real ksat, real porosity, real theta1, real theta2,
real psi_1, real psi_2) -> BrooksCoreyRetentionCurve ";

%feature("docstring")
cmf_core::BrooksCoreyRetentionCurve::Diffusivity "def
Diffusivity(self, args)

Diffusivity(RetentionCurve self, real wetness) -> real
Diffusivity(RetentionCurve self, cmf::math::num_array & wetness) ->
cmf::math::num_array  cmf::math::num_array
Diffusivity(cmf::math::num_array &wetness) ";

%feature("docstring")  cmf_core::BrooksCoreyRetentionCurve::dPsiM_dW "def dPsiM_dW(self, args)

dPsiM_dW(RetentionCurve self, real wetness) -> real
dPsiM_dW(RetentionCurve self, cmf::math::num_array const & wetness) ->
cmf::math::num_array  cmf::math::num_array dPsiM_dW(const
cmf::math::num_array &wetness) const ";

%feature("docstring")  cmf_core::BrooksCoreyRetentionCurve::FillHeight
"def FillHeight(self, args, kwargs)

FillHeight(RetentionCurve self, real lowerDepth, real Area, real
Volume) -> real  virtual real FillHeight(real lowerDepth, real Area,
real Volume) const  Returns the thickness of a soil column with a
certain pore volume. ";

%feature("docstring")  cmf_core::BrooksCoreyRetentionCurve::K "def
K(self, args)

K(RetentionCurve self, real wetness) -> real K(RetentionCurve self,
cmf::math::num_array const & wetness) -> cmf::math::num_array
cmf::math::num_array K(const cmf::math::num_array &wetness) const ";

%feature("docstring")
cmf_core::BrooksCoreyRetentionCurve::MatricPotential "def
MatricPotential(self, args)

MatricPotential(RetentionCurve self, real wetness) -> real
MatricPotential(RetentionCurve self, cmf::math::num_array const &
wetness) -> cmf::math::num_array  cmf::math::num_array
MatricPotential(const cmf::math::num_array &wetness) const ";

%feature("docstring")  cmf_core::BrooksCoreyRetentionCurve::Porosity "def Porosity(self, args, kwargs)

Porosity(RetentionCurve self, real depth=0.0) -> real  virtual real
Porosity(real depth=0.0) const =0  Returns the porosity at a certain
depth. ";

%feature("docstring")
cmf_core::BrooksCoreyRetentionCurve::SetPorosity "def
SetPorosity(self, args, kwargs)

SetPorosity(BrooksCoreyRetentionCurve self, real porosity, real
porosity_decay=0)  void SetPorosity(real porosity, real
porosity_decay=0)  Sets the porosity (Volume of pores per volume of
soil) and the exponential porosity decline with depth. ";

%feature("docstring")  cmf_core::BrooksCoreyRetentionCurve::theta "def theta(self, args)

theta(RetentionCurve self, real wetness) -> real theta(RetentionCurve
self, cmf::math::num_array const & wetness) -> cmf::math::num_array
cmf::math::num_array theta(const cmf::math::num_array &wetness) const
";

%feature("docstring")
cmf_core::BrooksCoreyRetentionCurve::Transmissivity "def
Transmissivity(self, args, kwargs)

Transmissivity(BrooksCoreyRetentionCurve self, real upperDepth, real
lowerDepth, real theta) -> real  real Transmissivity(real upperDepth,
real lowerDepth, real theta) const ";

%feature("docstring")  cmf_core::BrooksCoreyRetentionCurve::VoidVolume
"def VoidVolume(self, args, kwargs)

VoidVolume(RetentionCurve self, real upperDepth, real lowerDepth, real
Area) -> real  virtual real VoidVolume(real upperDepth, real
lowerDepth, real Area) const  Returns the void volume of a soil
column. ";

%feature("docstring")  cmf_core::BrooksCoreyRetentionCurve::Wetness "def Wetness(self, args)

Wetness(RetentionCurve self, real suction) -> real
Wetness(RetentionCurve self, cmf::math::num_array const & suction) ->
cmf::math::num_array  cmf::math::num_array Wetness(const
cmf::math::num_array &suction) const ";

%feature("docstring")
cmf_core::BrooksCoreyRetentionCurve::Wetness_eff "def
Wetness_eff(self, args, kwargs)

Wetness_eff(RetentionCurve self, real wetness, real pF_r=4.2) -> real
virtual real Wetness_eff(real wetness, real pF_r=4.2) const  Returns
the effective wetness, using a residual pF value   .. math:: w_{eff}
=
\\\\\\\\frac{w_{act}-w\\\\\\\\left(pF_r\\\\\\\\right)}{1-w\\\\\\\\left(pF_r\\\\\\\\right)}
. ";

%feature("docstring")  cmf_core::BrooksCoreyRetentionCurve::Wetness_pF
"def Wetness_pF(self, args)

Wetness_pF(RetentionCurve self, real pF) -> real
Wetness_pF(RetentionCurve self, cmf::math::num_array const & pF) ->
cmf::math::num_array  cmf::math::num_array Wetness_pF(const
cmf::math::num_array &pF) const ";


// File: classcmf__core_1_1_canopy_overflow.xml
%feature("docstring") cmf_core::CanopyOverflow "

Calculates the overflow of a canopy storage using a kinematic wave
approach.  This model routes only water that exceeds the canopy
capacity to the ground with an ad hoc estimated function:   .. math::
q_{CO} =
\\\\\\\\left(\\\\\\\\frac{V_{act}-V_{max}}{V_{max}}\\\\\\\\right) ^2
\\\\\\\\cdot 2400     \\\\\\\\frac{A_{cell}}{1000}  With:
:math:`q_{CO}(t)[\\\\\\\\frac{m^3}{day}]`: The flux from canopy to the
ground  :math:`V_{act}[mm]=1000 [mm/m]
\\\\\\\\frac{V_{canopy}[m^3]}{A_{cell} [m^2]}` The stored water of the
canopy in mm  :math:`V_{max}[mm]=c_{LAI}[mm] LAI` The capacity of the
canopy in mm, defined by the factor CanopyCapacityPerLAI [mm/LAI], and
the leaf area index LAI. (see: cmf::upslope::Vegetation)  C++
includes: surfacefluxes.h ";

%feature("docstring")  cmf_core::CanopyOverflow::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::CanopyOverflow self,
cmf::water::WaterStorage::ptr Canopy, cmf::water::flux_node::ptr
target, Cell cell) -> CanopyOverflow
CanopyOverflow(cmf::water::WaterStorage::ptr Canopy,
cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell) ";

%feature("docstring")  cmf_core::CanopyOverflow::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::CanopyOverflow::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::CanopyOverflow::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::CanopyOverflow::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::CanopyOverflow::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::CanopyOverflow::conc "def conc(self,
args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::CanopyOverflow::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::CanopyOverflow::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::CanopyOverflow::get_tracer_filter "def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::CanopyOverflow::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::CanopyOverflow::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::CanopyOverflow::q "def q(self, args,
kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::CanopyOverflow::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::CanopyOverflow::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::CanopyOverflow::set_tracer_filter "def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::CanopyOverflow::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::CanopyOverflow::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::CanopyOverflow::use_for_cell "def
use_for_cell(args, kwargs)

use_for_cell(Cell cell) -> CanopyOverflow ";


// File: classcmf_1_1upslope_1_1connections_1_1_canopy_overflow.xml
%feature("docstring") cmf::upslope::connections::CanopyOverflow "

Calculates the overflow of a canopy storage using a kinematic wave
approach.

This model routes only water that exceeds the canopy capacity to the
ground with an ad hoc estimated function: 

.. math::

    q_{CO} =
    \\\\left(\\\\frac{V_{act}-V_{max}}{V_{max}}\\\\right) ^2 \\\\cdot 2400
    \\\\frac{A_{cell}}{1000}

With:  :math:`q_{CO}(t)[\\\\frac{m^3}{day}]`:
The flux from canopy to the ground

:math:`V_{act}[mm]=1000 [mm/m] \\\\frac{V_{canopy}[m^3]}{A_{cell} [m^2]}`
The stored water of the canopy in mm

:math:`V_{max}[mm]=c_{LAI}[mm] LAI` The capacity of the canopy in mm,
defined by the factor CanopyCapacityPerLAI [mm/LAI], and the leaf area
index LAI. (see: cmf::upslope::Vegetation)

C++ includes: surfacefluxes.h ";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::CanopyOverflow "CanopyOverflow(cmf::water::WaterStorage::ptr Canopy,
cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell) ";

%feature("docstring")  cmf::upslope::connections::CanopyOverflow::conc
"real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::get_ptr "ptr get_ptr()
const ";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::get_target "flux_node::ptr
get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::get_target "flux_node::ptr
get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::left_node "flux_node::ptr
left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::connections::CanopyOverflow::q "real q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::right_node "flux_node::ptr
right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::CanopyOverflow::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_canopy_storage_evaporation.xml
%feature("docstring") cmf_core::CanopyStorageEvaporation "

Calculates the evaporation from a canopy storage.  C++ includes: ET.h
";

%feature("docstring")  cmf_core::CanopyStorageEvaporation::__init__ "def __init__(self, args, kwargs)

__init__(cmf::upslope::ET::CanopyStorageEvaporation self,
cmf::water::WaterStorage::ptr CanopyStorage,
cmf::water::flux_node::ptr ET_target, Cell cell) ->
CanopyStorageEvaporation
CanopyStorageEvaporation(cmf::water::WaterStorage::ptr CanopyStorage,
cmf::water::flux_node::ptr ET_target, cmf::upslope::Cell &cell) ";

%feature("docstring")
cmf_core::CanopyStorageEvaporation::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::CanopyStorageEvaporation::__eq__ "def __eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::CanopyStorageEvaporation::__getitem__
"def __getitem__(self, index) ";

%feature("docstring")  cmf_core::CanopyStorageEvaporation::__iter__ "def __iter__(self) ";

%feature("docstring")  cmf_core::CanopyStorageEvaporation::__repr__ "def __repr__(self) ";

%feature("docstring")  cmf_core::CanopyStorageEvaporation::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::CanopyStorageEvaporation::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::CanopyStorageEvaporation::get_target
"def get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::CanopyStorageEvaporation::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::CanopyStorageEvaporation::kill_me "def kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::CanopyStorageEvaporation::left_node "def left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::CanopyStorageEvaporation::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::CanopyStorageEvaporation::refresh "def refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::CanopyStorageEvaporation::right_node
"def right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::CanopyStorageEvaporation::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf_core::CanopyStorageEvaporation::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::CanopyStorageEvaporation::to_string "def to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1_e_t_1_1_canopy_storage_evaporation.xml
%feature("docstring") cmf::upslope::ET::CanopyStorageEvaporation "

Calculates the evaporation from a canopy storage.

C++ includes: ET.h ";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::CanopyStorageEvaporation "CanopyStorageEvaporation(cmf::water::WaterStorage::ptr CanopyStorage,
cmf::water::flux_node::ptr ET_target, cmf::upslope::Cell &cell) ";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::get_ptr "ptr get_ptr()
const ";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::left_node "flux_node::ptr
left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::ET::CanopyStorageEvaporation::q "real q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::upslope::ET::CanopyStorageEvaporation::to_string "virtual
std::string to_string() const ";


// File: classcmf_1_1upslope_1_1_cell.xml
%feature("docstring") cmf::upslope::Cell "

This class is the basic landscape object.

It is the owner of water storages, and the upper and lower boundary
conditions of the system (rainfall, atmospheric vapor, deep
groundwater)

C++ includes: cell.h ";

/*  Location  */

%feature("docstring")  cmf::upslope::Cell::get_topology "cmf::upslope::Topology& get_topology() ";

%feature("docstring")  cmf::upslope::Cell::get_position "cmf::geometry::point get_position() const

Returns the location of the cell. ";

%feature("docstring")  cmf::upslope::Cell::get_area "double
get_area() const

Returns the area of the cell. ";

%feature("docstring")  cmf::upslope::Cell::m3_to_mm "double
m3_to_mm(double volume) const

Converts a volume in m3 in mm for the cell area. ";

%feature("docstring")  cmf::upslope::Cell::mm_to_m3 "double
mm_to_m3(double depth) const ";

/*  Saturation  */

%feature("docstring")  cmf::upslope::Cell::InvalidateSatDepth "void
InvalidateSatDepth() const

Marks the saturated depth as unvalid. This is done automatically, when
the state of a layer changes. ";

%feature("docstring")  cmf::upslope::Cell::get_saturated_depth "real
get_saturated_depth() const

Returns the potential :math:`\\\\Psi_{total}` of the deepest unsaturated
layer as distance from the surface.

This function is wrapped as the property saturated_depth in Python ";

%feature("docstring")  cmf::upslope::Cell::set_saturated_depth "void
set_saturated_depth(real depth)

Sets the potential :math:`\\\\Psi_{total}` of each layer as distance from
the surface.

This function is wrapped as the property saturated_depth in Python ";

/*  Flux nodes of the cell  */

%feature("docstring")  cmf::upslope::Cell::get_meteorology "cmf::atmosphere::Meteorology& get_meteorology() const

Returns the meteorological data source. ";

%feature("docstring")  cmf::upslope::Cell::set_aerodynamic_resistance
"void
set_aerodynamic_resistance(cmf::atmosphere::aerodynamic_resistance::ptr
Ra)

Sets the method to calculate aerodynamic resistance against turbulent
sensible heat fluxes. ";

%feature("docstring")  cmf::upslope::Cell::set_meteorology "void
set_meteorology(const cmf::atmosphere::Meteorology &new_meteo)

Sets a meteorological data source. ";

%feature("docstring")  cmf::upslope::Cell::set_weather "void
set_weather(const cmf::atmosphere::Weather &weather)

Sets the weather for this cell. Connectivity to a meteorological
station is lost. ";

%feature("docstring")  cmf::upslope::Cell::set_rainfall "void
set_rainfall(double rainfall)

Exchanges a timeseries of rainfall with a constant flux. ";

%feature("docstring")  cmf::upslope::Cell::get_rainfall "double
get_rainfall(cmf::math::Time t) const

Returns the current rainfall flux in m3/day. ";

%feature("docstring")  cmf::upslope::Cell::set_rain_source "void
set_rain_source(cmf::atmosphere::RainSource::ptr new_source)

Changes the current source of rainfall. ";

%feature("docstring")  cmf::upslope::Cell::get_rain_source "cmf::atmosphere::RainSource::ptr get_rain_source()

Returns the current source for rainfall. ";

%feature("docstring")  cmf::upslope::Cell::set_uptakestress "void
set_uptakestress(const ET::RootUptakeStessFunction &stressfunction)

Uses the given WaterStressFunction for all stressedET like connections
to the transpiration target. ";

%feature("docstring")  cmf::upslope::Cell::get_evaporation "cmf::water::flux_node::ptr get_evaporation()

Returns the end point of all evaporation of this cell (a
cmf::water::flux_node) ";

%feature("docstring")  cmf::upslope::Cell::get_transpiration "cmf::water::flux_node::ptr get_transpiration()

Returns the end point of all transpiration of this cell (a
cmf::water::flux_node) ";

%feature("docstring")  cmf::upslope::Cell::get_surfacewater "cmf::water::flux_node::ptr get_surfacewater()

returns the surface water of this cell. This is either a flux node or
a cmf::upslope::SurfaceWater ";

%feature("docstring")  cmf::upslope::Cell::surfacewater_as_storage "surfacewater_ptr surfacewater_as_storage()

Makes the surfacewater of this cell a cmf::upslope::SurfaceWater
storage. ";

%feature("docstring")  cmf::upslope::Cell::add_storage "cmf::water::WaterStorage::ptr add_storage(std::string Name, char
storage_role='N', bool isopenwater=false)

Adds a new storage to the cell.

Parameters:
-----------

Name:  The name of the storage

storage_role:  A shortcut to describe the functional role of the
storage new storage. Possible Values: 'C' denotes a canopy storage

'S' denotes a snow storage

any other value denotes a storage with an undefined function

isopenwater:  If true, an open water storage with a cmf::river::Prism
height function is created ";

%feature("docstring")  cmf::upslope::Cell::add_storage "ptrdiff_t
add_storage(cmf::water::WaterStorage::ptr storage)

Bounds an existing storage to the cell. ";

%feature("docstring")  cmf::upslope::Cell::remove_storage "void
remove_storage(cmf::water::WaterStorage::ptr storage) ";

%feature("docstring")  cmf::upslope::Cell::storage_count "size_t
storage_count() const ";

%feature("docstring")  cmf::upslope::Cell::get_storage "cmf::water::WaterStorage::ptr get_storage(ptrdiff_t index) const ";

%feature("docstring")  cmf::upslope::Cell::get_canopy "cmf::water::WaterStorage::ptr get_canopy() const ";

%feature("docstring")  cmf::upslope::Cell::get_snow "cmf::water::WaterStorage::ptr get_snow() const ";

%feature("docstring")  cmf::upslope::Cell::snow_coverage "real
snow_coverage() const ";

%feature("docstring")  cmf::upslope::Cell::albedo "real albedo()
const ";

%feature("docstring")  cmf::upslope::Cell::surface_water_coverage "real surface_water_coverage() const

Returns the coverage of the surface water.

The covered fraction (0..1) is simply modelled as a piecewise linear
function of the surface water depth. If the depth is above the
aggregate height, the coverage is 1, below it is given as 

.. math::

     c =
    \\\\frac{h_{water}}{\\\\Delta h_{surface}}

with c the coverage,
:math:`h_{water}` the depth of the surface water and :math:`\\\\Delta h_{surface}`
the amplitude of the surface roughness ";

%feature("docstring")  cmf::upslope::Cell::heat_flux "real
heat_flux(cmf::math::Time t) const

Calculates the surface heat balance.

Parameters:
-----------

t:  Time step ";

%feature("docstring")  cmf::upslope::Cell::leave_wetness "real
leave_wetness() const

Return the fraction of wet leaves in the canopy if a canopy water
storage exists.

If no canopy storage is present, it returns 0.0 (=empty). The fraction
of wet leaves are calculated as the linear filling of the canopy
storage. ";

%feature("docstring")  cmf::upslope::Cell::get_WKB "cmf::bytestring
get_WKB() const ";

%feature("docstring")  cmf::upslope::Cell::set_WKB "void
set_WKB(cmf::bytestring wkb) ";

%feature("docstring")  cmf::upslope::Cell::get_project "cmf::project&
get_project() const ";

%feature("docstring")  cmf::upslope::Cell::get_weather "cmf::atmosphere::Weather get_weather(cmf::math::Time t) const

Returns the current meteorological conditions of the cell at time t.
";

/*  Layers  */

%feature("docstring")  cmf::upslope::Cell::layer_count "size_t
layer_count() const

Returns the number of layers of the cell. ";

%feature("docstring")  cmf::upslope::Cell::get_layer "cmf::upslope::SoilLayer::ptr get_layer(ptrdiff_t ndx) const

Returns the layer at position ndx.

From python this function is masked as a sequence: ";

%feature("docstring")  cmf::upslope::Cell::get_layers "const
layer_list& get_layers() const

Returns the list of layers.

From python this function is masked as a property: ";

%feature("docstring")  cmf::upslope::Cell::add_layer "cmf::upslope::SoilLayer::ptr add_layer(real lowerboundary, const
cmf::upslope::RetentionCurve &r_curve, real saturateddepth=10)

Adds a layer to the cell.

Layers are created using this function

the new layer

Parameters:
-----------

lowerboundary:  The maximum depth of the layer in m. If lowerboundary
is smaller or equal than the lowerboundary of thelowest layer, an
error is raised

r_curve:  A retention curve.See here for a discussion on retention
curves in cmf.

saturateddepth:  The initial potential of the new layer in m below
surface. Default = 10m (=quite dry) ";

%feature("docstring")  cmf::upslope::Cell::add_layer "cmf::upslope::SoilLayer::ptr add_layer(real lowerboundary)

Adds a rather conceptual layer to the cell. Use this version for
conceptual models. The retention curve resambles an empty bucket. ";

%feature("docstring")  cmf::upslope::Cell::remove_last_layer "void
remove_last_layer()

Remove the lowest layer from this cell. ";

%feature("docstring")  cmf::upslope::Cell::remove_layers "void
remove_layers()

Removes all layers from this cell. ";

%feature("docstring")  cmf::upslope::Cell::get_soildepth "double
get_soildepth() const

Returns the lower boundary of the lowest layer in m. ";

%feature("docstring")  cmf::upslope::Cell::~Cell "virtual ~Cell() ";

%feature("docstring")  cmf::upslope::Cell::Cell "Cell(double x,
double y, double z, double area, cmf::project &_project) ";

%feature("docstring")  cmf::upslope::Cell::get_states "cmf::math::StateVariableList get_states()

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf::upslope::Cell::to_string "std::string
to_string() const ";


// File: classcmf__core_1_1_cell.xml
%feature("docstring") cmf_core::Cell "

This class is the basic landscape object.  It is the owner of water
storages, and the upper and lower boundary conditions of the system
(rainfall, atmospheric vapor, deep groundwater)  C++ includes: cell.h
";

%feature("docstring")  cmf_core::Cell::__init__ "def __init__(self,
args, kwargs)

__init__(cmf::upslope::Cell self, double x, double y, double z, double
area, project _project) -> Cell  Cell(double x, double y, double z,
double area, cmf::project &_project) ";

%feature("docstring")  cmf_core::Cell::__eq__ "def __eq__(self, cmp)
";

%feature("docstring")  cmf_core::Cell::__hash__ "def __hash__(self)
";

%feature("docstring")  cmf_core::Cell::__repr__ "def __repr__(self)
";

%feature("docstring")  cmf_core::Cell::add_layer "def add_layer(self,
args)

add_layer(Cell self, real lowerboundary, RetentionCurve r_curve, real
saturateddepth=10) -> cmf::upslope::SoilLayer::ptr add_layer(Cell
self, real lowerboundary) -> cmf::upslope::SoilLayer::ptr
cmf::upslope::SoilLayer::ptr add_layer(real lowerboundary)  Adds a
rather conceptual layer to the cell. Use this version for conceptual
models. The retention curve resambles an empty bucket. ";

%feature("docstring")  cmf_core::Cell::add_storage "def
add_storage(self, args)

add_storage(Cell self, std::string Name, char storage_role, bool
isopenwater=False) -> cmf::water::WaterStorage::ptr add_storage(Cell
self, cmf::water::WaterStorage::ptr storage) -> ptrdiff_t  ptrdiff_t
add_storage(cmf::water::WaterStorage::ptr storage)  Bounds an existing
storage to the cell. ";

%feature("docstring")  cmf_core::Cell::albedo "def albedo(self, args,
kwargs)

albedo(Cell self) -> real  real albedo() const ";

%feature("docstring")  cmf_core::Cell::connect_soil_with_node "def
connect_soil_with_node(self, node, ctype, flowwidth, distance,
upper_boundary=0, lower_boundary=None)

Connects all layers between the boundaries with a node using a flux
connection node: Target node (flux_node) type: Type of the connection
(e.g. cmf.Richards_lateral) flowwidth: Width of the connection
distance: distance of the connection upper_boundary: Connect only
layers, whose lower depth is greater then this value lower_boundary:
Connect only  layers, whose upper depth is smaller then this value ";

%feature("docstring")  cmf_core::Cell::get_canopy "def
get_canopy(self, args, kwargs)

get_canopy(Cell self) -> cmf::water::WaterStorage::ptr
cmf::water::WaterStorage::ptr get_canopy() const ";

%feature("docstring")  cmf_core::Cell::get_layer "def get_layer(self,
args, kwargs)

get_layer(Cell self, ptrdiff_t ndx) -> cmf::upslope::SoilLayer::ptr
cmf::upslope::SoilLayer::ptr get_layer(ptrdiff_t ndx) const  Returns
the layer at position ndx.  From python this function is masked as a
sequence: ";

%feature("docstring")  cmf_core::Cell::get_position "def
get_position(self, args, kwargs)

get_position(Cell self) -> point  cmf::geometry::point get_position()
const  Returns the location of the cell. ";

%feature("docstring")  cmf_core::Cell::get_rainfall "def
get_rainfall(self, args, kwargs)

get_rainfall(Cell self, Time t) -> double  double
get_rainfall(cmf::math::Time t) const  Returns the current rainfall
flux in m3/day. ";

%feature("docstring")  cmf_core::Cell::get_snow "def get_snow(self,
args, kwargs)

get_snow(Cell self) -> cmf::water::WaterStorage::ptr
cmf::water::WaterStorage::ptr get_snow() const ";

%feature("docstring")  cmf_core::Cell::get_states "def
get_states(self, args, kwargs)

get_states(StateVariableOwner self) -> StateVariableList  virtual
StateVariableList get_states()=0  Add the state variables, owned by an
object derived from StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf_core::Cell::get_storage "def
get_storage(self, args, kwargs)

get_storage(Cell self, ptrdiff_t index) ->
cmf::water::WaterStorage::ptr  cmf::water::WaterStorage::ptr
get_storage(ptrdiff_t index) const ";

%feature("docstring")  cmf_core::Cell::get_surfacewater "def
get_surfacewater(self, args, kwargs)

get_surfacewater(Cell self) -> cmf::water::flux_node::ptr
cmf::water::flux_node::ptr get_surfacewater()  returns the surface
water of this cell. This is either a flux node or a
cmf::upslope::SurfaceWater ";

%feature("docstring")  cmf_core::Cell::get_weather "def
get_weather(self, args, kwargs)

get_weather(Cell self, Time t) -> Weather  cmf::atmosphere::Weather
get_weather(cmf::math::Time t) const  Returns the current
meteorological conditions of the cell at time t. ";

%feature("docstring")  cmf_core::Cell::get_WKB "def get_WKB(self,
args, kwargs)

get_WKB(Cell self) -> cmf::bytestring  cmf::bytestring get_WKB() const
";

%feature("docstring")  cmf_core::Cell::heat_flux "def heat_flux(self,
args, kwargs)

heat_flux(Cell self, Time t) -> real  real heat_flux(cmf::math::Time
t) const  Calculates the surface heat balance.  Parameters:
-----------  t:  Time step ";

%feature("docstring")  cmf_core::Cell::install_connection "def
install_connection(self, connection_type)

Calls the static use_for_cell method of the connection_type, if
present. The use_for_cell method might do quite a lot of stuff, please
consult the docs for the connection. Eg.
>>>help(Richards.use_for_cell) ";

%feature("docstring")  cmf_core::Cell::InvalidateSatDepth "def
InvalidateSatDepth(self, args, kwargs)

InvalidateSatDepth(Cell self)  void InvalidateSatDepth() const  Marks
the saturated depth as unvalid. This is done automatically, when the
state of a layer changes. ";

%feature("docstring")  cmf_core::Cell::layer_count "def
layer_count(self, args, kwargs)

layer_count(Cell self) -> size_t  size_t layer_count() const  Returns
the number of layers of the cell. ";

%feature("docstring")  cmf_core::Cell::leave_wetness "def
leave_wetness(self, args, kwargs)

leave_wetness(Cell self) -> real  real leave_wetness() const  Return
the fraction of wet leaves in the canopy if a canopy water storage
exists.  If no canopy storage is present, it returns 0.0 (=empty). The
fraction of wet leaves are calculated as the linear filling of the
canopy storage. ";

%feature("docstring")  cmf_core::Cell::m3_to_mm "def m3_to_mm(self,
args, kwargs)

m3_to_mm(Cell self, double volume) -> double  double m3_to_mm(double
volume) const  Converts a volume in m3 in mm for the cell area. ";

%feature("docstring")  cmf_core::Cell::mm_to_m3 "def mm_to_m3(self,
args, kwargs)

mm_to_m3(Cell self, double depth) -> double  double mm_to_m3(double
depth) const ";

%feature("docstring")  cmf_core::Cell::neighbors "def neighbors(self)
";

%feature("docstring")  cmf_core::Cell::remove_last_layer "def
remove_last_layer(self, args, kwargs)

remove_last_layer(Cell self)  void remove_last_layer()  Remove the
lowest layer from this cell. ";

%feature("docstring")  cmf_core::Cell::remove_layers "def
remove_layers(self, args, kwargs)

remove_layers(Cell self)  void remove_layers()  Removes all layers
from this cell. ";

%feature("docstring")  cmf_core::Cell::remove_storage "def
remove_storage(self, args, kwargs)

remove_storage(Cell self, cmf::water::WaterStorage::ptr storage)  void
remove_storage(cmf::water::WaterStorage::ptr storage) ";

%feature("docstring")  cmf_core::Cell::set_aerodynamic_resistance "def set_aerodynamic_resistance(self, args, kwargs)

set_aerodynamic_resistance(Cell self,
cmf::atmosphere::aerodynamic_resistance::ptr Ra)  void
set_aerodynamic_resistance(cmf::atmosphere::aerodynamic_resistance::ptr
Ra)  Sets the method to calculate aerodynamic resistance against
turbulent sensible heat fluxes. ";

%feature("docstring")  cmf_core::Cell::set_rainfall "def
set_rainfall(self, args, kwargs)

set_rainfall(Cell self, double rainfall)  void set_rainfall(double
rainfall)  Exchanges a timeseries of rainfall with a constant flux. ";

%feature("docstring")  cmf_core::Cell::set_uptakestress "def
set_uptakestress(self, args, kwargs)

set_uptakestress(Cell self, RootUptakeStessFunction stressfunction)
void set_uptakestress(const ET::RootUptakeStessFunction
&stressfunction)  Uses the given WaterStressFunction for all
stressedET like connections to the transpiration target. ";

%feature("docstring")  cmf_core::Cell::set_weather "def
set_weather(self, args, kwargs)

set_weather(Cell self, Weather weather)  void set_weather(const
cmf::atmosphere::Weather &weather)  Sets the weather for this cell.
Connectivity to a meteorological station is lost. ";

%feature("docstring")  cmf_core::Cell::set_WKB "def set_WKB(self,
args, kwargs)

set_WKB(Cell self, cmf::bytestring wkb)  void set_WKB(cmf::bytestring
wkb) ";

%feature("docstring")  cmf_core::Cell::snow_coverage "def
snow_coverage(self, args, kwargs)

snow_coverage(Cell self) -> real  real snow_coverage() const ";

%feature("docstring")  cmf_core::Cell::storage_count "def
storage_count(self, args, kwargs)

storage_count(Cell self) -> size_t  size_t storage_count() const ";

%feature("docstring")  cmf_core::Cell::storages "def storages(self)
";

%feature("docstring")  cmf_core::Cell::surface_storages "def
surface_storages(self) ";

%feature("docstring")  cmf_core::Cell::surface_water_coverage "def
surface_water_coverage(self, args, kwargs)

surface_water_coverage(Cell self) -> real  real
surface_water_coverage() const  Returns the coverage of the surface
water.  The covered fraction (0..1) is simply modelled as a piecewise
linear function of the surface water depth. If the depth is above the
aggregate height, the coverage is 1, below it is given as   .. math::
c =     \\\\\\\\frac{h_{water}}{\\\\\\\\Delta h_{surface}}  with c the
coverage, :math:`h_{water}` the depth of the surface water and
:math:`\\\\\\\\Delta h_{surface}` the amplitude of the surface
roughness ";

%feature("docstring")  cmf_core::Cell::surfacewater_as_storage "def
surfacewater_as_storage(self, args, kwargs)

surfacewater_as_storage(Cell self) -> cmf::upslope::surfacewater_ptr
surfacewater_ptr surfacewater_as_storage()  Makes the surfacewater of
this cell a cmf::upslope::SurfaceWater storage. ";

%feature("docstring")  cmf_core::Cell::to_string "def to_string(self,
args, kwargs)

to_string(Cell self) -> std::string  std::string to_string() const ";


// File: classcmf_1_1upslope_1_1cell__const__iterator.xml
%feature("docstring") cmf::upslope::cell_const_iterator "";

%feature("docstring")
cmf::upslope::cell_const_iterator::cell_const_iterator "cell_const_iterator(const cell_const_iterator &copy) ";

%feature("docstring")
cmf::upslope::cell_const_iterator::cell_const_iterator "cell_const_iterator(const cell_iterator &copy) ";

%feature("docstring")  cmf::upslope::cell_const_iterator::as_iterator
"const_iterator as_iterator() ";

%feature("docstring")  cmf::upslope::cell_const_iterator::ptr "const
cmf::upslope::Cell* ptr() const ";


// File: classcmf_1_1upslope_1_1cell__iterator.xml
%feature("docstring") cmf::upslope::cell_iterator "";

%feature("docstring")  cmf::upslope::cell_iterator::cell_iterator "cell_iterator() ";

%feature("docstring")  cmf::upslope::cell_iterator::cell_iterator "cell_iterator(const cell_iterator &copy) ";

%feature("docstring")  cmf::upslope::cell_iterator::as_iterator "iterator as_iterator() ";

%feature("docstring")  cmf::upslope::cell_iterator::ptr "cmf::upslope::Cell* ptr() const ";


// File: classcmf_1_1upslope_1_1cell__vector.xml
%feature("docstring") cmf::upslope::cell_vector "

A cell vector holds a bunch of cells.

C++ includes: cell_vector.h ";

%feature("docstring")  cmf::upslope::cell_vector::cell_vector "cell_vector() ";

%feature("docstring")  cmf::upslope::cell_vector::cell_vector "cell_vector(const cell_vector &copy) ";

%feature("docstring")  cmf::upslope::cell_vector::cell_vector "cell_vector(cell_const_iterator first, cell_const_iterator last) ";

%feature("docstring")  cmf::upslope::cell_vector::~cell_vector "virtual ~cell_vector() ";

%feature("docstring")  cmf::upslope::cell_vector::append "void
append(cmf::upslope::Cell &cell) ";

%feature("docstring")  cmf::upslope::cell_vector::as_set "std::set<Cell*> as_set() ";

%feature("docstring")  cmf::upslope::cell_vector::begin "cell_iterator begin() ";

%feature("docstring")  cmf::upslope::cell_vector::begin "cell_const_iterator begin() const ";

%feature("docstring")  cmf::upslope::cell_vector::contains "bool
contains(const cmf::upslope::Cell &cell) const ";

%feature("docstring")  cmf::upslope::cell_vector::end "cell_iterator
end() ";

%feature("docstring")  cmf::upslope::cell_vector::end "cell_const_iterator end() const ";

%feature("docstring")  cmf::upslope::cell_vector::get_area "double
get_area() const

Returns sum of the area of the cells. ";

%feature("docstring")  cmf::upslope::cell_vector::get_highest "Cell&
get_highest() const

Returns the heighest cell. ";

%feature("docstring")  cmf::upslope::cell_vector::get_lowest "Cell&
get_lowest() const

Returns the cell with the lowest height. ";

%feature("docstring")  cmf::upslope::cell_vector::get_slice "cell_vector get_slice(ptrdiff_t start, ptrdiff_t end, ptrdiff_t
step=1) ";

%feature("docstring")  cmf::upslope::cell_vector::get_states "cmf::math::StateVariableList get_states()

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf::upslope::cell_vector::pop "Cell& pop()

Returns and removes the last cell. ";

%feature("docstring")  cmf::upslope::cell_vector::ptr_begin "cellvec::iterator ptr_begin() ";

%feature("docstring")  cmf::upslope::cell_vector::ptr_end "cellvec::iterator ptr_end() ";

%feature("docstring")  cmf::upslope::cell_vector::remove "void
remove(ptrdiff_t index) ";

%feature("docstring")  cmf::upslope::cell_vector::remove "void
remove(const cmf::upslope::Cell &cell) ";

%feature("docstring")  cmf::upslope::cell_vector::size "size_t size()
const ";


// File: classcmf__core_1_1cell__vector.xml
%feature("docstring") cmf_core::cell_vector "

A cell vector holds a bunch of cells.  C++ includes: cell_vector.h ";

%feature("docstring")  cmf_core::cell_vector::__init__ "def
__init__(self, args)

__init__(cmf::upslope::cell_vector self) -> cell_vector
__init__(cmf::upslope::cell_vector self, cell_vector copy) ->
cell_vector  cell_vector(cell_const_iterator first,
cell_const_iterator last) ";

%feature("docstring")  cmf_core::cell_vector::__contains__ "def
__contains__(self, args, kwargs)

__contains__(cell_vector self, Cell cell) -> bool  bool contains(const
cmf::upslope::Cell &cell) const ";

%feature("docstring")  cmf_core::cell_vector::__getitem__ "def
__getitem__(self, args)

__getitem__(cell_vector self, ptrdiff_t index) -> Cell
__getitem__(cell_vector self, ptrdiff_t index) -> Cell ";

%feature("docstring")  cmf_core::cell_vector::__getslice__ "def
__getslice__(self, args, kwargs)

__getslice__(cell_vector self, ptrdiff_t start, ptrdiff_t end,
ptrdiff_t step=1) -> cell_vector  cell_vector get_slice(ptrdiff_t
start, ptrdiff_t end, ptrdiff_t step=1) ";

%feature("docstring")  cmf_core::cell_vector::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::cell_vector::__len__ "def
__len__(self, args, kwargs)

__len__(cell_vector self) -> size_t  size_t size() const ";

%feature("docstring")  cmf_core::cell_vector::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::cell_vector::append "def
append(self, args, kwargs)

append(cell_vector self, Cell cell)  void append(cmf::upslope::Cell
&cell) ";

%feature("docstring")  cmf_core::cell_vector::get_area "def
get_area(self, args, kwargs)

get_area(cell_vector self) -> double  double get_area() const  Returns
sum of the area of the cells. ";

%feature("docstring")  cmf_core::cell_vector::get_states "def
get_states(self, args, kwargs)

get_states(StateVariableOwner self) -> StateVariableList  virtual
StateVariableList get_states()=0  Add the state variables, owned by an
object derived from StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf_core::cell_vector::pop "def pop(self,
args, kwargs)

pop(cell_vector self) -> Cell  Cell& pop()  Returns and removes the
last cell. ";

%feature("docstring")  cmf_core::cell_vector::remove "def
remove(self, args)

remove(cell_vector self, ptrdiff_t index) remove(cell_vector self,
Cell cell)  void remove(const cmf::upslope::Cell &cell) ";


// File: classcmf_1_1upslope_1_1_cell_connector.xml
%feature("docstring") cmf::upslope::CellConnector "

A helper class to connect cells with flux_connection objects. This is
generated by flux_connection classes, intended to connect cells.

C++ includes: cell.h ";

%feature("docstring")  cmf::upslope::CellConnector::CellConnector "CellConnector(connectorfunction connector) ";

%feature("docstring")  cmf::upslope::CellConnector::connect "void
connect(cmf::upslope::Cell &cell1, cmf::upslope::Cell &cell2,
ptrdiff_t start_at_layer=0) const ";


// File: classcmf__core_1_1_cell_connector.xml
%feature("docstring") cmf_core::CellConnector "

A helper class to connect cells with flux_connection objects. This is
generated by flux_connection classes, intended to connect cells.  C++
includes: cell.h ";

%feature("docstring")  cmf_core::CellConnector::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::CellConnector self,
cmf::upslope::connectorfunction connector) -> CellConnector
CellConnector(connectorfunction connector) ";

%feature("docstring")  cmf_core::CellConnector::__call__ "def
__call__(self, args, kwargs)

__call__(CellConnector self, Cell cell1, Cell cell2, ptrdiff_t
start_at_layer=0) ";

%feature("docstring")  cmf_core::CellConnector::connect "def
connect(self, args, kwargs)

connect(CellConnector self, Cell cell1, Cell cell2, ptrdiff_t
start_at_layer=0)  void connect(cmf::upslope::Cell &cell1,
cmf::upslope::Cell &cell2, ptrdiff_t start_at_layer=0) const ";


// File: classcmf_1_1draw_1_1cellmap_1_1_cell_map.xml
%feature("docstring") cmf::draw::cellmap::CellMap "

Draws a map of the cell geometries. Only functional, when shapely is
installed.  A CellMap is created with cells to show and a function
returning a value from a cell  Usage example: >>>import cmf
>>>p=cmf.project() >>>def saturated_depth(c): ...    return
c.saturated_depth >>>cm = CellMap(p, saturated_depth) ";

%feature("docstring")  cmf::draw::cellmap::CellMap::__init__ "def
__init__(self, cells, value_function, cmap=default_colormap,
hold=True, vmin=None, vmax=None, kwargs)

Creates a new map from cells  :param cells: :param value_function:
:param cmap: :param hold: :param vmin: :param vmax: :param kwargs: ";

%feature("docstring")  cmf::draw::cellmap::CellMap::__call__ "def
__call__(self, recalc_range=False) ";

%feature("docstring")  cmf::draw::cellmap::CellMap::autoscale "def
autoscale(self)

Overwrite base class of maplotlib.cm.ScalarMappable to prevent missuse
";

%feature("docstring")  cmf::draw::cellmap::CellMap::autoscale_None "def autoscale_None(self)

Overwrite base class of maplotlib.cm.ScalarMappable to prevent missuse
";

%feature("docstring")  cmf::draw::cellmap::CellMap::color_values "def
color_values(self) ";

%feature("docstring")  cmf::draw::cellmap::CellMap::f "def f(self) ";

%feature("docstring")  cmf::draw::cellmap::CellMap::f "def f(self,
funct) ";

%feature("docstring")  cmf::draw::cellmap::CellMap::get_artists "def
get_artists(self)

Returns the list of matplotlib.patches.Polygons in the cell map.
Useful for Animations  :return: iterable of polygons ";


// File: classcmf_1_1river_1_1_channel.xml
%feature("docstring") cmf::river::Channel "

A wrapper for channel geometries.

C++ includes: ReachType.h ";

%feature("docstring")  cmf::river::Channel::Channel "Channel() ";

%feature("docstring")  cmf::river::Channel::Channel "Channel(double
length)

Creates a triangular reach of a length. ";

%feature("docstring")  cmf::river::Channel::Channel "Channel(const
IChannel &for_wrapping)

Wraps an existing channel geometry. ";

%feature("docstring")  cmf::river::Channel::Channel "Channel(const
IVolumeHeightFunction &for_casting) ";

%feature("docstring")  cmf::river::Channel::Channel "Channel(const
Channel &for_copy)

Copy constructable. ";

%feature("docstring")  cmf::river::Channel::Channel "Channel(char
typecode, double length, double width=1., double depth=0.25)

Creates a reachtype using a short cut character.

Acceptes one of the following characters: 'T' TriangularReach, width
and depth are ignored.

'R' RectangularReach, depth is ignored

'P' PipeReach, depth is ignored, width is the diameter of the pipe

'S' SWATReachType, a trapezoid flow cross section, as used in the SWAT
model, width (bank width) and depth are used the reach type

Parameters:
-----------

typecode:  Describes the geometry of the reach cross section.

length:  The length of the channel in m

width:  width of the reach cross section in m (ignored for typecode
'T')

depth:  depth of the reach (ignored for typecode 'T','R','P','S') ";

%feature("docstring")  cmf::river::Channel::~Channel "virtual
~Channel() ";

%feature("docstring")  cmf::river::Channel::A "virtual double
A(double V) const

Returns the area of the surface for a given volume. ";

%feature("docstring")  cmf::river::Channel::copy "Channel* copy()
const ";

%feature("docstring")  cmf::river::Channel::get_channel_width "double
get_channel_width(double depth) const

Calculates the flow width from a given actual depth [m] using the
actual IChannel geometry. ";

%feature("docstring")  cmf::river::Channel::get_depth "double
get_depth(double area) const

Calculates the actual depth of the reach using the IChannel geometry.

get_depth of the reach [m]

Parameters:
-----------

area:  Wetted area of a river cross section [m2], can be obtained by
V/l, where V is the stored volume and l is the reach length ";

%feature("docstring")  cmf::river::Channel::get_flux_crossection "double get_flux_crossection(double depth) const

Calculates the wetted area from a given depth using the IChannel
geometry.

In most cases use get_flux_crossection=V/l, where V is the stored
volume and l is the reach length Wetted area of a river cross section
[m2]

Parameters:
-----------

depth:  depth of the reach [m] ";

%feature("docstring")  cmf::river::Channel::get_length "double
get_length() const

Length of the reach. ";

%feature("docstring")  cmf::river::Channel::get_nManning "double
get_nManning() const ";

%feature("docstring")  cmf::river::Channel::get_wetted_perimeter "double get_wetted_perimeter(double depth) const

Calculates the wetted perimeter from a given actual depth [m] using
the actual IChannel geometry. ";

%feature("docstring")  cmf::river::Channel::h "virtual double
h(double V) const

Returns the depth of a given volume. ";

%feature("docstring")  cmf::river::Channel::q "virtual double
q(double h, double slope) const ";

%feature("docstring")  cmf::river::Channel::qManning "virtual double
qManning(double A, double slope) const

Calculates the flow rate from a given water volume in the reach


.. math::

     q_{Manning}&=& A R^{\\\\frac 2 3}
    \\\\sqrt{\\\\frac {\\\\Delta_z} n} \\\\\\\\ A &=& \\\\frac V l
    \\\\mbox{, (Crosssectional area of the wetted crossection, Volume per
    length)} \\\\\\\\ R &=& \\\\frac A {P(d)} \\\\\\\\ P(d) &=& \\\\mbox{
    the perimeter of the wetted crosssection, a function of reach depth}
    \\\\\\\\ d(V) &=& \\\\mbox{ the depth of the reach a function of the
    volume} \\\\\\\\ \\\\Delta_z &=& \\\\frac{z_{max} - z_{min}}{l}
    \\\\mbox{ Slope of the reach} 

.

Flow rate [m3/s]

Parameters:
-----------

A:  The area of the cross section [m2]

slope:  The slope of the reach [m/m] ";

%feature("docstring")  cmf::river::Channel::set_nManning "void
set_nManning(double val) ";

%feature("docstring")  cmf::river::Channel::typecode "char typecode()
const ";

%feature("docstring")  cmf::river::Channel::V "virtual double
V(double h) const ";


// File: classcmf__core_1_1_channel.xml
%feature("docstring") cmf_core::Channel "

A wrapper for channel geometries.  C++ includes: ReachType.h ";

%feature("docstring")  cmf_core::Channel::__init__ "def
__init__(self, args)

__init__(cmf::river::Channel self) -> Channel
__init__(cmf::river::Channel self, double length) -> Channel
__init__(cmf::river::Channel self, IChannel for_wrapping) -> Channel
__init__(cmf::river::Channel self, IVolumeHeightFunction for_casting)
-> Channel __init__(cmf::river::Channel self, Channel for_copy) ->
Channel __init__(cmf::river::Channel self, char typecode, double
length, double width=1., double depth=0.25) -> Channel  Channel(char
typecode, double length, double width=1., double depth=0.25)  Creates
a reachtype using a short cut character.  Acceptes one of the
following characters: 'T' TriangularReach, width and depth are
ignored.  'R' RectangularReach, depth is ignored  'P' PipeReach, depth
is ignored, width is the diameter of the pipe  'S' SWATReachType, a
trapezoid flow cross section, as used in the SWAT model, width (bank
width) and depth are used the reach type  Parameters: -----------
typecode:  Describes the geometry of the reach cross section.  length:
The length of the channel in m  width:  width of the reach cross
section in m (ignored for typecode 'T')  depth:  depth of the reach
(ignored for typecode 'T','R','P','S') ";

%feature("docstring")  cmf_core::Channel::A "def A(self, args,
kwargs)

A(IVolumeHeightFunction self, double V) -> double  virtual double
A(double V) const =0  Returns the area of the surface for a given
volume. ";

%feature("docstring")  cmf_core::Channel::copy "def copy(self, args,
kwargs)

copy(Channel self) -> Channel  Channel* copy() const ";

%feature("docstring")  cmf_core::Channel::get_channel_width "def
get_channel_width(self, args, kwargs)

get_channel_width(IChannel self, double depth) -> double  virtual
double get_channel_width(double depth) const =0  Calculates the flow
width from a given actual depth [m] using the actual IChannel
geometry. ";

%feature("docstring")  cmf_core::Channel::get_depth "def
get_depth(self, args, kwargs)

get_depth(IChannel self, double area) -> double  virtual double
get_depth(double area) const =0  Calculates the actual depth of the
reach using the IChannel geometry.  get_depth of the reach [m]
Parameters: -----------  area:  Wetted area of a river cross section
[m2], can be obtained by V/l, where V is the stored volume and l is
the reach length ";

%feature("docstring")  cmf_core::Channel::get_flux_crossection "def
get_flux_crossection(self, args, kwargs)

get_flux_crossection(IChannel self, double depth) -> double  virtual
double get_flux_crossection(double depth) const =0  Calculates the
wetted area from a given depth using the IChannel geometry.  In most
cases use get_flux_crossection=V/l, where V is the stored volume and l
is the reach length Wetted area of a river cross section [m2]
Parameters: -----------  depth:  depth of the reach [m] ";

%feature("docstring")  cmf_core::Channel::get_length "def
get_length(self, args, kwargs)

get_length(IChannel self) -> double  virtual double get_length() const
=0  Length of the reach. ";

%feature("docstring")  cmf_core::Channel::get_nManning "def
get_nManning(self, args, kwargs)

get_nManning(IChannel self) -> double  virtual double get_nManning()
const =0 ";

%feature("docstring")  cmf_core::Channel::get_wetted_perimeter "def
get_wetted_perimeter(self, args, kwargs)

get_wetted_perimeter(IChannel self, double depth) -> double  virtual
double get_wetted_perimeter(double depth) const =0  Calculates the
wetted perimeter from a given actual depth [m] using the actual
IChannel geometry. ";

%feature("docstring")  cmf_core::Channel::h "def h(self, args,
kwargs)

h(IVolumeHeightFunction self, double V) -> double  virtual double
h(double V) const =0  Returns the depth of a given volume. ";

%feature("docstring")  cmf_core::Channel::q "def q(self, args,
kwargs)

q(IVolumeHeightFunction self, double h, double slope) -> double
virtual double q(double h, double slope) const ";

%feature("docstring")  cmf_core::Channel::qManning "def
qManning(self, args, kwargs)

qManning(IChannel self, double A, double slope) -> double  virtual
double qManning(double A, double slope) const  Calculates the flow
rate from a given water volume in the reach   .. math:: q_{Manning}&=&
A R^{\\\\\\\\frac 2 3}     \\\\\\\\sqrt{\\\\\\\\frac {\\\\\\\\Delta_z}
n} \\\\\\\\\\\\\\\\ A &=& \\\\\\\\frac V l \\\\\\\\mbox{,
(Crosssectional area of the wetted crossection, Volume per
length)} \\\\\\\\\\\\\\\\ R &=& \\\\\\\\frac A {P(d)} \\\\\\\\\\\\\\\\
P(d) &=& \\\\\\\\mbox{     the perimeter of the wetted crosssection, a
function of reach depth}     \\\\\\\\\\\\\\\\ d(V) &=& \\\\\\\\mbox{
the depth of the reach a function of the volume} \\\\\\\\\\\\\\\\
\\\\\\\\Delta_z &=& \\\\\\\\frac{z_{max} - z_{min}}{l}
\\\\\\\\mbox{ Slope of the reach}   .  Flow rate [m3/s]  Parameters:
-----------  A:  The area of the cross section [m2]  slope:  The slope
of the reach [m/m] ";

%feature("docstring")  cmf_core::Channel::set_nManning "def
set_nManning(self, args, kwargs)

set_nManning(IChannel self, double val)  virtual void
set_nManning(double val)=0 ";

%feature("docstring")  cmf_core::Channel::typecode "def
typecode(self, args, kwargs)

typecode(IChannel self) -> char  virtual char typecode() const =0 ";

%feature("docstring")  cmf_core::Channel::V "def V(self, args,
kwargs)

V(IVolumeHeightFunction self, double h) -> double  virtual double
V(double h) const =0 ";


// File: classcmf_1_1upslope_1_1conductable.xml
%feature("docstring") cmf::upslope::conductable "

An abstract interface for all classes providing a conductivity (e.g.

soil layer or aquifer) Each water storage where the concept of
conductivity is applicable should implement (by deriving) the
interface

This class is not part of the Python interface, since a dynamic typed
language can use duck typing instead of this interface

C++ includes: conductable.h ";

%feature("docstring")  cmf::upslope::conductable::get_K "virtual real
get_K(cmf::geometry::point direction) const =0 ";


// File: classcmf__core_1_1connection__list.xml
%feature("docstring") cmf_core::connection_list "

A self sorting list of connections.  C++ includes: flux_connection.h
";

%feature("docstring")  cmf_core::connection_list::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::water::connection_list self) -> connection_list ";

%feature("docstring")  cmf_core::connection_list::__contains__ "def
__contains__(self, args, kwargs)

__contains__(connection_list self, cmf::water::flux_connection::ptr
const & con) -> bool ";

%feature("docstring")  cmf_core::connection_list::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::connection_list::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::connection_list::__len__ "def
__len__(self, args, kwargs)

__len__(connection_list self) -> size_t ";

%feature("docstring")  cmf_core::connection_list::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::connection_list::append "def
append(self, args, kwargs)

append(connection_list self, cmf::water::flux_connection::ptr
connection) -> bool  bool append(cmf::water::flux_connection::ptr
connection) ";

%feature("docstring")  cmf_core::connection_list::at "def at(self,
args, kwargs)

at(connection_list self, size_t pos) ->
cmf::water::flux_connection::ptr  cmf::water::flux_connection::ptr
at(size_t pos) const ";

%feature("docstring")  cmf_core::connection_list::begin "def
begin(self, args)

begin(connection_list self) -> cmf::water::connection_list::iterator
begin(connection_list self) ->
cmf::water::connection_list::const_iterator  const_iterator begin()
const ";

%feature("docstring")  cmf_core::connection_list::contains "def
contains(self, args, kwargs)

contains(connection_list self, cmf::water::flux_connection::ptr
connection) -> bool  bool contains(cmf::water::flux_connection::ptr
connection) const ";

%feature("docstring")  cmf_core::connection_list::do_action "def
do_action(self, args, kwargs)

do_action(connection_list self, Time t, bool use_OpenMP=True)  void
do_action(cmf::math::Time t, bool use_OpenMP=true) ";

%feature("docstring")  cmf_core::connection_list::end "def end(self,
args)

end(connection_list self) -> cmf::water::connection_list::iterator
end(connection_list self) ->
cmf::water::connection_list::const_iterator  const_iterator end()
const ";

%feature("docstring")  cmf_core::connection_list::extend "def
extend(self, args, kwargs)

extend(connection_list self, connection_list connections)  void
extend(const connection_list &connections) ";

%feature("docstring")  cmf_core::connection_list::remove "def
remove(self, args, kwargs)

remove(connection_list self, cmf::water::flux_connection::ptr
connection) -> bool  bool remove(cmf::water::flux_connection::ptr
connection) ";

%feature("docstring")  cmf_core::connection_list::size "def
size(self, args, kwargs)

size(connection_list self) -> size_t  size_t size() const ";


// File: classcmf_1_1water_1_1connection__list.xml
%feature("docstring") cmf::water::connection_list "

A self sorting list of connections.

C++ includes: flux_connection.h ";

%feature("docstring")  cmf::water::connection_list::~connection_list "virtual ~connection_list() ";

%feature("docstring")  cmf::water::connection_list::append "bool
append(cmf::water::flux_connection::ptr connection) ";

%feature("docstring")  cmf::water::connection_list::at "cmf::water::flux_connection::ptr at(size_t pos) const ";

%feature("docstring")  cmf::water::connection_list::begin "iterator
begin() ";

%feature("docstring")  cmf::water::connection_list::begin "const_iterator begin() const ";

%feature("docstring")  cmf::water::connection_list::contains "bool
contains(cmf::water::flux_connection::ptr connection) const ";

%feature("docstring")  cmf::water::connection_list::do_action "void
do_action(cmf::math::Time t, bool use_OpenMP=true) ";

%feature("docstring")  cmf::water::connection_list::end "iterator
end() ";

%feature("docstring")  cmf::water::connection_list::end "const_iterator end() const ";

%feature("docstring")  cmf::water::connection_list::extend "void
extend(const connection_list &connections) ";

%feature("docstring")  cmf::water::connection_list::remove "bool
remove(cmf::water::flux_connection::ptr connection) ";

%feature("docstring")  cmf::water::connection_list::size "size_t
size() const ";


// File: classcmf__core_1_1constant_e_tpot.xml
%feature("docstring") cmf_core::constantETpot "

A constant evapotranspiration.  Uses a constant measured or elsewhere
modelled ETpot. Actual Evapotranspiration is calculated from rootdepth
and actual matrix potential in the layers using Tact. The value of
ETpot can be changed during runtime  C++ includes: ET.h ";

%feature("docstring")  cmf_core::constantETpot::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::ET::constantETpot self,
cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr
ET_target, double constantETpot_value) -> constantETpot
constantETpot(cmf::upslope::SoilLayer::ptr source,
cmf::water::flux_node::ptr ET_target, double constantETpot_value) ";

%feature("docstring")  cmf_core::constantETpot::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::constantETpot::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::constantETpot::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::constantETpot::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::constantETpot::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::constantETpot::conc "def conc(self,
args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::constantETpot::ETpot "def
ETpot(self, args, kwargs)

ETpot(stressedET self, Time t) -> real  virtual real
ETpot(cmf::math::Time t) const ";

%feature("docstring")  cmf_core::constantETpot::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::constantETpot::get_layer "def
get_layer(self, args, kwargs)

get_layer(stressedET self) -> cmf::upslope::SoilLayer::ptr
SoilLayer::ptr get_layer() const ";

%feature("docstring")  cmf_core::constantETpot::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::constantETpot::get_tracer_filter "def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::constantETpot::GetETpot "def
GetETpot(self, args, kwargs)

GetETpot(constantETpot self, Time t) -> real  real
GetETpot(cmf::math::Time t) const ";

%feature("docstring")  cmf_core::constantETpot::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::constantETpot::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::constantETpot::q "def q(self, args,
kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::constantETpot::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::constantETpot::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::constantETpot::set_stressfunction "def set_stressfunction(self, args, kwargs)

set_stressfunction(stressedET self, RootUptakeStessFunction
stressfunction)  void set_stressfunction(const RootUptakeStessFunction
&stressfunction)  Sets the stress function to limit water uptake. ";

%feature("docstring")  cmf_core::constantETpot::set_tracer_filter "def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::constantETpot::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::constantETpot::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1_e_t_1_1constant_e_tpot.xml
%feature("docstring") cmf::upslope::ET::constantETpot "

A constant evapotranspiration.

Uses a constant measured or elsewhere modelled ETpot. Actual
Evapotranspiration is calculated from rootdepth and actual matrix
potential in the layers using Tact. The value of ETpot can be changed
during runtime

C++ includes: ET.h ";

%feature("docstring")  cmf::upslope::ET::constantETpot::constantETpot
"constantETpot(cmf::upslope::SoilLayer::ptr source,
cmf::water::flux_node::ptr ET_target, double constantETpot_value) ";

%feature("docstring")  cmf::upslope::ET::constantETpot::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")  cmf::upslope::ET::constantETpot::ETpot "virtual real ETpot(cmf::math::Time t) const ";

%feature("docstring")
cmf::upslope::ET::constantETpot::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::upslope::ET::constantETpot::get_layer "SoilLayer::ptr get_layer() const ";

%feature("docstring")  cmf::upslope::ET::constantETpot::get_ptr "ptr
get_ptr() const ";

%feature("docstring")  cmf::upslope::ET::constantETpot::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::ET::constantETpot::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::ET::constantETpot::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::constantETpot::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::ET::constantETpot::GetETpot "real GetETpot(cmf::math::Time t) const ";

%feature("docstring")  cmf::upslope::ET::constantETpot::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::upslope::ET::constantETpot::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::ET::constantETpot::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::ET::constantETpot::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::upslope::ET::constantETpot::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::ET::constantETpot::set_stressfunction "void
set_stressfunction(const RootUptakeStessFunction &stressfunction)

Sets the stress function to limit water uptake. ";

%feature("docstring")
cmf::upslope::ET::constantETpot::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::constantETpot::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf::upslope::ET::constantETpot::short_string "virtual std::string short_string() const ";

%feature("docstring")  cmf::upslope::ET::constantETpot::to_string "std::string to_string() const ";


// File: classcmf_1_1atmosphere_1_1_constant_meteorology.xml
%feature("docstring") cmf::atmosphere::ConstantMeteorology "

A primitive implementation of the Meteorology interface.

Holds a Weather record and returns it for any date

C++ includes: meteorology.h ";

%feature("docstring")
cmf::atmosphere::ConstantMeteorology::ConstantMeteorology "ConstantMeteorology()

Creates a ConstantMeteorology with a standard weather. ";

%feature("docstring")
cmf::atmosphere::ConstantMeteorology::ConstantMeteorology "ConstantMeteorology(const cmf::atmosphere::Weather &w)

Creates a ConstantMeteorology with weather w. ";

%feature("docstring")
cmf::atmosphere::ConstantMeteorology::ConstantMeteorology "ConstantMeteorology(const cmf::atmosphere::ConstantMeteorology &other)

Copy constructor. ";

%feature("docstring")  cmf::atmosphere::ConstantMeteorology::copy "ConstantMeteorology* copy() const

Creates a new instannce of the ConstantMeteorology with the same
weather. ";

%feature("docstring")
cmf::atmosphere::ConstantMeteorology::get_instrument_height "virtual
real get_instrument_height() const

Returns the height of the instruments above canopy. ";

%feature("docstring")
cmf::atmosphere::ConstantMeteorology::get_weather "virtual
cmf::atmosphere::Weather get_weather(cmf::math::Time t) const

Returns weather, regardless of t. ";


// File: classcmf__core_1_1_constant_meteorology.xml
%feature("docstring") cmf_core::ConstantMeteorology "

A primitive implementation of the Meteorology interface.  Holds a
Weather record and returns it for any date  C++ includes:
meteorology.h ";

%feature("docstring")  cmf_core::ConstantMeteorology::__init__ "def
__init__(self, args)

__init__(cmf::atmosphere::ConstantMeteorology self) ->
ConstantMeteorology __init__(cmf::atmosphere::ConstantMeteorology
self, Weather w) -> ConstantMeteorology
__init__(cmf::atmosphere::ConstantMeteorology self,
ConstantMeteorology other) -> ConstantMeteorology
ConstantMeteorology(const cmf::atmosphere::ConstantMeteorology &other)
Copy constructor. ";

%feature("docstring")  cmf_core::ConstantMeteorology::__call__ "def
__call__(self, args, kwargs)

__call__(Meteorology self, Time t) -> Weather ";

%feature("docstring")  cmf_core::ConstantMeteorology::copy "def
copy(self, args, kwargs)

copy(ConstantMeteorology self) -> ConstantMeteorology
ConstantMeteorology* copy() const  Creates a new instannce of the
ConstantMeteorology with the same weather. ";

%feature("docstring")
cmf_core::ConstantMeteorology::get_instrument_height "def
get_instrument_height(self, args, kwargs)

get_instrument_height(Meteorology self) -> real  virtual real
get_instrument_height() const =0  Returns the height of the
instruments above canopy. ";

%feature("docstring")  cmf_core::ConstantMeteorology::get_weather "def get_weather(self, args, kwargs)

get_weather(Meteorology self, Time t) -> Weather  virtual
cmf::atmosphere::Weather get_weather(cmf::math::Time t) const =0
Returns the Weather at time t. Pure virtual function. Must get
implemented by child functions. ";


// File: classcmf_1_1atmosphere_1_1_constant_rain_source.xml
%feature("docstring") cmf::atmosphere::ConstantRainSource "

A simple implementation of RainSource.

Returns intensity for any time step.

C++ includes: precipitation.h ";

%feature("docstring")
cmf::atmosphere::ConstantRainSource::ConstantRainSource "ConstantRainSource(cmf::project &_project, cmf::geometry::point
location, real _intensity)

Creates a new ConstantRainSource.

Consider using Cell::set_rainfall for internal creation of a constant
rain source, instead of direct use

Parameters:
-----------

_project:  The project the rain source is belonging to.

location:  The location of the rain source

_intensity:  The constant rainfall intensity in mm/day ";

%feature("docstring")  cmf::atmosphere::ConstantRainSource::conc "virtual real conc(cmf::math::Time t, const cmf::water::solute &Solute)
const

Returns the concentration of a solute in the rainfall at time t. ";

%feature("docstring")
cmf::atmosphere::ConstantRainSource::connection_to "cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::atmosphere::ConstantRainSource::flux3d_to
"cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf::atmosphere::ConstantRainSource::flux_to "real flux_to(const cmf::water::flux_node &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")
cmf::atmosphere::ConstantRainSource::get_3d_flux "cmf::geometry::point get_3d_flux(cmf::math::Time t)

Returns the sum of all flux vectors. ";

%feature("docstring")
cmf::atmosphere::ConstantRainSource::get_connections "cmf::water::connection_list get_connections() const ";

%feature("docstring")
cmf::atmosphere::ConstantRainSource::get_intensity "real
get_intensity(cmf::math::Time t) const

Returns the actual rainfall intensity in mm/day. ";

%feature("docstring")
cmf::atmosphere::ConstantRainSource::get_potential "virtual real
get_potential() const

Returns the water potential of the node in m waterhead.

The base class water storage always returns the height of the location
";

%feature("docstring")
cmf::atmosphere::ConstantRainSource::get_project "cmf::project&
get_project() const

Returns the project, this node is part of. ";

%feature("docstring")  cmf::atmosphere::ConstantRainSource::is_empty "virtual double is_empty() const

Returns false. ";

%feature("docstring")  cmf::atmosphere::ConstantRainSource::is_storage
"virtual bool is_storage() const

true, if this is a waterstorage ";

%feature("docstring")
cmf::atmosphere::ConstantRainSource::RecalcFluxes "virtual bool
RecalcFluxes(cmf::math::Time t)

Pure flux_nodes do not influence fluxes, therefore no recalculation of
fluxes is required by flux_node.

WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")
cmf::atmosphere::ConstantRainSource::remove_connection "bool
remove_connection(cmf::water::flux_node::ptr To)

Remove the connection. ";

%feature("docstring")  cmf::atmosphere::ConstantRainSource::set_conc "void set_conc(const cmf::water::solute &Solute, real value)

Sets the concentration of a solute in the rainfall. ";

%feature("docstring")
cmf::atmosphere::ConstantRainSource::set_potential "virtual void
set_potential(real new_potential)

Sets the potential of this flux node. ";

%feature("docstring")  cmf::atmosphere::ConstantRainSource::to_string
"virtual std::string to_string() const ";

%feature("docstring")
cmf::atmosphere::ConstantRainSource::waterbalance "real
waterbalance(cmf::math::Time t, const flux_connection *Without=0)
const

Returns the sum of all fluxes (positive and negative) at time t.

Single fluxes can be excluded from the calculation

Parameters:
-----------

t:  Time of the query

Without:  A flux_connection that is excluded from the waterbalance
(e.g. to prevent closed circuits) ";


// File: classcmf__core_1_1_constant_rain_source.xml
%feature("docstring") cmf_core::ConstantRainSource "

A simple implementation of RainSource.  Returns intensity for any time
step.  C++ includes: precipitation.h ";

%feature("docstring")  cmf_core::ConstantRainSource::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::atmosphere::ConstantRainSource self, project _project,
point location, real _intensity) -> ConstantRainSource
ConstantRainSource(cmf::project &_project, cmf::geometry::point
location, real _intensity)  Creates a new ConstantRainSource. Consider
using Cell::set_rainfall for internal creation of a constant rain
source, instead of direct use  Parameters: -----------  _project: The
project the rain source is belonging to.  location:  The location of
the rain source  _intensity:  The constant rainfall intensity in
mm/day ";

%feature("docstring")  cmf_core::ConstantRainSource::__call__ "def
__call__(self, args, kwargs)

__call__(RainSource self, Time t) -> real ";

%feature("docstring")  cmf_core::ConstantRainSource::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_node self, flux_node other) -> bool ";

%feature("docstring")  cmf_core::ConstantRainSource::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::ConstantRainSource::conc "def
conc(self, args, kwargs)

conc(flux_node self, Time t, solute Solute) -> real  virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const
Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf_core::ConstantRainSource::connected_nodes "def connected_nodes(self) ";

%feature("docstring")  cmf_core::ConstantRainSource::connection_to "def connection_to(self, args, kwargs)

connection_to(flux_node self, flux_node target) -> flux_connection
cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)  Returns the connection between this and target. ";

%feature("docstring")  cmf_core::ConstantRainSource::flux3d_to "def
flux3d_to(self, args, kwargs)

flux3d_to(flux_node self, flux_node target, Time t) -> point
cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf_core::ConstantRainSource::flux_to "def
flux_to(self, args, kwargs)

flux_to(flux_node self, flux_node target, Time t) -> real  real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)
Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf_core::ConstantRainSource::fluxes "def
fluxes(self, t) ";

%feature("docstring")  cmf_core::ConstantRainSource::get_3d_flux "def
get_3d_flux(self, args, kwargs)

get_3d_flux(flux_node self, Time t) -> point  cmf::geometry::point
get_3d_flux(cmf::math::Time t)  Returns the sum of all flux vectors.
";

%feature("docstring")  cmf_core::ConstantRainSource::get_intensity "def get_intensity(self, args, kwargs)

get_intensity(RainSource self, Time t) -> real  virtual real
get_intensity(cmf::math::Time t) const =0  Returns the actual rainfall
intensity in mm/day. ";

%feature("docstring")  cmf_core::ConstantRainSource::is_empty "def
is_empty(self, args, kwargs)

is_empty(flux_node self) -> double  virtual double is_empty() const
Returns true if the node has no water. ";

%feature("docstring")  cmf_core::ConstantRainSource::is_storage "def
is_storage(self, args, kwargs)

is_storage(flux_node self) -> bool  virtual bool is_storage() const
true, if this is a waterstorage ";

%feature("docstring")  cmf_core::ConstantRainSource::RecalcFluxes "def RecalcFluxes(self, args, kwargs)

RecalcFluxes(flux_node self, Time t) -> bool  virtual bool
RecalcFluxes(cmf::math::Time t)  Pure flux_nodes do not influence
fluxes, therefore no recalculation of fluxes is required by flux_node.
WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf_core::ConstantRainSource::remove_connection
"def remove_connection(self, args, kwargs)

remove_connection(flux_node self, cmf::water::flux_node::ptr To) ->
bool  bool remove_connection(cmf::water::flux_node::ptr To)  Remove
the connection. ";

%feature("docstring")  cmf_core::ConstantRainSource::set_conc "def
set_conc(self, args, kwargs)

set_conc(ConstantRainSource self, solute Solute, real value)  void
set_conc(const cmf::water::solute &Solute, real value)  Sets the
concentration of a solute in the rainfall. ";

%feature("docstring")  cmf_core::ConstantRainSource::to_string "def
to_string(self, args, kwargs)

to_string(flux_node self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::ConstantRainSource::waterbalance "def waterbalance(self, args, kwargs)

waterbalance(flux_node self, Time t, flux_connection Without=None) ->
real  real waterbalance(cmf::math::Time t, const flux_connection
*Without=0) const  Returns the sum of all fluxes (positive and
negative) at time t.  Single fluxes can be excluded from the
calculation  Parameters: -----------  t:  Time of the query  Without:
A flux_connection that is excluded from the waterbalance (e.g. to
prevent closed circuits) ";


// File: classcmf__core_1_1constraint__kinematic__wave.xml
%feature("docstring") cmf_core::constraint_kinematic_wave "

Calculates flux out of a storage as a linear function of its volume to
a power, constraint by the volume stored in the target storage.
Deprecated Will be replaced by ConstraintLinearStorageConnection,
without beta and gamma.   .. math::       q = \\\\\\\\frac 1 {t_r}
{\\\\\\\\left(\\\\\\\\frac{V_{l} - V_{residual}}{V_0}
\\\\\\\\right)^\\\\\\\\beta}
\\\\\\\\left(\\\\\\\\frac{V_{r,max}-V_{r}}{V_{r,max}}\\\\\\\\right)^\\\\\\\\gamma
where:  :math:`V_l` The actual volume stored by the left water storage
:math:`V_{residual} [m^3]` The volume of water not flowing out
(default = 0)  :math:`V_0` The reference volume to scale the exponent
(default = 1m3/day)  :math:`\\\\\\\\beta` A parameter to shape the
response curve. In case of :math:`\\\\\\\\beta \\\\\\\\neq 1`,
:math:`t_r` is not a residence time, but just a parameter.  :math:`t_r
[days]` The residence time of the water in this storage in days
:math:`V_{r,max}` The capacity of the right water storage in m3
:math:`V_{r}` The actual volume of the right water storage
:math:`\\\\\\\\gamma` A shape parameter for the target capacity
constriction  C++ includes: simple_connections.h ";

%feature("docstring")  cmf_core::constraint_kinematic_wave::__init__ "def __init__(self, args, kwargs)

__init__(cmf::water::constraint_kinematic_wave self,
cmf::water::WaterStorage::ptr source, cmf::water::WaterStorage::ptr
target, real residencetime=1.0, real exponent=1.0, real residual=0.0,
real V0=1.0, real Vrmax=1.0, real gamma=1.0) ->
constraint_kinematic_wave  constraint_kinematic_wave(WaterStorage::ptr
source, WaterStorage::ptr target, real residencetime=1.0, real
exponent=1.0, real residual=0.0, real V0=1.0, real Vrmax=1.0, real
gamma=1.0)  Creates a kinematic wave connection.    .. math::       q
= \\\\\\\\frac 1 {t_r} {\\\\\\\\left(\\\\\\\\frac{V -
V_{residual}}{V_0}     \\\\\\\\right)^\\\\\\\\beta}   Parameters:
-----------  source:  Water storage from which the water flows out.
Flux is a function of source.volume  target:  Target node (boundary
condition or storage). Does not influence the strength of the flow
residencetime:   :math:`t_r [days]` The residence time of the water in
this storage  exponent:   :math:`\\\\\\\\beta [-]` An empirical
exponent to shape the flux function (default = 1 (linear function))
residual:   :math:`V_{residual} [m^3]` The volume of water not flowing
out (default = 0)  V0:   :math:`V_0` The reference volume to scale the
exponent  Vrmax:   :math:`V_{r,max}` Capacity of the target water
storage in m3  gamma:   :math:`\\\\\\\\gamma` Target capacity
constriction curve shape ";

%feature("docstring")
cmf_core::constraint_kinematic_wave::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::constraint_kinematic_wave::__eq__ "def __eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")
cmf_core::constraint_kinematic_wave::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::constraint_kinematic_wave::__iter__ "def __iter__(self) ";

%feature("docstring")  cmf_core::constraint_kinematic_wave::__repr__ "def __repr__(self) ";

%feature("docstring")  cmf_core::constraint_kinematic_wave::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::constraint_kinematic_wave::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::constraint_kinematic_wave::get_target
"def get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::constraint_kinematic_wave::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::constraint_kinematic_wave::kill_me "def kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::constraint_kinematic_wave::left_node
"def left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::constraint_kinematic_wave::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::constraint_kinematic_wave::refresh "def refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::constraint_kinematic_wave::right_node
"def right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::constraint_kinematic_wave::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf_core::constraint_kinematic_wave::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::constraint_kinematic_wave::to_string
"def to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1water_1_1constraint__kinematic__wave.xml
%feature("docstring") cmf::water::constraint_kinematic_wave "

Calculates flux out of a storage as a linear function of its volume to
a power, constraint by the volume stored in the target storage.

Deprecated Will be replaced by ConstraintLinearStorageConnection,
without beta and gamma. 

.. math::

     q = \\\\frac 1 {t_r}
    {\\\\left(\\\\frac{V_{l} - V_{residual}}{V_0} \\\\right)^\\\\beta}
    \\\\left(\\\\frac{V_{r,max}-V_{r}}{V_{r,max}}\\\\right)^\\\\gamma

where:  :math:`V_l` The actual volume stored by the left water storage

:math:`V_{residual} [m^3]` The volume of water not flowing out (default = 0)

:math:`V_0` The reference volume to scale the exponent (default = 1m3/day)

:math:`\\\\beta` A parameter to shape the response curve. In case of
:math:`\\\\beta \\\\neq 1`, :math:`t_r` is not a residence time, but just a
parameter.

:math:`t_r [days]` The residence time of the water in this storage in days

:math:`V_{r,max}` The capacity of the right water storage in m3

:math:`V_{r}` The actual volume of the right water storage

:math:`\\\\gamma` A shape parameter for the target capacity constriction

C++ includes: simple_connections.h ";

%feature("docstring")
cmf::water::constraint_kinematic_wave::constraint_kinematic_wave "constraint_kinematic_wave(WaterStorage::ptr source, WaterStorage::ptr
target, real residencetime=1.0, real exponent=1.0, real residual=0.0,
real V0=1.0, real Vrmax=1.0, real gamma=1.0)

Creates a kinematic wave connection.



.. math::

     q = \\\\frac 1 {t_r} {\\\\left(\\\\frac{V - V_{residual}}{V_0}
    \\\\right)^\\\\beta} 

Parameters:
-----------

source:  Water storage from which the water flows out. Flux is a
function of source.volume

target:  Target node (boundary condition or storage). Does not
influence the strength of the flow

residencetime:   :math:`t_r [days]` The residence time of the water in this
storage

exponent:   :math:`\\\\beta [-]` An empirical exponent to shape the flux
function (default = 1 (linear function))

residual:   :math:`V_{residual} [m^3]` The volume of water not flowing out
(default = 0)

V0:   :math:`V_0` The reference volume to scale the exponent

Vrmax:   :math:`V_{r,max}` Capacity of the target water storage in m3

gamma:   :math:`\\\\gamma` Target capacity constriction curve shape ";

%feature("docstring")  cmf::water::constraint_kinematic_wave::conc "real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::water::constraint_kinematic_wave::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::water::constraint_kinematic_wave::get_ptr
"ptr get_ptr() const ";

%feature("docstring")
cmf::water::constraint_kinematic_wave::get_target "flux_node::ptr
get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::water::constraint_kinematic_wave::get_target "flux_node::ptr
get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::water::constraint_kinematic_wave::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::constraint_kinematic_wave::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::water::constraint_kinematic_wave::kill_me
"bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::water::constraint_kinematic_wave::left_node "flux_node::ptr
left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::water::constraint_kinematic_wave::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::water::constraint_kinematic_wave::refresh
"void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::water::constraint_kinematic_wave::right_node "flux_node::ptr
right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::water::constraint_kinematic_wave::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::constraint_kinematic_wave::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::water::constraint_kinematic_wave::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::water::constraint_kinematic_wave::to_string "virtual std::string
to_string() const ";


// File: classcmf__core_1_1_constraint_linear_storage_connection.xml
%feature("docstring") cmf_core::ConstraintLinearStorageConnection "

Calculates flux out of a storage as a linear function of its volume,
constraint by the volume stored in the target storage.    .. math:: q
= \\\\\\\\frac {1}{t_r} \\\\\\\\left({V_{l} - V_{l,min}}\\\\\\\\right)
\\\\\\\\cdot
\\\\\\\\left(\\\\\\\\frac{V_{r,max}-V_{r}}{V_{r,max}}\\\\\\\\right)
where:  :math:`V_l` The actual volume stored by the left water storage
:math:`V_{l,min} [m^3]` The volume of water not flowing out (default =
0)  :math:`\\\\\\\\beta` A parameter to shape the response curve. In
case of :math:`\\\\\\\\beta \\\\\\\\neq 1`, :math:`t_r` is not a
residence time, but just a parameter.  :math:`t_r [days]` The
residence time of the water in this storage in days  :math:`V_{r,max}`
The capacity of the right water storage in m3  :math:`V_{r}` The
actual volume of the right water storage  :math:`\\\\\\\\gamma` A
shape parameter for the target capacity constriction  C++ includes:
simple_connections.h ";

%feature("docstring")
cmf_core::ConstraintLinearStorageConnection::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::water::ConstraintLinearStorageConnection self,
cmf::water::WaterStorage::ptr source, cmf::water::WaterStorage::ptr
target, real residencetime=1.0, real Vlmin=0.0, real Vrmax=1.0) ->
ConstraintLinearStorageConnection
ConstraintLinearStorageConnection(WaterStorage::ptr source,
WaterStorage::ptr target, real residencetime=1.0, real Vlmin=0.0, real
Vrmax=1.0)  Creates a linear storage connection, constrained by the
fill level of the source   .. math::       q = \\\\\\\\frac 1 {t_r}
{\\\\\\\\left(\\\\\\\\frac{V -     V_{residual}}{V_0}
\\\\\\\\right)^\\\\\\\\beta}   .  Parameters: -----------  source:
Water storage from which the water flows out. Flux is a function of
source.volume  target:  Target node (boundary condition or storage).
Does not influence the strength of the flow  residencetime: :math:`t_r
[days]` The residence time of the water in this storage Vlmin:
:math:`V_{l,min} [m^3]` The volume of water not flowing out (default =
0)  Vrmax:   :math:`V_{r,max}` Capacity of the target water storage in
m3 ";

%feature("docstring")
cmf_core::ConstraintLinearStorageConnection::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")
cmf_core::ConstraintLinearStorageConnection::__eq__ "def __eq__(self,
args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")
cmf_core::ConstraintLinearStorageConnection::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")
cmf_core::ConstraintLinearStorageConnection::__iter__ "def
__iter__(self) ";

%feature("docstring")
cmf_core::ConstraintLinearStorageConnection::__repr__ "def
__repr__(self) ";

%feature("docstring")
cmf_core::ConstraintLinearStorageConnection::conc "def conc(self,
args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::ConstraintLinearStorageConnection::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf_core::ConstraintLinearStorageConnection::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::ConstraintLinearStorageConnection::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")
cmf_core::ConstraintLinearStorageConnection::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")
cmf_core::ConstraintLinearStorageConnection::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::ConstraintLinearStorageConnection::q
"def q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")
cmf_core::ConstraintLinearStorageConnection::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")
cmf_core::ConstraintLinearStorageConnection::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::ConstraintLinearStorageConnection::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf_core::ConstraintLinearStorageConnection::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")
cmf_core::ConstraintLinearStorageConnection::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1water_1_1_constraint_linear_storage_connection.xml
%feature("docstring") cmf::water::ConstraintLinearStorageConnection "

Calculates flux out of a storage as a linear function of its volume,
constraint by the volume stored in the target storage.



.. math::

     q = \\\\frac {1}{t_r} \\\\left({V_{l} - V_{l,min}}\\\\right)
    \\\\cdot \\\\left(\\\\frac{V_{r,max}-V_{r}}{V_{r,max}}\\\\right)

where:  :math:`V_l` The actual volume stored by the left water storage

:math:`V_{l,min} [m^3]` The volume of water not flowing out (default = 0)

:math:`\\\\beta` A parameter to shape the response curve. In case of
:math:`\\\\beta \\\\neq 1`, :math:`t_r` is not a residence time, but just a
parameter.

:math:`t_r [days]` The residence time of the water in this storage in days

:math:`V_{r,max}` The capacity of the right water storage in m3

:math:`V_{r}` The actual volume of the right water storage

:math:`\\\\gamma` A shape parameter for the target capacity constriction

C++ includes: simple_connections.h ";

%feature("docstring")
cmf::water::ConstraintLinearStorageConnection::ConstraintLinearStorageConnection
"ConstraintLinearStorageConnection(WaterStorage::ptr source,
WaterStorage::ptr target, real residencetime=1.0, real Vlmin=0.0, real
Vrmax=1.0)

Creates a linear storage connection, constrained by the fill level of
the source 

.. math::

     q = \\\\frac 1 {t_r} {\\\\left(\\\\frac{V -
    V_{residual}}{V_0} \\\\right)^\\\\beta} 

.

Parameters:
-----------

source:  Water storage from which the water flows out. Flux is a
function of source.volume

target:  Target node (boundary condition or storage). Does not
influence the strength of the flow

residencetime:   :math:`t_r [days]` The residence time of the water in this
storage

Vlmin:   :math:`V_{l,min} [m^3]` The volume of water not flowing out
(default = 0)

Vrmax:   :math:`V_{r,max}` Capacity of the target water storage in m3 ";

%feature("docstring")
cmf::water::ConstraintLinearStorageConnection::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::water::ConstraintLinearStorageConnection::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::water::ConstraintLinearStorageConnection::get_ptr "ptr get_ptr()
const ";

%feature("docstring")
cmf::water::ConstraintLinearStorageConnection::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::water::ConstraintLinearStorageConnection::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::water::ConstraintLinearStorageConnection::get_tracer_filter "real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::ConstraintLinearStorageConnection::get_tracer_filter "real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::water::ConstraintLinearStorageConnection::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::water::ConstraintLinearStorageConnection::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")
cmf::water::ConstraintLinearStorageConnection::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::water::ConstraintLinearStorageConnection::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::water::ConstraintLinearStorageConnection::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::water::ConstraintLinearStorageConnection::set_tracer_filter "void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::ConstraintLinearStorageConnection::set_tracer_filter "void set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::water::ConstraintLinearStorageConnection::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::water::ConstraintLinearStorageConnection::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_content_stress.xml
%feature("docstring") cmf_core::ContentStress "

A simple water content based stress model based on Feddes (1978)
stress a is piecewise linear function based on water content  if
:math:`\\\\\\\\theta>\\\\\\\\theta_d \\\\\\\\rightarrow ET = ET_{pot}`
if :math:`\\\\\\\\theta_d>\\\\\\\\theta > \\\\\\\\theta_{wilt}
\\\\\\\\rightarrow ET = \\\\\\\\frac{\\\\\\\\theta_d -
\\\\\\\\theta}{\\\\\\\\theta_d - \\\\\\\\theta_{wilt}} ET_{pot}`  if
:math:`\\\\\\\\theta_{wilt}>\\\\\\\\theta \\\\\\\\rightarrow ET = 0.0`
The parameters :math:`\\\\\\\\theta_{d,w}` can be omitted (or set to a
negative value) to use default values derived from the layer
properties. The critical water content (where stress starts) is then
defined (conf. Feddes 1978) as the center between field capacity (
:math:`\\\\\\\\theta_{fc}`) and the wilting point (
:math:`\\\\\\\\theta_{wp}`).  :math:`\\\\\\\\theta_w =
\\\\\\\\theta(pF=4.2)`: Water content at pF=4.2 :math:`\\\\\\\\theta_d
= 1/2 (\\\\\\\\theta(pF=1.8) + \\\\\\\\theta(pF=4.2))`  C++ includes:
waterstress.h ";

%feature("docstring")  cmf_core::ContentStress::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::ET::ContentStress self, real theta_d=-1, real
theta_w=-1) -> ContentStress  ContentStress(real theta_d=-1, real
theta_w=-1)  Creates a new ContentStress for critical water content
theta_d in vol Water/vol Soil and wilting point theta_w. ";

%feature("docstring")  cmf_core::ContentStress::copy "def copy(self,
args, kwargs)

copy(ContentStress self) -> ContentStress
cmf::upslope::ET::ContentStress* copy() const  Creates a new copy of
this wetness. ";

%feature("docstring")  cmf_core::ContentStress::Tact "def Tact(self,
args, kwargs)

Tact(RootUptakeStessFunction self, stressedET connection, real Tpot)
-> real  virtual real Tact(const stressedET *connection, real Tpot)
const =0  Calculates the water stress for a layer.  Parameters:
-----------  connection:  The stressedET connection this stress
function belongs to  Tpot:  Potential Transpiration in mm/day (for the
full profile)  Actual flux from layer in m3/day ";

%feature("docstring")  cmf_core::ContentStress::to_string "def
to_string(self, args, kwargs)

to_string(RootUptakeStessFunction self) -> std::string  virtual
std::string to_string() const =0 ";


// File: classcmf_1_1upslope_1_1_e_t_1_1_content_stress.xml
%feature("docstring") cmf::upslope::ET::ContentStress "

A simple water content based stress model based on Feddes (1978)

stress a is piecewise linear function based on water content

if :math:`\\\\theta>\\\\theta_d \\\\rightarrow ET = ET_{pot}`

if :math:`\\\\theta_d>\\\\theta > \\\\theta_{wilt} \\\\rightarrow ET = \\\\frac{\\\\theta_d - \\\\theta}{\\\\theta_d - \\\\theta_{wilt}} ET_{pot}`

if :math:`\\\\theta_{wilt}>\\\\theta \\\\rightarrow ET = 0.0`

The parameters :math:`\\\\theta_{d,w}` can be omitted (or set to a negative
value) to use default values derived from the layer properties. The
critical water content (where stress starts) is then defined (conf.
Feddes 1978) as the center between field capacity ( :math:`\\\\theta_{fc}`)
and the wilting point ( :math:`\\\\theta_{wp}`).  :math:`\\\\theta_w = \\\\theta(pF=4.2)`: Water content at pF=4.2

:math:`\\\\theta_d = 1/2 (\\\\theta(pF=1.8) + \\\\theta(pF=4.2))`

C++ includes: waterstress.h ";

%feature("docstring")  cmf::upslope::ET::ContentStress::ContentStress
"ContentStress(real theta_d=-1, real theta_w=-1)

Creates a new ContentStress for critical water content theta_d in vol
Water/vol Soil and wilting point theta_w. ";

%feature("docstring")  cmf::upslope::ET::ContentStress::~ContentStress
"virtual ~ContentStress() ";

%feature("docstring")  cmf::upslope::ET::ContentStress::copy "cmf::upslope::ET::ContentStress* copy() const

Creates a new copy of this wetness. ";

%feature("docstring")  cmf::upslope::ET::ContentStress::Tact "real
Tact(const stressedET *connection, real Tpot) const

Calculates the water stress for a layer.

Parameters:
-----------

connection:  The stressedET connection this stress function belongs to

Tpot:  Potential Transpiration in mm/day (for the full profile)

Actual flux from layer in m3/day ";

%feature("docstring")  cmf::upslope::ET::ContentStress::to_string "std::string to_string() const ";


// File: classcmf_1_1river_1_1_cross_section_reach.xml
%feature("docstring") cmf::river::CrossSectionReach "

Structure for the description of reaches with a freely defined cross
section.

Although double triangular cross section reach are rarely met, a
triangular reach does scale with its water load, and is therefore
preferable in case where nothing about IChannel geometry is known

C++ includes: cross_section_reach.h ";

%feature("docstring")
cmf::river::CrossSectionReach::CrossSectionReach "CrossSectionReach(double l, cmf::math::num_array x,
cmf::math::num_array depth)

Creates a new triangular reach type. ";

%feature("docstring")
cmf::river::CrossSectionReach::CrossSectionReach "CrossSectionReach(const CrossSectionReach &copy) ";

%feature("docstring")
cmf::river::CrossSectionReach::~CrossSectionReach "virtual
~CrossSectionReach() ";

%feature("docstring")  cmf::river::CrossSectionReach::A "virtual
double A(double V) const

Returns the area of the surface for a given volume. ";

%feature("docstring")  cmf::river::CrossSectionReach::check_iterator "void check_iterator(double h) const ";

%feature("docstring")  cmf::river::CrossSectionReach::copy "CrossSectionReach* copy() const ";

%feature("docstring")
cmf::river::CrossSectionReach::get_channel_width "virtual double
get_channel_width(double depth) const

Calculates the flow width from a given actual depth [m] using the
actual IChannel geometry. ";

%feature("docstring")  cmf::river::CrossSectionReach::get_depth "virtual double get_depth(double area) const

Returns the depth at a given crossection area. ";

%feature("docstring")
cmf::river::CrossSectionReach::get_flux_crossection "virtual double
get_flux_crossection(double depth) const

Returns the crossection area at a given depth. ";

%feature("docstring")  cmf::river::CrossSectionReach::get_length "double get_length() const

Length of the reach. ";

%feature("docstring")  cmf::river::CrossSectionReach::get_nManning "virtual double get_nManning() const ";

%feature("docstring")
cmf::river::CrossSectionReach::get_wetted_perimeter "virtual double
get_wetted_perimeter(double depth) const

Returns the wetted perimeter at a given depth. ";

%feature("docstring")  cmf::river::CrossSectionReach::h "virtual
double h(double V) const

Returns the depth of a given volume. ";

%feature("docstring")  cmf::river::CrossSectionReach::q "virtual
double q(double h, double slope) const ";

%feature("docstring")  cmf::river::CrossSectionReach::qManning "virtual double qManning(double A, double slope) const

Calculates the flow rate from a given water volume in the reach


.. math::

     q_{Manning}&=& A R^{\\\\frac 2 3}
    \\\\sqrt{\\\\frac {\\\\Delta_z} n} \\\\\\\\ A &=& \\\\frac V l
    \\\\mbox{, (Crosssectional area of the wetted crossection, Volume per
    length)} \\\\\\\\ R &=& \\\\frac A {P(d)} \\\\\\\\ P(d) &=& \\\\mbox{
    the perimeter of the wetted crosssection, a function of reach depth}
    \\\\\\\\ d(V) &=& \\\\mbox{ the depth of the reach a function of the
    volume} \\\\\\\\ \\\\Delta_z &=& \\\\frac{z_{max} - z_{min}}{l}
    \\\\mbox{ Slope of the reach} 

.

Flow rate [m3/s]

Parameters:
-----------

A:  The area of the cross section [m2]

slope:  The slope of the reach [m/m] ";

%feature("docstring")  cmf::river::CrossSectionReach::set_nManning "virtual void set_nManning(double nManning) ";

%feature("docstring")  cmf::river::CrossSectionReach::typecode "char
typecode() const ";

%feature("docstring")  cmf::river::CrossSectionReach::V "virtual
double V(double h) const ";


// File: classcmf__core_1_1_cross_section_reach.xml
%feature("docstring") cmf_core::CrossSectionReach "

Structure for the description of reaches with a freely defined cross
section.  Although double triangular cross section reach are rarely
met, a triangular reach does scale with its water load, and is
therefore preferable in case where nothing about IChannel geometry is
known  C++ includes: cross_section_reach.h ";

%feature("docstring")  cmf_core::CrossSectionReach::__init__ "def
__init__(self, args)

__init__(cmf::river::CrossSectionReach self, double l,
cmf::math::num_array x, cmf::math::num_array depth) ->
CrossSectionReach __init__(cmf::river::CrossSectionReach self,
CrossSectionReach copy) -> CrossSectionReach  CrossSectionReach(const
CrossSectionReach &copy) ";

%feature("docstring")  cmf_core::CrossSectionReach::A "def A(self,
args, kwargs)

A(IVolumeHeightFunction self, double V) -> double  virtual double
A(double V) const =0  Returns the area of the surface for a given
volume. ";

%feature("docstring")  cmf_core::CrossSectionReach::check_iterator "def check_iterator(self, args, kwargs)

check_iterator(CrossSectionReach self, double h)  void
check_iterator(double h) const ";

%feature("docstring")  cmf_core::CrossSectionReach::copy "def
copy(self, args, kwargs)

copy(CrossSectionReach self) -> CrossSectionReach  CrossSectionReach*
copy() const ";

%feature("docstring")  cmf_core::CrossSectionReach::get_channel_width
"def get_channel_width(self, args, kwargs)

get_channel_width(IChannel self, double depth) -> double  virtual
double get_channel_width(double depth) const =0  Calculates the flow
width from a given actual depth [m] using the actual IChannel
geometry. ";

%feature("docstring")  cmf_core::CrossSectionReach::get_depth "def
get_depth(self, args, kwargs)

get_depth(IChannel self, double area) -> double  virtual double
get_depth(double area) const =0  Calculates the actual depth of the
reach using the IChannel geometry.  get_depth of the reach [m]
Parameters: -----------  area:  Wetted area of a river cross section
[m2], can be obtained by V/l, where V is the stored volume and l is
the reach length ";

%feature("docstring")
cmf_core::CrossSectionReach::get_flux_crossection "def
get_flux_crossection(self, args, kwargs)

get_flux_crossection(IChannel self, double depth) -> double  virtual
double get_flux_crossection(double depth) const =0  Calculates the
wetted area from a given depth using the IChannel geometry.  In most
cases use get_flux_crossection=V/l, where V is the stored volume and l
is the reach length Wetted area of a river cross section [m2]
Parameters: -----------  depth:  depth of the reach [m] ";

%feature("docstring")  cmf_core::CrossSectionReach::get_length "def
get_length(self, args, kwargs)

get_length(IChannel self) -> double  virtual double get_length() const
=0  Length of the reach. ";

%feature("docstring")  cmf_core::CrossSectionReach::get_nManning "def
get_nManning(self, args, kwargs)

get_nManning(IChannel self) -> double  virtual double get_nManning()
const =0 ";

%feature("docstring")
cmf_core::CrossSectionReach::get_wetted_perimeter "def
get_wetted_perimeter(self, args, kwargs)

get_wetted_perimeter(IChannel self, double depth) -> double  virtual
double get_wetted_perimeter(double depth) const =0  Calculates the
wetted perimeter from a given actual depth [m] using the actual
IChannel geometry. ";

%feature("docstring")  cmf_core::CrossSectionReach::h "def h(self,
args, kwargs)

h(IVolumeHeightFunction self, double V) -> double  virtual double
h(double V) const =0  Returns the depth of a given volume. ";

%feature("docstring")  cmf_core::CrossSectionReach::q "def q(self,
args, kwargs)

q(IVolumeHeightFunction self, double h, double slope) -> double
virtual double q(double h, double slope) const ";

%feature("docstring")  cmf_core::CrossSectionReach::qManning "def
qManning(self, args, kwargs)

qManning(IChannel self, double A, double slope) -> double  virtual
double qManning(double A, double slope) const  Calculates the flow
rate from a given water volume in the reach   .. math:: q_{Manning}&=&
A R^{\\\\\\\\frac 2 3}     \\\\\\\\sqrt{\\\\\\\\frac {\\\\\\\\Delta_z}
n} \\\\\\\\\\\\\\\\ A &=& \\\\\\\\frac V l \\\\\\\\mbox{,
(Crosssectional area of the wetted crossection, Volume per
length)} \\\\\\\\\\\\\\\\ R &=& \\\\\\\\frac A {P(d)} \\\\\\\\\\\\\\\\
P(d) &=& \\\\\\\\mbox{     the perimeter of the wetted crosssection, a
function of reach depth}     \\\\\\\\\\\\\\\\ d(V) &=& \\\\\\\\mbox{
the depth of the reach a function of the volume} \\\\\\\\\\\\\\\\
\\\\\\\\Delta_z &=& \\\\\\\\frac{z_{max} - z_{min}}{l}
\\\\\\\\mbox{ Slope of the reach}   .  Flow rate [m3/s]  Parameters:
-----------  A:  The area of the cross section [m2]  slope:  The slope
of the reach [m/m] ";

%feature("docstring")  cmf_core::CrossSectionReach::set_nManning "def
set_nManning(self, args, kwargs)

set_nManning(IChannel self, double val)  virtual void
set_nManning(double val)=0 ";

%feature("docstring")  cmf_core::CrossSectionReach::typecode "def
typecode(self, args, kwargs)

typecode(IChannel self) -> char  virtual char typecode() const =0 ";

%feature("docstring")  cmf_core::CrossSectionReach::V "def V(self,
args, kwargs)

V(IVolumeHeightFunction self, double h) -> double  virtual double
V(double h) const =0 ";


// File: classcmf__core_1_1cubicspline.xml
%feature("docstring") cmf_core::cubicspline "

Interpolates points with a cubic spline interpolation.  Code is
modified after:http://ganeshtiwaridotcomdotnp.blogspot.de/2009/12/c-c-
code- cubic- spline-interpolation.html  C++ includes: spline.h ";

%feature("docstring")  cmf_core::cubicspline::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::math::cubicspline self, cmf::math::num_array const & x,
cmf::math::num_array const & y) -> cubicspline  cubicspline(const
cmf::math::num_array &x, const cmf::math::num_array &y) ";

%feature("docstring")  cmf_core::cubicspline::__call__ "def
__call__(self, args, kwargs)

__call__(cubicspline self, real x) -> real ";

%feature("docstring")  cmf_core::cubicspline::generate "def
generate(self, args, kwargs)

generate(cubicspline self)  void generate() ";

%feature("docstring")  cmf_core::cubicspline::size "def size(self,
args, kwargs)

size(cubicspline self) -> size_t  size_t size() const ";


// File: classcmf_1_1math_1_1cubicspline.xml
%feature("docstring") cmf::math::cubicspline "

Interpolates points with a cubic spline interpolation.

Code is modified
after:http://ganeshtiwaridotcomdotnp.blogspot.de/2009/12/c-c-code-
cubic- spline-interpolation.html

C++ includes: spline.h ";

%feature("docstring")  cmf::math::cubicspline::cubicspline "cubicspline(const cmf::math::num_array &x, const cmf::math::num_array
&y) ";

%feature("docstring")  cmf::math::cubicspline::generate "void
generate() ";

%feature("docstring")  cmf::math::cubicspline::size "size_t size()
const ";


// File: classcmf__core_1_1_c_vode_adams.xml
%feature("docstring") cmf_core::CVodeAdams "

Explizit multistep solver using CVode.  C++ includes: cvode3.h ";

%feature("docstring")  cmf_core::CVodeAdams::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::math::CVodeAdams self, StateVariableOwner states, real
epsilon=1e-9) -> CVodeAdams  CVodeAdams(cmf::math::StateVariableOwner
&states, real epsilon=1e-9) ";

%feature("docstring")  cmf_core::CVodeAdams::__call__ "def
__call__(self, t, dt=None, reset=False)

Advances the integration until `t`  A shortcut to .integrate_until
Parameters ---------- t : cmf.Time     The time step to advance to. If
t < current time, the solver will     advance to self.t + t dt :
cmf.Time, optional     The timestep for the integration. If not given
try to integrate in one step reset : bool, optional     If True, the
solver will perform a reset before starting  Returns ------- cmf.Time
The new time stamp ";

%feature("docstring")  cmf_core::CVodeAdams::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(Integrator self, long position) ->
cmf::math::StateVariable::ptr ";

%feature("docstring")  cmf_core::CVodeAdams::__len__ "def
__len__(self, args, kwargs)

__len__(Integrator self) -> size_t ";

%feature("docstring")  cmf_core::CVodeAdams::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::CVodeAdams::add_single_state "def
add_single_state(self, args, kwargs)

add_single_state(Integrator self, cmf::math::StateVariable::ptr state)
virtual void add_single_state(cmf::math::StateVariable::ptr state)
Adds a single state variable to the integrator. ";

%feature("docstring")  cmf_core::CVodeAdams::add_states "def
add_states(self, args, kwargs)

add_states(Integrator self, StateVariableOwner stateOwner)  virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)  Add state
variables from a StateVariableOwner. ";

%feature("docstring")  cmf_core::CVodeAdams::copy "def copy(self,
args, kwargs)

copy(CVodeBase self) -> CVodeBase  virtual Integrator* copy() const =0
Polymorphic copy constructor. ";

%feature("docstring")  cmf_core::CVodeAdams::get_dt "def get_dt(self,
args, kwargs)

get_dt(Integrator self) -> Time  cmf::math::Time get_dt() const
Returns the last time step. ";

%feature("docstring")  cmf_core::CVodeAdams::get_dxdt "def
get_dxdt(self, args, kwargs)

get_dxdt(Integrator self, Time time) -> cmf::math::num_array
cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf_core::CVodeAdams::get_error "def
get_error(self, args, kwargs)

get_error(CVodeBase self) -> cmf::math::num_array ";

%feature("docstring")  cmf_core::CVodeAdams::get_info "def
get_info(self, args, kwargs)

get_info(CVodeBase self) -> CVodeInfo ";

%feature("docstring")  cmf_core::CVodeAdams::get_jacobian "def
get_jacobian(self) ";

%feature("docstring")  cmf_core::CVodeAdams::get_state "def
get_state(self, args, kwargs)

get_state(Integrator self, ptrdiff_t position) -> real  real
get_state(ptrdiff_t position) const  Returns the statevariable at
position Simplifies the assessment of state variables. ";

%feature("docstring")  cmf_core::CVodeAdams::get_states "def
get_states(self, args)

get_states(Integrator self) -> cmf::math::num_array
get_states(Integrator self) -> StateVariableList  StateVariableList
get_states()  gets the state variables of the integrator ";

%feature("docstring")  cmf_core::CVodeAdams::get_t "def get_t(self,
args, kwargs)

get_t(Integrator self) -> Time  cmf::math::Time get_t() const  Returns
the current model time. ";

%feature("docstring")  cmf_core::CVodeAdams::initialize "def
initialize(self, args, kwargs)

initialize(CVodeBase self) -> int ";

%feature("docstring")  cmf_core::CVodeAdams::integrate "def
integrate(self, args, kwargs)

integrate(Integrator self, Time t_max, Time dt) -> int  virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)=0  Integrates the
vector of state variables.  Parameters: -----------  t_max:  To stop
the model (if running in a model framework) at time steps of value
exchange e.g. full hours, the next value exchange time can be given
dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf_core::CVodeAdams::integrate_until "def
integrate_until(self, args, kwargs)

integrate_until(Integrator self, Time t_max, Time dt, bool
reset=False)  void integrate_until(cmf::math::Time t_max,
cmf::math::Time dt=Time(), bool reset=false)  Integrates the vector of
state variables until t_max.  Parameters: -----------  t_max:   Time,
the solver should run to  dt:   Time step (may be omitted)  reset:  If
true, solver is reseted before integration starts ";

%feature("docstring")  cmf_core::CVodeAdams::reset "def reset(self,
args, kwargs)

reset(Integrator self)  virtual void reset()  Resets any saved history
(for multistep methods) ";

%feature("docstring")  cmf_core::CVodeAdams::run "def run(self,
start=None, end=None, step=day *1, max_errors=0, reset=False)

Returns an iterator over the timesteps start..end  **Examples:**  >>>
solver=cmf.CVodeIntegrator(...) >>> for t in solver.run(solver.t,
solver.t + cmf.week, cmf.h): >>>    print(t, solver[0].state) or with
list comprehension >>> states = [solver[0].state for t in
solver.run(solver.t, solver.t + cmf.week, cmf.h)]  Parameters
---------- start : cmf.Time, optional Start time for the solver
iteration end : cmf.Time, optional End time of the iteration step :
cmf.Time, optional Step size for the integration max_errors: int
Number of tolerated errors. If >0, up to these number of runtime
errors will be saved with their time and the integration proceeds
after a reset of the solver. Some systems operate with values close to
their physical limits and inifinite values in the integration can
easily occur. For these kind of systems set max_errors to eg. 10. A
larger number of errors should be eliminated usually. reset: bool If
True, the solver performs a `reset` at every time step  Yields ------
cmf.Time      the actual timestep ";

%feature("docstring")  cmf_core::CVodeAdams::set_error_msg "def
set_error_msg(self, args, kwargs)

set_error_msg(CVodeBase self, std::string error) ";

%feature("docstring")  cmf_core::CVodeAdams::set_state "def
set_state(self, args, kwargs)

set_state(Integrator self, ptrdiff_t position, real newState)  void
set_state(ptrdiff_t position, real newState)  Simplifies the
assessment of state variables. ";

%feature("docstring")  cmf_core::CVodeAdams::set_t "def set_t(self,
args, kwargs)

set_t(Integrator self, Time val)  void set_t(cmf::math::Time val) Sets
the current model time. ";

%feature("docstring")  cmf_core::CVodeAdams::size "def size(self,
args, kwargs)

size(Integrator self) -> size_t  size_t size() const  returns the
number of state variables ";

%feature("docstring")  cmf_core::CVodeAdams::to_string "def
to_string(self, args, kwargs)

to_string(CVodeBase self) -> std::string ";


// File: classcmf_1_1math_1_1_c_vode_adams.xml
%feature("docstring") cmf::math::CVodeAdams "

Explizit multistep solver using CVode.

C++ includes: cvode.h ";

/*  Accuracy parameters  */

/*  model time  */

%feature("docstring")  cmf::math::CVodeAdams::get_t "cmf::math::Time
get_t() const

Returns the current model time. ";

%feature("docstring")  cmf::math::CVodeAdams::set_t "void
set_t(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::CVodeAdams::get_dt "cmf::math::Time
get_dt() const

Returns the last time step. ";

/*  Integrate  */

%feature("docstring")  cmf::math::CVodeAdams::integrate_until "void
integrate_until(cmf::math::Time t_max, cmf::math::Time dt=Time(), bool
reset=false)

Integrates the vector of state variables until t_max.

Parameters:
-----------

t_max:   Time, the solver should run to

dt:   Time step (may be omitted)

reset:  If true, solver is reseted before integration starts ";

%feature("docstring")  cmf::math::CVodeAdams::CVodeAdams "CVodeAdams(cmf::math::StateVariableOwner &states, real epsilon=1e-9)
";

%feature("docstring")  cmf::math::CVodeAdams::_get_jacobian "virtual
cmf::math::num_array _get_jacobian() const

Returns a continuous 1D array representing the Jacobian columns
concatenated.

In Python, get_jacobian returns the Jacobian as a 2D array ";

%feature("docstring")  cmf::math::CVodeAdams::add_single_state "virtual void add_single_state(cmf::math::StateVariable::ptr state)

Adds a single state variable to the integrator. ";

%feature("docstring")  cmf::math::CVodeAdams::add_states "virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)

Add state variables from a StateVariableOwner. ";

%feature("docstring")  cmf::math::CVodeAdams::add_values_to_states "void add_values_to_states(const num_array &operands)

Adds the values in operands to the current states. ";

%feature("docstring")  cmf::math::CVodeAdams::copy "CVodeBase* copy()
const

Returns a copy of the solver. ";

%feature("docstring")  cmf::math::CVodeAdams::copy_dxdt "void
copy_dxdt(Time time, num_array &destination, real factor=1) const

Copies the derivatives at time step \"time\" to a numeric vector using
use_OpenMP.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Vector to be overwritten by the results

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::CVodeAdams::copy_dxdt "void
copy_dxdt(Time time, real *destination, real factor=1) const

Copies the derivatives at time step \"time\" to an preallocated c
array.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Allocated c array

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::CVodeAdams::copy_states "void
copy_states(num_array &destination) const

Copies the states to a numeric vector using use_OpenMP. ";

%feature("docstring")  cmf::math::CVodeAdams::copy_states "void
copy_states(real *destination) const ";

%feature("docstring")  cmf::math::CVodeAdams::get_dxdt "cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf::math::CVodeAdams::get_error "cmf::math::num_array get_error() const

Error vector of the integrator. ";

%feature("docstring")  cmf::math::CVodeAdams::get_info "CVodeInfo
get_info() const

Returns the current solver statistics. ";

%feature("docstring")  cmf::math::CVodeAdams::get_state "real
get_state(ptrdiff_t position) const

Returns the statevariable at position Simplifies the assessment of
state variables. ";

%feature("docstring")  cmf::math::CVodeAdams::get_states "cmf::math::num_array get_states() const ";

%feature("docstring")  cmf::math::CVodeAdams::get_states "StateVariableList get_states()

gets the state variables of the integrator ";

%feature("docstring")  cmf::math::CVodeAdams::initialize "int
initialize()

Initialize the internal memory.

Automatically called, when one starts to integrate ";

%feature("docstring")  cmf::math::CVodeAdams::integrate "virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)

Integrates the vector of state variables.

Parameters:
-----------

t_max:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf::math::CVodeAdams::reset "virtual void
reset()

Resets the history of the multispte solver and overwrites the internal
state cache. ";

%feature("docstring")  cmf::math::CVodeAdams::set_error_msg "void
set_error_msg(std::string error)

Sets an error message. ";

%feature("docstring")  cmf::math::CVodeAdams::set_state "void
set_state(ptrdiff_t position, real newState)

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::CVodeAdams::set_states "void
set_states(const num_array &newStates)

Copies the new states to the actual states. ";

%feature("docstring")  cmf::math::CVodeAdams::set_states "void
set_states(real *newStates) ";

%feature("docstring")  cmf::math::CVodeAdams::size "size_t size()
const

returns the number of state variables ";

%feature("docstring")  cmf::math::CVodeAdams::to_string "std::string
to_string() const

Returns a string representation of the solver. ";


// File: classcmf__core_1_1_c_vode_banded.xml
%feature("docstring") cmf_core::CVodeBanded "

implicit BDF CVode solver with a banded Jacobian approximation  C++
includes: cvode3.h ";

%feature("docstring")  cmf_core::CVodeBanded::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::math::CVodeBanded self, StateVariableOwner states, real
epsilon=1e-9, int w=5) -> CVodeBanded
CVodeBanded(cmf::math::StateVariableOwner &states, real epsilon=1e-9,
int w=5) ";

%feature("docstring")  cmf_core::CVodeBanded::__call__ "def
__call__(self, t, dt=None, reset=False)

Advances the integration until `t`  A shortcut to .integrate_until
Parameters ---------- t : cmf.Time     The time step to advance to. If
t < current time, the solver will     advance to self.t + t dt :
cmf.Time, optional     The timestep for the integration. If not given
try to integrate in one step reset : bool, optional     If True, the
solver will perform a reset before starting  Returns ------- cmf.Time
The new time stamp ";

%feature("docstring")  cmf_core::CVodeBanded::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(Integrator self, long position) ->
cmf::math::StateVariable::ptr ";

%feature("docstring")  cmf_core::CVodeBanded::__len__ "def
__len__(self, args, kwargs)

__len__(Integrator self) -> size_t ";

%feature("docstring")  cmf_core::CVodeBanded::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::CVodeBanded::add_single_state "def
add_single_state(self, args, kwargs)

add_single_state(Integrator self, cmf::math::StateVariable::ptr state)
virtual void add_single_state(cmf::math::StateVariable::ptr state)
Adds a single state variable to the integrator. ";

%feature("docstring")  cmf_core::CVodeBanded::add_states "def
add_states(self, args, kwargs)

add_states(Integrator self, StateVariableOwner stateOwner)  virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)  Add state
variables from a StateVariableOwner. ";

%feature("docstring")  cmf_core::CVodeBanded::copy "def copy(self,
args, kwargs)

copy(CVodeBase self) -> CVodeBase  virtual Integrator* copy() const =0
Polymorphic copy constructor. ";

%feature("docstring")  cmf_core::CVodeBanded::get_dt "def
get_dt(self, args, kwargs)

get_dt(Integrator self) -> Time  cmf::math::Time get_dt() const
Returns the last time step. ";

%feature("docstring")  cmf_core::CVodeBanded::get_dxdt "def
get_dxdt(self, args, kwargs)

get_dxdt(Integrator self, Time time) -> cmf::math::num_array
cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf_core::CVodeBanded::get_error "def
get_error(self, args, kwargs)

get_error(CVodeBase self) -> cmf::math::num_array ";

%feature("docstring")  cmf_core::CVodeBanded::get_info "def
get_info(self, args, kwargs)

get_info(CVodeBase self) -> CVodeInfo ";

%feature("docstring")  cmf_core::CVodeBanded::get_jacobian "def
get_jacobian(self) ";

%feature("docstring")  cmf_core::CVodeBanded::get_state "def
get_state(self, args, kwargs)

get_state(Integrator self, ptrdiff_t position) -> real  real
get_state(ptrdiff_t position) const  Returns the statevariable at
position Simplifies the assessment of state variables. ";

%feature("docstring")  cmf_core::CVodeBanded::get_states "def
get_states(self, args)

get_states(Integrator self) -> cmf::math::num_array
get_states(Integrator self) -> StateVariableList  StateVariableList
get_states()  gets the state variables of the integrator ";

%feature("docstring")  cmf_core::CVodeBanded::get_t "def get_t(self,
args, kwargs)

get_t(Integrator self) -> Time  cmf::math::Time get_t() const  Returns
the current model time. ";

%feature("docstring")  cmf_core::CVodeBanded::initialize "def
initialize(self, args, kwargs)

initialize(CVodeBase self) -> int ";

%feature("docstring")  cmf_core::CVodeBanded::integrate "def
integrate(self, args, kwargs)

integrate(Integrator self, Time t_max, Time dt) -> int  virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)=0  Integrates the
vector of state variables.  Parameters: -----------  t_max:  To stop
the model (if running in a model framework) at time steps of value
exchange e.g. full hours, the next value exchange time can be given
dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf_core::CVodeBanded::integrate_until "def
integrate_until(self, args, kwargs)

integrate_until(Integrator self, Time t_max, Time dt, bool
reset=False)  void integrate_until(cmf::math::Time t_max,
cmf::math::Time dt=Time(), bool reset=false)  Integrates the vector of
state variables until t_max.  Parameters: -----------  t_max:   Time,
the solver should run to  dt:   Time step (may be omitted)  reset:  If
true, solver is reseted before integration starts ";

%feature("docstring")  cmf_core::CVodeBanded::reset "def reset(self,
args, kwargs)

reset(Integrator self)  virtual void reset()  Resets any saved history
(for multistep methods) ";

%feature("docstring")  cmf_core::CVodeBanded::run "def run(self,
start=None, end=None, step=day *1, max_errors=0, reset=False)

Returns an iterator over the timesteps start..end  **Examples:**  >>>
solver=cmf.CVodeIntegrator(...) >>> for t in solver.run(solver.t,
solver.t + cmf.week, cmf.h): >>>    print(t, solver[0].state) or with
list comprehension >>> states = [solver[0].state for t in
solver.run(solver.t, solver.t + cmf.week, cmf.h)]  Parameters
---------- start : cmf.Time, optional Start time for the solver
iteration end : cmf.Time, optional End time of the iteration step :
cmf.Time, optional Step size for the integration max_errors: int
Number of tolerated errors. If >0, up to these number of runtime
errors will be saved with their time and the integration proceeds
after a reset of the solver. Some systems operate with values close to
their physical limits and inifinite values in the integration can
easily occur. For these kind of systems set max_errors to eg. 10. A
larger number of errors should be eliminated usually. reset: bool If
True, the solver performs a `reset` at every time step  Yields ------
cmf.Time      the actual timestep ";

%feature("docstring")  cmf_core::CVodeBanded::set_error_msg "def
set_error_msg(self, args, kwargs)

set_error_msg(CVodeBase self, std::string error) ";

%feature("docstring")  cmf_core::CVodeBanded::set_state "def
set_state(self, args, kwargs)

set_state(Integrator self, ptrdiff_t position, real newState)  void
set_state(ptrdiff_t position, real newState)  Simplifies the
assessment of state variables. ";

%feature("docstring")  cmf_core::CVodeBanded::set_t "def set_t(self,
args, kwargs)

set_t(Integrator self, Time val)  void set_t(cmf::math::Time val) Sets
the current model time. ";

%feature("docstring")  cmf_core::CVodeBanded::size "def size(self,
args, kwargs)

size(Integrator self) -> size_t  size_t size() const  returns the
number of state variables ";

%feature("docstring")  cmf_core::CVodeBanded::to_string "def
to_string(self, args, kwargs)

to_string(CVodeBase self) -> std::string ";


// File: classcmf_1_1math_1_1_c_vode_banded.xml
%feature("docstring") cmf::math::CVodeBanded "

implicit BDF CVode solver with a banded Jacobian approximation

C++ includes: cvode.h ";

/*  Accuracy parameters  */

/*  model time  */

%feature("docstring")  cmf::math::CVodeBanded::get_t "cmf::math::Time
get_t() const

Returns the current model time. ";

%feature("docstring")  cmf::math::CVodeBanded::set_t "void
set_t(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::CVodeBanded::get_dt "cmf::math::Time get_dt() const

Returns the last time step. ";

/*  Integrate  */

%feature("docstring")  cmf::math::CVodeBanded::integrate_until "void
integrate_until(cmf::math::Time t_max, cmf::math::Time dt=Time(), bool
reset=false)

Integrates the vector of state variables until t_max.

Parameters:
-----------

t_max:   Time, the solver should run to

dt:   Time step (may be omitted)

reset:  If true, solver is reseted before integration starts ";

%feature("docstring")  cmf::math::CVodeBanded::CVodeBanded "CVodeBanded(cmf::math::StateVariableOwner &states, real epsilon=1e-9,
int w=5) ";

%feature("docstring")  cmf::math::CVodeBanded::_get_jacobian "virtual
cmf::math::num_array _get_jacobian() const

Returns a continuous 1D array representing the Jacobian columns
concatenated.

In Python, get_jacobian returns the Jacobian as a 2D array ";

%feature("docstring")  cmf::math::CVodeBanded::add_single_state "virtual void add_single_state(cmf::math::StateVariable::ptr state)

Adds a single state variable to the integrator. ";

%feature("docstring")  cmf::math::CVodeBanded::add_states "virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)

Add state variables from a StateVariableOwner. ";

%feature("docstring")  cmf::math::CVodeBanded::add_values_to_states "void add_values_to_states(const num_array &operands)

Adds the values in operands to the current states. ";

%feature("docstring")  cmf::math::CVodeBanded::copy "CVodeBase*
copy() const

Returns a copy of the solver. ";

%feature("docstring")  cmf::math::CVodeBanded::copy_dxdt "void
copy_dxdt(Time time, num_array &destination, real factor=1) const

Copies the derivatives at time step \"time\" to a numeric vector using
use_OpenMP.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Vector to be overwritten by the results

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::CVodeBanded::copy_dxdt "void
copy_dxdt(Time time, real *destination, real factor=1) const

Copies the derivatives at time step \"time\" to an preallocated c
array.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Allocated c array

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::CVodeBanded::copy_states "void
copy_states(num_array &destination) const

Copies the states to a numeric vector using use_OpenMP. ";

%feature("docstring")  cmf::math::CVodeBanded::copy_states "void
copy_states(real *destination) const ";

%feature("docstring")  cmf::math::CVodeBanded::get_dxdt "cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf::math::CVodeBanded::get_error "cmf::math::num_array get_error() const

Error vector of the integrator. ";

%feature("docstring")  cmf::math::CVodeBanded::get_info "CVodeInfo
get_info() const

Returns the current solver statistics. ";

%feature("docstring")  cmf::math::CVodeBanded::get_state "real
get_state(ptrdiff_t position) const

Returns the statevariable at position Simplifies the assessment of
state variables. ";

%feature("docstring")  cmf::math::CVodeBanded::get_states "cmf::math::num_array get_states() const ";

%feature("docstring")  cmf::math::CVodeBanded::get_states "StateVariableList get_states()

gets the state variables of the integrator ";

%feature("docstring")  cmf::math::CVodeBanded::initialize "int
initialize()

Initialize the internal memory.

Automatically called, when one starts to integrate ";

%feature("docstring")  cmf::math::CVodeBanded::integrate "virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)

Integrates the vector of state variables.

Parameters:
-----------

t_max:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf::math::CVodeBanded::reset "virtual void
reset()

Resets the history of the multispte solver and overwrites the internal
state cache. ";

%feature("docstring")  cmf::math::CVodeBanded::set_error_msg "void
set_error_msg(std::string error)

Sets an error message. ";

%feature("docstring")  cmf::math::CVodeBanded::set_state "void
set_state(ptrdiff_t position, real newState)

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::CVodeBanded::set_states "void
set_states(const num_array &newStates)

Copies the new states to the actual states. ";

%feature("docstring")  cmf::math::CVodeBanded::set_states "void
set_states(real *newStates) ";

%feature("docstring")  cmf::math::CVodeBanded::size "size_t size()
const

returns the number of state variables ";

%feature("docstring")  cmf::math::CVodeBanded::to_string "std::string
to_string() const

Returns a string representation of the solver. ";


// File: classcmf__core_1_1_c_vode_base.xml
%feature("docstring") cmf_core::CVodeBase "

Proxy of C++ cmf::math::CVodeBase class. ";

%feature("docstring")  cmf_core::CVodeBase::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::CVodeBase::__call__ "def
__call__(self, t, dt=None, reset=False)

Advances the integration until `t`  A shortcut to .integrate_until
Parameters ---------- t : cmf.Time     The time step to advance to. If
t < current time, the solver will     advance to self.t + t dt :
cmf.Time, optional     The timestep for the integration. If not given
try to integrate in one step reset : bool, optional     If True, the
solver will perform a reset before starting  Returns ------- cmf.Time
The new time stamp ";

%feature("docstring")  cmf_core::CVodeBase::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(Integrator self, long position) ->
cmf::math::StateVariable::ptr ";

%feature("docstring")  cmf_core::CVodeBase::__len__ "def
__len__(self, args, kwargs)

__len__(Integrator self) -> size_t ";

%feature("docstring")  cmf_core::CVodeBase::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::CVodeBase::add_single_state "def
add_single_state(self, args, kwargs)

add_single_state(Integrator self, cmf::math::StateVariable::ptr state)
virtual void add_single_state(cmf::math::StateVariable::ptr state)
Adds a single state variable to the integrator. ";

%feature("docstring")  cmf_core::CVodeBase::add_states "def
add_states(self, args, kwargs)

add_states(Integrator self, StateVariableOwner stateOwner)  virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)  Add state
variables from a StateVariableOwner. ";

%feature("docstring")  cmf_core::CVodeBase::copy "def copy(self,
args, kwargs)

copy(CVodeBase self) -> CVodeBase  virtual Integrator* copy() const =0
Polymorphic copy constructor. ";

%feature("docstring")  cmf_core::CVodeBase::get_dt "def get_dt(self,
args, kwargs)

get_dt(Integrator self) -> Time  cmf::math::Time get_dt() const
Returns the last time step. ";

%feature("docstring")  cmf_core::CVodeBase::get_dxdt "def
get_dxdt(self, args, kwargs)

get_dxdt(Integrator self, Time time) -> cmf::math::num_array
cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf_core::CVodeBase::get_error "def
get_error(self, args, kwargs)

get_error(CVodeBase self) -> cmf::math::num_array ";

%feature("docstring")  cmf_core::CVodeBase::get_info "def
get_info(self, args, kwargs)

get_info(CVodeBase self) -> CVodeInfo ";

%feature("docstring")  cmf_core::CVodeBase::get_jacobian "def
get_jacobian(self) ";

%feature("docstring")  cmf_core::CVodeBase::get_state "def
get_state(self, args, kwargs)

get_state(Integrator self, ptrdiff_t position) -> real  real
get_state(ptrdiff_t position) const  Returns the statevariable at
position Simplifies the assessment of state variables. ";

%feature("docstring")  cmf_core::CVodeBase::get_states "def
get_states(self, args)

get_states(Integrator self) -> cmf::math::num_array
get_states(Integrator self) -> StateVariableList  StateVariableList
get_states()  gets the state variables of the integrator ";

%feature("docstring")  cmf_core::CVodeBase::get_t "def get_t(self,
args, kwargs)

get_t(Integrator self) -> Time  cmf::math::Time get_t() const  Returns
the current model time. ";

%feature("docstring")  cmf_core::CVodeBase::initialize "def
initialize(self, args, kwargs)

initialize(CVodeBase self) -> int ";

%feature("docstring")  cmf_core::CVodeBase::integrate "def
integrate(self, args, kwargs)

integrate(Integrator self, Time t_max, Time dt) -> int  virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)=0  Integrates the
vector of state variables.  Parameters: -----------  t_max:  To stop
the model (if running in a model framework) at time steps of value
exchange e.g. full hours, the next value exchange time can be given
dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf_core::CVodeBase::integrate_until "def
integrate_until(self, args, kwargs)

integrate_until(Integrator self, Time t_max, Time dt, bool
reset=False)  void integrate_until(cmf::math::Time t_max,
cmf::math::Time dt=Time(), bool reset=false)  Integrates the vector of
state variables until t_max.  Parameters: -----------  t_max:   Time,
the solver should run to  dt:   Time step (may be omitted)  reset:  If
true, solver is reseted before integration starts ";

%feature("docstring")  cmf_core::CVodeBase::reset "def reset(self,
args, kwargs)

reset(Integrator self)  virtual void reset()  Resets any saved history
(for multistep methods) ";

%feature("docstring")  cmf_core::CVodeBase::run "def run(self,
start=None, end=None, step=day *1, max_errors=0, reset=False)

Returns an iterator over the timesteps start..end  **Examples:**  >>>
solver=cmf.CVodeIntegrator(...) >>> for t in solver.run(solver.t,
solver.t + cmf.week, cmf.h): >>>    print(t, solver[0].state) or with
list comprehension >>> states = [solver[0].state for t in
solver.run(solver.t, solver.t + cmf.week, cmf.h)]  Parameters
---------- start : cmf.Time, optional Start time for the solver
iteration end : cmf.Time, optional End time of the iteration step :
cmf.Time, optional Step size for the integration max_errors: int
Number of tolerated errors. If >0, up to these number of runtime
errors will be saved with their time and the integration proceeds
after a reset of the solver. Some systems operate with values close to
their physical limits and inifinite values in the integration can
easily occur. For these kind of systems set max_errors to eg. 10. A
larger number of errors should be eliminated usually. reset: bool If
True, the solver performs a `reset` at every time step  Yields ------
cmf.Time      the actual timestep ";

%feature("docstring")  cmf_core::CVodeBase::set_error_msg "def
set_error_msg(self, args, kwargs)

set_error_msg(CVodeBase self, std::string error) ";

%feature("docstring")  cmf_core::CVodeBase::set_state "def
set_state(self, args, kwargs)

set_state(Integrator self, ptrdiff_t position, real newState)  void
set_state(ptrdiff_t position, real newState)  Simplifies the
assessment of state variables. ";

%feature("docstring")  cmf_core::CVodeBase::set_t "def set_t(self,
args, kwargs)

set_t(Integrator self, Time val)  void set_t(cmf::math::Time val) Sets
the current model time. ";

%feature("docstring")  cmf_core::CVodeBase::size "def size(self,
args, kwargs)

size(Integrator self) -> size_t  size_t size() const  returns the
number of state variables ";

%feature("docstring")  cmf_core::CVodeBase::to_string "def
to_string(self, args, kwargs)

to_string(CVodeBase self) -> std::string ";


// File: classcmf_1_1math_1_1_c_vode_base.xml
%feature("docstring") cmf::math::CVodeBase "

Abstract base class for different modes of the CVode solver.

Initantiate one of the child classes to gain different modes of the
CVode solver

C++ includes: cvode.h ";

/*  Accuracy parameters  */

/*  model time  */

%feature("docstring")  cmf::math::CVodeBase::get_t "cmf::math::Time
get_t() const

Returns the current model time. ";

%feature("docstring")  cmf::math::CVodeBase::set_t "void
set_t(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::CVodeBase::get_dt "cmf::math::Time
get_dt() const

Returns the last time step. ";

/*  Integrate  */

%feature("docstring")  cmf::math::CVodeBase::integrate_until "void
integrate_until(cmf::math::Time t_max, cmf::math::Time dt=Time(), bool
reset=false)

Integrates the vector of state variables until t_max.

Parameters:
-----------

t_max:   Time, the solver should run to

dt:   Time step (may be omitted)

reset:  If true, solver is reseted before integration starts ";

%feature("docstring")  cmf::math::CVodeBase::~CVodeBase "~CVodeBase()
";

%feature("docstring")  cmf::math::CVodeBase::_get_jacobian "virtual
cmf::math::num_array _get_jacobian() const

Returns a continuous 1D array representing the Jacobian columns
concatenated.

In Python, get_jacobian returns the Jacobian as a 2D array ";

%feature("docstring")  cmf::math::CVodeBase::add_single_state "virtual void add_single_state(cmf::math::StateVariable::ptr state)

Adds a single state variable to the integrator. ";

%feature("docstring")  cmf::math::CVodeBase::add_states "virtual void
add_states(cmf::math::StateVariableOwner &stateOwner)

Add state variables from a StateVariableOwner. ";

%feature("docstring")  cmf::math::CVodeBase::add_values_to_states "void add_values_to_states(const num_array &operands)

Adds the values in operands to the current states. ";

%feature("docstring")  cmf::math::CVodeBase::copy "CVodeBase* copy()
const

Returns a copy of the solver. ";

%feature("docstring")  cmf::math::CVodeBase::copy_dxdt "void
copy_dxdt(Time time, num_array &destination, real factor=1) const

Copies the derivatives at time step \"time\" to a numeric vector using
use_OpenMP.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Vector to be overwritten by the results

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::CVodeBase::copy_dxdt "void
copy_dxdt(Time time, real *destination, real factor=1) const

Copies the derivatives at time step \"time\" to an preallocated c
array.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Allocated c array

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::CVodeBase::copy_states "void
copy_states(num_array &destination) const

Copies the states to a numeric vector using use_OpenMP. ";

%feature("docstring")  cmf::math::CVodeBase::copy_states "void
copy_states(real *destination) const ";

%feature("docstring")  cmf::math::CVodeBase::get_dxdt "cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf::math::CVodeBase::get_error "cmf::math::num_array get_error() const

Error vector of the integrator. ";

%feature("docstring")  cmf::math::CVodeBase::get_info "CVodeInfo
get_info() const

Returns the current solver statistics. ";

%feature("docstring")  cmf::math::CVodeBase::get_state "real
get_state(ptrdiff_t position) const

Returns the statevariable at position Simplifies the assessment of
state variables. ";

%feature("docstring")  cmf::math::CVodeBase::get_states "cmf::math::num_array get_states() const ";

%feature("docstring")  cmf::math::CVodeBase::get_states "StateVariableList get_states()

gets the state variables of the integrator ";

%feature("docstring")  cmf::math::CVodeBase::initialize "int
initialize()

Initialize the internal memory.

Automatically called, when one starts to integrate ";

%feature("docstring")  cmf::math::CVodeBase::integrate "virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)

Integrates the vector of state variables.

Parameters:
-----------

t_max:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf::math::CVodeBase::reset "virtual void
reset()

Resets the history of the multispte solver and overwrites the internal
state cache. ";

%feature("docstring")  cmf::math::CVodeBase::set_error_msg "void
set_error_msg(std::string error)

Sets an error message. ";

%feature("docstring")  cmf::math::CVodeBase::set_state "void
set_state(ptrdiff_t position, real newState)

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::CVodeBase::set_states "void
set_states(const num_array &newStates)

Copies the new states to the actual states. ";

%feature("docstring")  cmf::math::CVodeBase::set_states "void
set_states(real *newStates) ";

%feature("docstring")  cmf::math::CVodeBase::size "size_t size()
const

returns the number of state variables ";

%feature("docstring")  cmf::math::CVodeBase::to_string "virtual
std::string to_string() const =0

Returns a string representation of the solver. ";


// File: classcmf__core_1_1_c_vode_dense.xml
%feature("docstring") cmf_core::CVodeDense "

implicit BDF CVode solver with full Jacobian approximation  Use this
solver for small but stiff systems (<20 state variables)  The solver
calculates for each step the full Jacobian matrix of the system using
a difference quotient approximation of the real Jacobian  C++
includes: cvode3.h ";

%feature("docstring")  cmf_core::CVodeDense::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::math::CVodeDense self, StateVariableOwner states, real
epsilon=1e-9) -> CVodeDense  CVodeDense(cmf::math::StateVariableOwner
&states, real epsilon=1e-9)  Creates a new implicit dense CVode
solver. ";

%feature("docstring")  cmf_core::CVodeDense::__call__ "def
__call__(self, t, dt=None, reset=False)

Advances the integration until `t`  A shortcut to .integrate_until
Parameters ---------- t : cmf.Time     The time step to advance to. If
t < current time, the solver will     advance to self.t + t dt :
cmf.Time, optional     The timestep for the integration. If not given
try to integrate in one step reset : bool, optional     If True, the
solver will perform a reset before starting  Returns ------- cmf.Time
The new time stamp ";

%feature("docstring")  cmf_core::CVodeDense::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(Integrator self, long position) ->
cmf::math::StateVariable::ptr ";

%feature("docstring")  cmf_core::CVodeDense::__len__ "def
__len__(self, args, kwargs)

__len__(Integrator self) -> size_t ";

%feature("docstring")  cmf_core::CVodeDense::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::CVodeDense::add_single_state "def
add_single_state(self, args, kwargs)

add_single_state(Integrator self, cmf::math::StateVariable::ptr state)
virtual void add_single_state(cmf::math::StateVariable::ptr state)
Adds a single state variable to the integrator. ";

%feature("docstring")  cmf_core::CVodeDense::add_states "def
add_states(self, args, kwargs)

add_states(Integrator self, StateVariableOwner stateOwner)  virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)  Add state
variables from a StateVariableOwner. ";

%feature("docstring")  cmf_core::CVodeDense::copy "def copy(self,
args, kwargs)

copy(CVodeBase self) -> CVodeBase  virtual Integrator* copy() const =0
Polymorphic copy constructor. ";

%feature("docstring")  cmf_core::CVodeDense::get_dt "def get_dt(self,
args, kwargs)

get_dt(Integrator self) -> Time  cmf::math::Time get_dt() const
Returns the last time step. ";

%feature("docstring")  cmf_core::CVodeDense::get_dxdt "def
get_dxdt(self, args, kwargs)

get_dxdt(Integrator self, Time time) -> cmf::math::num_array
cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf_core::CVodeDense::get_error "def
get_error(self, args, kwargs)

get_error(CVodeBase self) -> cmf::math::num_array ";

%feature("docstring")  cmf_core::CVodeDense::get_info "def
get_info(self, args, kwargs)

get_info(CVodeBase self) -> CVodeInfo ";

%feature("docstring")  cmf_core::CVodeDense::get_jacobian "def
get_jacobian(self) ";

%feature("docstring")  cmf_core::CVodeDense::get_state "def
get_state(self, args, kwargs)

get_state(Integrator self, ptrdiff_t position) -> real  real
get_state(ptrdiff_t position) const  Returns the statevariable at
position Simplifies the assessment of state variables. ";

%feature("docstring")  cmf_core::CVodeDense::get_states "def
get_states(self, args)

get_states(Integrator self) -> cmf::math::num_array
get_states(Integrator self) -> StateVariableList  StateVariableList
get_states()  gets the state variables of the integrator ";

%feature("docstring")  cmf_core::CVodeDense::get_t "def get_t(self,
args, kwargs)

get_t(Integrator self) -> Time  cmf::math::Time get_t() const  Returns
the current model time. ";

%feature("docstring")  cmf_core::CVodeDense::initialize "def
initialize(self, args, kwargs)

initialize(CVodeBase self) -> int ";

%feature("docstring")  cmf_core::CVodeDense::integrate "def
integrate(self, args, kwargs)

integrate(Integrator self, Time t_max, Time dt) -> int  virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)=0  Integrates the
vector of state variables.  Parameters: -----------  t_max:  To stop
the model (if running in a model framework) at time steps of value
exchange e.g. full hours, the next value exchange time can be given
dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf_core::CVodeDense::integrate_until "def
integrate_until(self, args, kwargs)

integrate_until(Integrator self, Time t_max, Time dt, bool
reset=False)  void integrate_until(cmf::math::Time t_max,
cmf::math::Time dt=Time(), bool reset=false)  Integrates the vector of
state variables until t_max.  Parameters: -----------  t_max:   Time,
the solver should run to  dt:   Time step (may be omitted)  reset:  If
true, solver is reseted before integration starts ";

%feature("docstring")  cmf_core::CVodeDense::reset "def reset(self,
args, kwargs)

reset(Integrator self)  virtual void reset()  Resets any saved history
(for multistep methods) ";

%feature("docstring")  cmf_core::CVodeDense::run "def run(self,
start=None, end=None, step=day *1, max_errors=0, reset=False)

Returns an iterator over the timesteps start..end  **Examples:**  >>>
solver=cmf.CVodeIntegrator(...) >>> for t in solver.run(solver.t,
solver.t + cmf.week, cmf.h): >>>    print(t, solver[0].state) or with
list comprehension >>> states = [solver[0].state for t in
solver.run(solver.t, solver.t + cmf.week, cmf.h)]  Parameters
---------- start : cmf.Time, optional Start time for the solver
iteration end : cmf.Time, optional End time of the iteration step :
cmf.Time, optional Step size for the integration max_errors: int
Number of tolerated errors. If >0, up to these number of runtime
errors will be saved with their time and the integration proceeds
after a reset of the solver. Some systems operate with values close to
their physical limits and inifinite values in the integration can
easily occur. For these kind of systems set max_errors to eg. 10. A
larger number of errors should be eliminated usually. reset: bool If
True, the solver performs a `reset` at every time step  Yields ------
cmf.Time      the actual timestep ";

%feature("docstring")  cmf_core::CVodeDense::set_error_msg "def
set_error_msg(self, args, kwargs)

set_error_msg(CVodeBase self, std::string error) ";

%feature("docstring")  cmf_core::CVodeDense::set_state "def
set_state(self, args, kwargs)

set_state(Integrator self, ptrdiff_t position, real newState)  void
set_state(ptrdiff_t position, real newState)  Simplifies the
assessment of state variables. ";

%feature("docstring")  cmf_core::CVodeDense::set_t "def set_t(self,
args, kwargs)

set_t(Integrator self, Time val)  void set_t(cmf::math::Time val) Sets
the current model time. ";

%feature("docstring")  cmf_core::CVodeDense::size "def size(self,
args, kwargs)

size(Integrator self) -> size_t  size_t size() const  returns the
number of state variables ";

%feature("docstring")  cmf_core::CVodeDense::to_string "def
to_string(self, args, kwargs)

to_string(CVodeBase self) -> std::string ";


// File: classcmf_1_1math_1_1_c_vode_dense.xml
%feature("docstring") cmf::math::CVodeDense "

implicit BDF CVode solver with full Jacobian approximation

Use this solver for small but stiff systems (<20 state variables)

The solver calculates for each step the full Jacobian matrix of the
system using a difference quotient approximation of the real Jacobian

C++ includes: cvode.h ";

/*  Accuracy parameters  */

/*  model time  */

%feature("docstring")  cmf::math::CVodeDense::get_t "cmf::math::Time
get_t() const

Returns the current model time. ";

%feature("docstring")  cmf::math::CVodeDense::set_t "void
set_t(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::CVodeDense::get_dt "cmf::math::Time
get_dt() const

Returns the last time step. ";

/*  Integrate  */

%feature("docstring")  cmf::math::CVodeDense::integrate_until "void
integrate_until(cmf::math::Time t_max, cmf::math::Time dt=Time(), bool
reset=false)

Integrates the vector of state variables until t_max.

Parameters:
-----------

t_max:   Time, the solver should run to

dt:   Time step (may be omitted)

reset:  If true, solver is reseted before integration starts ";

%feature("docstring")  cmf::math::CVodeDense::CVodeDense "CVodeDense(cmf::math::StateVariableOwner &states, real epsilon=1e-9)

Creates a new implicit dense CVode solver. ";

%feature("docstring")  cmf::math::CVodeDense::_get_jacobian "virtual
cmf::math::num_array _get_jacobian() const

Returns a continuous 1D array representing the Jacobian columns
concatenated.

In Python, get_jacobian returns the Jacobian as a 2D array ";

%feature("docstring")  cmf::math::CVodeDense::add_single_state "virtual void add_single_state(cmf::math::StateVariable::ptr state)

Adds a single state variable to the integrator. ";

%feature("docstring")  cmf::math::CVodeDense::add_states "virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)

Add state variables from a StateVariableOwner. ";

%feature("docstring")  cmf::math::CVodeDense::add_values_to_states "void add_values_to_states(const num_array &operands)

Adds the values in operands to the current states. ";

%feature("docstring")  cmf::math::CVodeDense::copy "CVodeBase* copy()
const

Returns a copy of the solver. ";

%feature("docstring")  cmf::math::CVodeDense::copy_dxdt "void
copy_dxdt(Time time, num_array &destination, real factor=1) const

Copies the derivatives at time step \"time\" to a numeric vector using
use_OpenMP.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Vector to be overwritten by the results

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::CVodeDense::copy_dxdt "void
copy_dxdt(Time time, real *destination, real factor=1) const

Copies the derivatives at time step \"time\" to an preallocated c
array.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Allocated c array

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::CVodeDense::copy_states "void
copy_states(num_array &destination) const

Copies the states to a numeric vector using use_OpenMP. ";

%feature("docstring")  cmf::math::CVodeDense::copy_states "void
copy_states(real *destination) const ";

%feature("docstring")  cmf::math::CVodeDense::get_dxdt "cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf::math::CVodeDense::get_error "cmf::math::num_array get_error() const

Error vector of the integrator. ";

%feature("docstring")  cmf::math::CVodeDense::get_info "CVodeInfo
get_info() const

Returns the current solver statistics. ";

%feature("docstring")  cmf::math::CVodeDense::get_state "real
get_state(ptrdiff_t position) const

Returns the statevariable at position Simplifies the assessment of
state variables. ";

%feature("docstring")  cmf::math::CVodeDense::get_states "cmf::math::num_array get_states() const ";

%feature("docstring")  cmf::math::CVodeDense::get_states "StateVariableList get_states()

gets the state variables of the integrator ";

%feature("docstring")  cmf::math::CVodeDense::initialize "int
initialize()

Initialize the internal memory.

Automatically called, when one starts to integrate ";

%feature("docstring")  cmf::math::CVodeDense::integrate "virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)

Integrates the vector of state variables.

Parameters:
-----------

t_max:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf::math::CVodeDense::reset "virtual void
reset()

Resets the history of the multispte solver and overwrites the internal
state cache. ";

%feature("docstring")  cmf::math::CVodeDense::set_error_msg "void
set_error_msg(std::string error)

Sets an error message. ";

%feature("docstring")  cmf::math::CVodeDense::set_state "void
set_state(ptrdiff_t position, real newState)

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::CVodeDense::set_states "void
set_states(const num_array &newStates)

Copies the new states to the actual states. ";

%feature("docstring")  cmf::math::CVodeDense::set_states "void
set_states(real *newStates) ";

%feature("docstring")  cmf::math::CVodeDense::size "size_t size()
const

returns the number of state variables ";

%feature("docstring")  cmf::math::CVodeDense::to_string "std::string
to_string() const

Returns a string representation of the solver. ";


// File: classcmf__core_1_1_c_vode_diag.xml
%feature("docstring") cmf_core::CVodeDiag "

implicit BDF CVode solver with a one line diagonal Jacobian
approximation  C++ includes: cvode3.h ";

%feature("docstring")  cmf_core::CVodeDiag::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::math::CVodeDiag self, StateVariableOwner states, real
epsilon=1e-9) -> CVodeDiag  CVodeDiag(cmf::math::StateVariableOwner
&states, real epsilon=1e-9) ";

%feature("docstring")  cmf_core::CVodeDiag::__call__ "def
__call__(self, t, dt=None, reset=False)

Advances the integration until `t`  A shortcut to .integrate_until
Parameters ---------- t : cmf.Time     The time step to advance to. If
t < current time, the solver will     advance to self.t + t dt :
cmf.Time, optional     The timestep for the integration. If not given
try to integrate in one step reset : bool, optional     If True, the
solver will perform a reset before starting  Returns ------- cmf.Time
The new time stamp ";

%feature("docstring")  cmf_core::CVodeDiag::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(Integrator self, long position) ->
cmf::math::StateVariable::ptr ";

%feature("docstring")  cmf_core::CVodeDiag::__len__ "def
__len__(self, args, kwargs)

__len__(Integrator self) -> size_t ";

%feature("docstring")  cmf_core::CVodeDiag::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::CVodeDiag::add_single_state "def
add_single_state(self, args, kwargs)

add_single_state(Integrator self, cmf::math::StateVariable::ptr state)
virtual void add_single_state(cmf::math::StateVariable::ptr state)
Adds a single state variable to the integrator. ";

%feature("docstring")  cmf_core::CVodeDiag::add_states "def
add_states(self, args, kwargs)

add_states(Integrator self, StateVariableOwner stateOwner)  virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)  Add state
variables from a StateVariableOwner. ";

%feature("docstring")  cmf_core::CVodeDiag::copy "def copy(self,
args, kwargs)

copy(CVodeBase self) -> CVodeBase  virtual Integrator* copy() const =0
Polymorphic copy constructor. ";

%feature("docstring")  cmf_core::CVodeDiag::get_dt "def get_dt(self,
args, kwargs)

get_dt(Integrator self) -> Time  cmf::math::Time get_dt() const
Returns the last time step. ";

%feature("docstring")  cmf_core::CVodeDiag::get_dxdt "def
get_dxdt(self, args, kwargs)

get_dxdt(Integrator self, Time time) -> cmf::math::num_array
cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf_core::CVodeDiag::get_error "def
get_error(self, args, kwargs)

get_error(CVodeBase self) -> cmf::math::num_array ";

%feature("docstring")  cmf_core::CVodeDiag::get_info "def
get_info(self, args, kwargs)

get_info(CVodeBase self) -> CVodeInfo ";

%feature("docstring")  cmf_core::CVodeDiag::get_jacobian "def
get_jacobian(self) ";

%feature("docstring")  cmf_core::CVodeDiag::get_state "def
get_state(self, args, kwargs)

get_state(Integrator self, ptrdiff_t position) -> real  real
get_state(ptrdiff_t position) const  Returns the statevariable at
position Simplifies the assessment of state variables. ";

%feature("docstring")  cmf_core::CVodeDiag::get_states "def
get_states(self, args)

get_states(Integrator self) -> cmf::math::num_array
get_states(Integrator self) -> StateVariableList  StateVariableList
get_states()  gets the state variables of the integrator ";

%feature("docstring")  cmf_core::CVodeDiag::get_t "def get_t(self,
args, kwargs)

get_t(Integrator self) -> Time  cmf::math::Time get_t() const  Returns
the current model time. ";

%feature("docstring")  cmf_core::CVodeDiag::initialize "def
initialize(self, args, kwargs)

initialize(CVodeBase self) -> int ";

%feature("docstring")  cmf_core::CVodeDiag::integrate "def
integrate(self, args, kwargs)

integrate(Integrator self, Time t_max, Time dt) -> int  virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)=0  Integrates the
vector of state variables.  Parameters: -----------  t_max:  To stop
the model (if running in a model framework) at time steps of value
exchange e.g. full hours, the next value exchange time can be given
dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf_core::CVodeDiag::integrate_until "def
integrate_until(self, args, kwargs)

integrate_until(Integrator self, Time t_max, Time dt, bool
reset=False)  void integrate_until(cmf::math::Time t_max,
cmf::math::Time dt=Time(), bool reset=false)  Integrates the vector of
state variables until t_max.  Parameters: -----------  t_max:   Time,
the solver should run to  dt:   Time step (may be omitted)  reset:  If
true, solver is reseted before integration starts ";

%feature("docstring")  cmf_core::CVodeDiag::reset "def reset(self,
args, kwargs)

reset(Integrator self)  virtual void reset()  Resets any saved history
(for multistep methods) ";

%feature("docstring")  cmf_core::CVodeDiag::run "def run(self,
start=None, end=None, step=day *1, max_errors=0, reset=False)

Returns an iterator over the timesteps start..end  **Examples:**  >>>
solver=cmf.CVodeIntegrator(...) >>> for t in solver.run(solver.t,
solver.t + cmf.week, cmf.h): >>>    print(t, solver[0].state) or with
list comprehension >>> states = [solver[0].state for t in
solver.run(solver.t, solver.t + cmf.week, cmf.h)]  Parameters
---------- start : cmf.Time, optional Start time for the solver
iteration end : cmf.Time, optional End time of the iteration step :
cmf.Time, optional Step size for the integration max_errors: int
Number of tolerated errors. If >0, up to these number of runtime
errors will be saved with their time and the integration proceeds
after a reset of the solver. Some systems operate with values close to
their physical limits and inifinite values in the integration can
easily occur. For these kind of systems set max_errors to eg. 10. A
larger number of errors should be eliminated usually. reset: bool If
True, the solver performs a `reset` at every time step  Yields ------
cmf.Time      the actual timestep ";

%feature("docstring")  cmf_core::CVodeDiag::set_error_msg "def
set_error_msg(self, args, kwargs)

set_error_msg(CVodeBase self, std::string error) ";

%feature("docstring")  cmf_core::CVodeDiag::set_state "def
set_state(self, args, kwargs)

set_state(Integrator self, ptrdiff_t position, real newState)  void
set_state(ptrdiff_t position, real newState)  Simplifies the
assessment of state variables. ";

%feature("docstring")  cmf_core::CVodeDiag::set_t "def set_t(self,
args, kwargs)

set_t(Integrator self, Time val)  void set_t(cmf::math::Time val) Sets
the current model time. ";

%feature("docstring")  cmf_core::CVodeDiag::size "def size(self,
args, kwargs)

size(Integrator self) -> size_t  size_t size() const  returns the
number of state variables ";

%feature("docstring")  cmf_core::CVodeDiag::to_string "def
to_string(self, args, kwargs)

to_string(CVodeBase self) -> std::string ";


// File: classcmf_1_1math_1_1_c_vode_diag.xml
%feature("docstring") cmf::math::CVodeDiag "

implicit BDF CVode solver with a one line diagonal Jacobian
approximation

C++ includes: cvode.h ";

/*  Accuracy parameters  */

/*  model time  */

%feature("docstring")  cmf::math::CVodeDiag::get_t "cmf::math::Time
get_t() const

Returns the current model time. ";

%feature("docstring")  cmf::math::CVodeDiag::set_t "void
set_t(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::CVodeDiag::get_dt "cmf::math::Time
get_dt() const

Returns the last time step. ";

/*  Integrate  */

%feature("docstring")  cmf::math::CVodeDiag::integrate_until "void
integrate_until(cmf::math::Time t_max, cmf::math::Time dt=Time(), bool
reset=false)

Integrates the vector of state variables until t_max.

Parameters:
-----------

t_max:   Time, the solver should run to

dt:   Time step (may be omitted)

reset:  If true, solver is reseted before integration starts ";

%feature("docstring")  cmf::math::CVodeDiag::CVodeDiag "CVodeDiag(cmf::math::StateVariableOwner &states, real epsilon=1e-9) ";

%feature("docstring")  cmf::math::CVodeDiag::_get_jacobian "virtual
cmf::math::num_array _get_jacobian() const

Returns a continuous 1D array representing the Jacobian columns
concatenated.

In Python, get_jacobian returns the Jacobian as a 2D array ";

%feature("docstring")  cmf::math::CVodeDiag::add_single_state "virtual void add_single_state(cmf::math::StateVariable::ptr state)

Adds a single state variable to the integrator. ";

%feature("docstring")  cmf::math::CVodeDiag::add_states "virtual void
add_states(cmf::math::StateVariableOwner &stateOwner)

Add state variables from a StateVariableOwner. ";

%feature("docstring")  cmf::math::CVodeDiag::add_values_to_states "void add_values_to_states(const num_array &operands)

Adds the values in operands to the current states. ";

%feature("docstring")  cmf::math::CVodeDiag::copy "CVodeBase* copy()
const

Returns a copy of the solver. ";

%feature("docstring")  cmf::math::CVodeDiag::copy_dxdt "void
copy_dxdt(Time time, num_array &destination, real factor=1) const

Copies the derivatives at time step \"time\" to a numeric vector using
use_OpenMP.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Vector to be overwritten by the results

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::CVodeDiag::copy_dxdt "void
copy_dxdt(Time time, real *destination, real factor=1) const

Copies the derivatives at time step \"time\" to an preallocated c
array.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Allocated c array

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::CVodeDiag::copy_states "void
copy_states(num_array &destination) const

Copies the states to a numeric vector using use_OpenMP. ";

%feature("docstring")  cmf::math::CVodeDiag::copy_states "void
copy_states(real *destination) const ";

%feature("docstring")  cmf::math::CVodeDiag::get_dxdt "cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf::math::CVodeDiag::get_error "cmf::math::num_array get_error() const

Error vector of the integrator. ";

%feature("docstring")  cmf::math::CVodeDiag::get_info "CVodeInfo
get_info() const

Returns the current solver statistics. ";

%feature("docstring")  cmf::math::CVodeDiag::get_state "real
get_state(ptrdiff_t position) const

Returns the statevariable at position Simplifies the assessment of
state variables. ";

%feature("docstring")  cmf::math::CVodeDiag::get_states "cmf::math::num_array get_states() const ";

%feature("docstring")  cmf::math::CVodeDiag::get_states "StateVariableList get_states()

gets the state variables of the integrator ";

%feature("docstring")  cmf::math::CVodeDiag::initialize "int
initialize()

Initialize the internal memory.

Automatically called, when one starts to integrate ";

%feature("docstring")  cmf::math::CVodeDiag::integrate "virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)

Integrates the vector of state variables.

Parameters:
-----------

t_max:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf::math::CVodeDiag::reset "virtual void
reset()

Resets the history of the multispte solver and overwrites the internal
state cache. ";

%feature("docstring")  cmf::math::CVodeDiag::set_error_msg "void
set_error_msg(std::string error)

Sets an error message. ";

%feature("docstring")  cmf::math::CVodeDiag::set_state "void
set_state(ptrdiff_t position, real newState)

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::CVodeDiag::set_states "void
set_states(const num_array &newStates)

Copies the new states to the actual states. ";

%feature("docstring")  cmf::math::CVodeDiag::set_states "void
set_states(real *newStates) ";

%feature("docstring")  cmf::math::CVodeDiag::size "size_t size()
const

returns the number of state variables ";

%feature("docstring")  cmf::math::CVodeDiag::to_string "std::string
to_string() const

Returns a string representation of the solver. ";


// File: classcmf__core_1_1_c_vode_info.xml
%feature("docstring") cmf_core::CVodeInfo "

Reports the current state of a CVode solver.  C++ includes: cvode3.h
";

%feature("docstring")  cmf_core::CVodeInfo::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::math::CVodeInfo self) -> CVodeInfo ";

%feature("docstring")  cmf_core::CVodeInfo::to_string "def
to_string(self, args, kwargs)

to_string(CVodeInfo self) -> std::string  std::string to_string()
const ";


// File: structcmf_1_1math_1_1_c_vode_info.xml
%feature("docstring") cmf::math::CVodeInfo "

Reports the current state of a CVode solver.

C++ includes: cvode.h ";

%feature("docstring")  cmf::math::CVodeInfo::to_string "std::string
to_string() const ";


// File: classcmf__core_1_1_c_vode_k_l_u.xml
%feature("docstring") cmf_core::CVodeKLU "

Proxy of C++ cmf::math::CVodeKLU class. ";

%feature("docstring")  cmf_core::CVodeKLU::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::math::CVodeKLU self, StateVariableOwner states, real
epsilon=1e-9) -> CVodeKLU  CVodeKLU(cmf::math::StateVariableOwner
&states, real epsilon=1e-9) ";

%feature("docstring")  cmf_core::CVodeKLU::__call__ "def
__call__(self, t, dt=None, reset=False)

Advances the integration until `t`  A shortcut to .integrate_until
Parameters ---------- t : cmf.Time     The time step to advance to. If
t < current time, the solver will     advance to self.t + t dt :
cmf.Time, optional     The timestep for the integration. If not given
try to integrate in one step reset : bool, optional     If True, the
solver will perform a reset before starting  Returns ------- cmf.Time
The new time stamp ";

%feature("docstring")  cmf_core::CVodeKLU::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(Integrator self, long position) ->
cmf::math::StateVariable::ptr ";

%feature("docstring")  cmf_core::CVodeKLU::__len__ "def __len__(self,
args, kwargs)

__len__(Integrator self) -> size_t ";

%feature("docstring")  cmf_core::CVodeKLU::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::CVodeKLU::add_single_state "def
add_single_state(self, args, kwargs)

add_single_state(Integrator self, cmf::math::StateVariable::ptr state)
virtual void add_single_state(cmf::math::StateVariable::ptr state)
Adds a single state variable to the integrator. ";

%feature("docstring")  cmf_core::CVodeKLU::add_states "def
add_states(self, args, kwargs)

add_states(Integrator self, StateVariableOwner stateOwner)  virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)  Add state
variables from a StateVariableOwner. ";

%feature("docstring")  cmf_core::CVodeKLU::copy "def copy(self, args,
kwargs)

copy(CVodeBase self) -> CVodeBase  virtual Integrator* copy() const =0
Polymorphic copy constructor. ";

%feature("docstring")  cmf_core::CVodeKLU::get_dt "def get_dt(self,
args, kwargs)

get_dt(Integrator self) -> Time  cmf::math::Time get_dt() const
Returns the last time step. ";

%feature("docstring")  cmf_core::CVodeKLU::get_dxdt "def
get_dxdt(self, args, kwargs)

get_dxdt(Integrator self, Time time) -> cmf::math::num_array
cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf_core::CVodeKLU::get_error "def
get_error(self, args, kwargs)

get_error(CVodeBase self) -> cmf::math::num_array ";

%feature("docstring")  cmf_core::CVodeKLU::get_info "def
get_info(self, args, kwargs)

get_info(CVodeBase self) -> CVodeInfo ";

%feature("docstring")  cmf_core::CVodeKLU::get_jacobian "def
get_jacobian(self) ";

%feature("docstring")  cmf_core::CVodeKLU::get_state "def
get_state(self, args, kwargs)

get_state(Integrator self, ptrdiff_t position) -> real  real
get_state(ptrdiff_t position) const  Returns the statevariable at
position Simplifies the assessment of state variables. ";

%feature("docstring")  cmf_core::CVodeKLU::get_states "def
get_states(self, args)

get_states(Integrator self) -> cmf::math::num_array
get_states(Integrator self) -> StateVariableList  StateVariableList
get_states()  gets the state variables of the integrator ";

%feature("docstring")  cmf_core::CVodeKLU::get_t "def get_t(self,
args, kwargs)

get_t(Integrator self) -> Time  cmf::math::Time get_t() const  Returns
the current model time. ";

%feature("docstring")  cmf_core::CVodeKLU::initialize "def
initialize(self, args, kwargs)

initialize(CVodeBase self) -> int ";

%feature("docstring")  cmf_core::CVodeKLU::integrate "def
integrate(self, args, kwargs)

integrate(Integrator self, Time t_max, Time dt) -> int  virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)=0  Integrates the
vector of state variables.  Parameters: -----------  t_max:  To stop
the model (if running in a model framework) at time steps of value
exchange e.g. full hours, the next value exchange time can be given
dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf_core::CVodeKLU::integrate_until "def
integrate_until(self, args, kwargs)

integrate_until(Integrator self, Time t_max, Time dt, bool
reset=False)  void integrate_until(cmf::math::Time t_max,
cmf::math::Time dt=Time(), bool reset=false)  Integrates the vector of
state variables until t_max.  Parameters: -----------  t_max:   Time,
the solver should run to  dt:   Time step (may be omitted)  reset:  If
true, solver is reseted before integration starts ";

%feature("docstring")  cmf_core::CVodeKLU::reset "def reset(self,
args, kwargs)

reset(Integrator self)  virtual void reset()  Resets any saved history
(for multistep methods) ";

%feature("docstring")  cmf_core::CVodeKLU::run "def run(self,
start=None, end=None, step=day *1, max_errors=0, reset=False)

Returns an iterator over the timesteps start..end  **Examples:**  >>>
solver=cmf.CVodeIntegrator(...) >>> for t in solver.run(solver.t,
solver.t + cmf.week, cmf.h): >>>    print(t, solver[0].state) or with
list comprehension >>> states = [solver[0].state for t in
solver.run(solver.t, solver.t + cmf.week, cmf.h)]  Parameters
---------- start : cmf.Time, optional Start time for the solver
iteration end : cmf.Time, optional End time of the iteration step :
cmf.Time, optional Step size for the integration max_errors: int
Number of tolerated errors. If >0, up to these number of runtime
errors will be saved with their time and the integration proceeds
after a reset of the solver. Some systems operate with values close to
their physical limits and inifinite values in the integration can
easily occur. For these kind of systems set max_errors to eg. 10. A
larger number of errors should be eliminated usually. reset: bool If
True, the solver performs a `reset` at every time step  Yields ------
cmf.Time      the actual timestep ";

%feature("docstring")  cmf_core::CVodeKLU::set_error_msg "def
set_error_msg(self, args, kwargs)

set_error_msg(CVodeBase self, std::string error) ";

%feature("docstring")  cmf_core::CVodeKLU::set_state "def
set_state(self, args, kwargs)

set_state(Integrator self, ptrdiff_t position, real newState)  void
set_state(ptrdiff_t position, real newState)  Simplifies the
assessment of state variables. ";

%feature("docstring")  cmf_core::CVodeKLU::set_t "def set_t(self,
args, kwargs)

set_t(Integrator self, Time val)  void set_t(cmf::math::Time val) Sets
the current model time. ";

%feature("docstring")  cmf_core::CVodeKLU::size "def size(self, args,
kwargs)

size(Integrator self) -> size_t  size_t size() const  returns the
number of state variables ";

%feature("docstring")  cmf_core::CVodeKLU::to_string "def
to_string(self, args, kwargs)

to_string(CVodeBase self) -> std::string ";


// File: classcmf_1_1math_1_1_c_vode_k_l_u.xml
%feature("docstring") cmf::math::CVodeKLU "";

/*  model time  */

%feature("docstring")  cmf::math::CVodeKLU::get_t "cmf::math::Time
get_t() const

Returns the current model time. ";

%feature("docstring")  cmf::math::CVodeKLU::set_t "void
set_t(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::CVodeKLU::get_dt "cmf::math::Time
get_dt() const

Returns the last time step. ";

/*  Integrate  */

%feature("docstring")  cmf::math::CVodeKLU::integrate_until "void
integrate_until(cmf::math::Time t_max, cmf::math::Time dt=Time(), bool
reset=false)

Integrates the vector of state variables until t_max.

Parameters:
-----------

t_max:   Time, the solver should run to

dt:   Time step (may be omitted)

reset:  If true, solver is reseted before integration starts ";

/*  Accuracy parameters  */

%feature("docstring")  cmf::math::CVodeKLU::CVodeKLU "CVodeKLU(cmf::math::StateVariableOwner &states, real epsilon=1e-9) ";

%feature("docstring")  cmf::math::CVodeKLU::_get_jacobian "virtual
cmf::math::num_array _get_jacobian() const ";

%feature("docstring")  cmf::math::CVodeKLU::add_single_state "virtual
void add_single_state(cmf::math::StateVariable::ptr state)

Adds a single state variable to the integrator. ";

%feature("docstring")  cmf::math::CVodeKLU::add_states "virtual void
add_states(cmf::math::StateVariableOwner &stateOwner)

Add state variables from a StateVariableOwner. ";

%feature("docstring")  cmf::math::CVodeKLU::add_values_to_states "void add_values_to_states(const num_array &operands)

Adds the values in operands to the current states. ";

%feature("docstring")  cmf::math::CVodeKLU::copy "CVodeBase* copy()
const

Returns a copy of the solver. ";

%feature("docstring")  cmf::math::CVodeKLU::copy_dxdt "void
copy_dxdt(Time time, num_array &destination, real factor=1) const

Copies the derivatives at time step \"time\" to a numeric vector using
use_OpenMP.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Vector to be overwritten by the results

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::CVodeKLU::copy_dxdt "void
copy_dxdt(Time time, real *destination, real factor=1) const

Copies the derivatives at time step \"time\" to an preallocated c
array.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Allocated c array

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::CVodeKLU::copy_states "void
copy_states(num_array &destination) const

Copies the states to a numeric vector using use_OpenMP. ";

%feature("docstring")  cmf::math::CVodeKLU::copy_states "void
copy_states(real *destination) const ";

%feature("docstring")  cmf::math::CVodeKLU::get_dxdt "cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf::math::CVodeKLU::get_error "cmf::math::num_array get_error() const

Error vector of the integrator. ";

%feature("docstring")  cmf::math::CVodeKLU::get_info "CVodeInfo
get_info() const

Returns the current solver statistics. ";

%feature("docstring")  cmf::math::CVodeKLU::get_state "real
get_state(ptrdiff_t position) const

Returns the statevariable at position Simplifies the assessment of
state variables. ";

%feature("docstring")  cmf::math::CVodeKLU::get_states "cmf::math::num_array get_states() const ";

%feature("docstring")  cmf::math::CVodeKLU::get_states "StateVariableList get_states()

gets the state variables of the integrator ";

%feature("docstring")  cmf::math::CVodeKLU::initialize "int
initialize()

Initialize the internal memory.

Automatically called, when one starts to integrate ";

%feature("docstring")  cmf::math::CVodeKLU::integrate "virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)

Integrates the vector of state variables.

Parameters:
-----------

t_max:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf::math::CVodeKLU::reset "virtual void
reset()

Resets the history of the multispte solver and overwrites the internal
state cache. ";

%feature("docstring")  cmf::math::CVodeKLU::set_error_msg "void
set_error_msg(std::string error)

Sets an error message. ";

%feature("docstring")  cmf::math::CVodeKLU::set_state "void
set_state(ptrdiff_t position, real newState)

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::CVodeKLU::set_states "void
set_states(const num_array &newStates)

Copies the new states to the actual states. ";

%feature("docstring")  cmf::math::CVodeKLU::set_states "void
set_states(real *newStates) ";

%feature("docstring")  cmf::math::CVodeKLU::size "size_t size() const

returns the number of state variables ";

%feature("docstring")  cmf::math::CVodeKLU::to_string "std::string
to_string() const ";


// File: classcmf__core_1_1_c_vode_krylov.xml
%feature("docstring") cmf_core::CVodeKrylov "

implicit BDF CVode solver with a Krylov preconditioner  C++ includes:
cvode3.h ";

%feature("docstring")  cmf_core::CVodeKrylov::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::math::CVodeKrylov self, StateVariableOwner states, real
epsilon=1e-9, int w=5, char p) -> CVodeKrylov
CVodeKrylov(cmf::math::StateVariableOwner &states, real epsilon=1e-9,
int w=5, char p='L') ";

%feature("docstring")  cmf_core::CVodeKrylov::__call__ "def
__call__(self, t, dt=None, reset=False)

Advances the integration until `t`  A shortcut to .integrate_until
Parameters ---------- t : cmf.Time     The time step to advance to. If
t < current time, the solver will     advance to self.t + t dt :
cmf.Time, optional     The timestep for the integration. If not given
try to integrate in one step reset : bool, optional     If True, the
solver will perform a reset before starting  Returns ------- cmf.Time
The new time stamp ";

%feature("docstring")  cmf_core::CVodeKrylov::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(Integrator self, long position) ->
cmf::math::StateVariable::ptr ";

%feature("docstring")  cmf_core::CVodeKrylov::__len__ "def
__len__(self, args, kwargs)

__len__(Integrator self) -> size_t ";

%feature("docstring")  cmf_core::CVodeKrylov::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::CVodeKrylov::add_single_state "def
add_single_state(self, args, kwargs)

add_single_state(Integrator self, cmf::math::StateVariable::ptr state)
virtual void add_single_state(cmf::math::StateVariable::ptr state)
Adds a single state variable to the integrator. ";

%feature("docstring")  cmf_core::CVodeKrylov::add_states "def
add_states(self, args, kwargs)

add_states(Integrator self, StateVariableOwner stateOwner)  virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)  Add state
variables from a StateVariableOwner. ";

%feature("docstring")  cmf_core::CVodeKrylov::copy "def copy(self,
args, kwargs)

copy(CVodeBase self) -> CVodeBase  virtual Integrator* copy() const =0
Polymorphic copy constructor. ";

%feature("docstring")  cmf_core::CVodeKrylov::get_dt "def
get_dt(self, args, kwargs)

get_dt(Integrator self) -> Time  cmf::math::Time get_dt() const
Returns the last time step. ";

%feature("docstring")  cmf_core::CVodeKrylov::get_dxdt "def
get_dxdt(self, args, kwargs)

get_dxdt(Integrator self, Time time) -> cmf::math::num_array
cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf_core::CVodeKrylov::get_error "def
get_error(self, args, kwargs)

get_error(CVodeBase self) -> cmf::math::num_array ";

%feature("docstring")  cmf_core::CVodeKrylov::get_info "def
get_info(self, args, kwargs)

get_info(CVodeBase self) -> CVodeInfo ";

%feature("docstring")  cmf_core::CVodeKrylov::get_jacobian "def
get_jacobian(self) ";

%feature("docstring")  cmf_core::CVodeKrylov::get_state "def
get_state(self, args, kwargs)

get_state(Integrator self, ptrdiff_t position) -> real  real
get_state(ptrdiff_t position) const  Returns the statevariable at
position Simplifies the assessment of state variables. ";

%feature("docstring")  cmf_core::CVodeKrylov::get_states "def
get_states(self, args)

get_states(Integrator self) -> cmf::math::num_array
get_states(Integrator self) -> StateVariableList  StateVariableList
get_states()  gets the state variables of the integrator ";

%feature("docstring")  cmf_core::CVodeKrylov::get_t "def get_t(self,
args, kwargs)

get_t(Integrator self) -> Time  cmf::math::Time get_t() const  Returns
the current model time. ";

%feature("docstring")  cmf_core::CVodeKrylov::initialize "def
initialize(self, args, kwargs)

initialize(CVodeBase self) -> int ";

%feature("docstring")  cmf_core::CVodeKrylov::integrate "def
integrate(self, args, kwargs)

integrate(Integrator self, Time t_max, Time dt) -> int  virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)=0  Integrates the
vector of state variables.  Parameters: -----------  t_max:  To stop
the model (if running in a model framework) at time steps of value
exchange e.g. full hours, the next value exchange time can be given
dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf_core::CVodeKrylov::integrate_until "def
integrate_until(self, args, kwargs)

integrate_until(Integrator self, Time t_max, Time dt, bool
reset=False)  void integrate_until(cmf::math::Time t_max,
cmf::math::Time dt=Time(), bool reset=false)  Integrates the vector of
state variables until t_max.  Parameters: -----------  t_max:   Time,
the solver should run to  dt:   Time step (may be omitted)  reset:  If
true, solver is reseted before integration starts ";

%feature("docstring")  cmf_core::CVodeKrylov::reset "def reset(self,
args, kwargs)

reset(Integrator self)  virtual void reset()  Resets any saved history
(for multistep methods) ";

%feature("docstring")  cmf_core::CVodeKrylov::run "def run(self,
start=None, end=None, step=day *1, max_errors=0, reset=False)

Returns an iterator over the timesteps start..end  **Examples:**  >>>
solver=cmf.CVodeIntegrator(...) >>> for t in solver.run(solver.t,
solver.t + cmf.week, cmf.h): >>>    print(t, solver[0].state) or with
list comprehension >>> states = [solver[0].state for t in
solver.run(solver.t, solver.t + cmf.week, cmf.h)]  Parameters
---------- start : cmf.Time, optional Start time for the solver
iteration end : cmf.Time, optional End time of the iteration step :
cmf.Time, optional Step size for the integration max_errors: int
Number of tolerated errors. If >0, up to these number of runtime
errors will be saved with their time and the integration proceeds
after a reset of the solver. Some systems operate with values close to
their physical limits and inifinite values in the integration can
easily occur. For these kind of systems set max_errors to eg. 10. A
larger number of errors should be eliminated usually. reset: bool If
True, the solver performs a `reset` at every time step  Yields ------
cmf.Time      the actual timestep ";

%feature("docstring")  cmf_core::CVodeKrylov::set_error_msg "def
set_error_msg(self, args, kwargs)

set_error_msg(CVodeBase self, std::string error) ";

%feature("docstring")  cmf_core::CVodeKrylov::set_state "def
set_state(self, args, kwargs)

set_state(Integrator self, ptrdiff_t position, real newState)  void
set_state(ptrdiff_t position, real newState)  Simplifies the
assessment of state variables. ";

%feature("docstring")  cmf_core::CVodeKrylov::set_t "def set_t(self,
args, kwargs)

set_t(Integrator self, Time val)  void set_t(cmf::math::Time val) Sets
the current model time. ";

%feature("docstring")  cmf_core::CVodeKrylov::size "def size(self,
args, kwargs)

size(Integrator self) -> size_t  size_t size() const  returns the
number of state variables ";

%feature("docstring")  cmf_core::CVodeKrylov::to_string "def
to_string(self, args, kwargs)

to_string(CVodeBase self) -> std::string ";


// File: classcmf_1_1math_1_1_c_vode_krylov.xml
%feature("docstring") cmf::math::CVodeKrylov "

implicit BDF CVode solver with a Krylov preconditioner

C++ includes: cvode.h ";

/*  Accuracy parameters  */

/*  model time  */

%feature("docstring")  cmf::math::CVodeKrylov::get_t "cmf::math::Time
get_t() const

Returns the current model time. ";

%feature("docstring")  cmf::math::CVodeKrylov::set_t "void
set_t(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::CVodeKrylov::get_dt "cmf::math::Time get_dt() const

Returns the last time step. ";

/*  Integrate  */

%feature("docstring")  cmf::math::CVodeKrylov::integrate_until "void
integrate_until(cmf::math::Time t_max, cmf::math::Time dt=Time(), bool
reset=false)

Integrates the vector of state variables until t_max.

Parameters:
-----------

t_max:   Time, the solver should run to

dt:   Time step (may be omitted)

reset:  If true, solver is reseted before integration starts ";

%feature("docstring")  cmf::math::CVodeKrylov::CVodeKrylov "CVodeKrylov(cmf::math::StateVariableOwner &states, real epsilon=1e-9,
int w=5, char p='L') ";

%feature("docstring")  cmf::math::CVodeKrylov::_get_jacobian "virtual
cmf::math::num_array _get_jacobian() const

Returns a continuous 1D array representing the Jacobian columns
concatenated.

In Python, get_jacobian returns the Jacobian as a 2D array ";

%feature("docstring")  cmf::math::CVodeKrylov::add_single_state "virtual void add_single_state(cmf::math::StateVariable::ptr state)

Adds a single state variable to the integrator. ";

%feature("docstring")  cmf::math::CVodeKrylov::add_states "virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)

Add state variables from a StateVariableOwner. ";

%feature("docstring")  cmf::math::CVodeKrylov::add_values_to_states "void add_values_to_states(const num_array &operands)

Adds the values in operands to the current states. ";

%feature("docstring")  cmf::math::CVodeKrylov::copy "CVodeBase*
copy() const

Returns a copy of the solver. ";

%feature("docstring")  cmf::math::CVodeKrylov::copy_dxdt "void
copy_dxdt(Time time, num_array &destination, real factor=1) const

Copies the derivatives at time step \"time\" to a numeric vector using
use_OpenMP.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Vector to be overwritten by the results

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::CVodeKrylov::copy_dxdt "void
copy_dxdt(Time time, real *destination, real factor=1) const

Copies the derivatives at time step \"time\" to an preallocated c
array.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Allocated c array

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::CVodeKrylov::copy_states "void
copy_states(num_array &destination) const

Copies the states to a numeric vector using use_OpenMP. ";

%feature("docstring")  cmf::math::CVodeKrylov::copy_states "void
copy_states(real *destination) const ";

%feature("docstring")  cmf::math::CVodeKrylov::get_dxdt "cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf::math::CVodeKrylov::get_error "cmf::math::num_array get_error() const

Error vector of the integrator. ";

%feature("docstring")  cmf::math::CVodeKrylov::get_info "CVodeInfo
get_info() const

Returns the current solver statistics. ";

%feature("docstring")  cmf::math::CVodeKrylov::get_state "real
get_state(ptrdiff_t position) const

Returns the statevariable at position Simplifies the assessment of
state variables. ";

%feature("docstring")  cmf::math::CVodeKrylov::get_states "cmf::math::num_array get_states() const ";

%feature("docstring")  cmf::math::CVodeKrylov::get_states "StateVariableList get_states()

gets the state variables of the integrator ";

%feature("docstring")  cmf::math::CVodeKrylov::initialize "int
initialize()

Initialize the internal memory.

Automatically called, when one starts to integrate ";

%feature("docstring")  cmf::math::CVodeKrylov::integrate "virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)

Integrates the vector of state variables.

Parameters:
-----------

t_max:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf::math::CVodeKrylov::reset "virtual void
reset()

Resets the history of the multispte solver and overwrites the internal
state cache. ";

%feature("docstring")  cmf::math::CVodeKrylov::set_error_msg "void
set_error_msg(std::string error)

Sets an error message. ";

%feature("docstring")  cmf::math::CVodeKrylov::set_state "void
set_state(ptrdiff_t position, real newState)

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::CVodeKrylov::set_states "void
set_states(const num_array &newStates)

Copies the new states to the actual states. ";

%feature("docstring")  cmf::math::CVodeKrylov::set_states "void
set_states(real *newStates) ";

%feature("docstring")  cmf::math::CVodeKrylov::size "size_t size()
const

returns the number of state variables ";

%feature("docstring")  cmf::math::CVodeKrylov::to_string "std::string
to_string() const

Returns a string representation of the solver. ";


// File: classcmf__core_1_1_c_vode_options.xml
%feature("docstring") cmf_core::CVodeOptions "

A set of options for all CVode3 solver.  Negative numbers indicate
that this option stays on the default value. For the meaning of the
options see CVODE-UD, section 4.5.6  See Hindmarsh, A., Serban, R. and
Reynolds, D.: User Documentation for cvode v3.1.0, 2017, UCRL-
SM-208108  Usage example: >>>solver = CVodeDens(p, 1e-9)
>>>solver.options.max_order = 2  C++ includes: cvode3.h ";

%feature("docstring")  cmf_core::CVodeOptions::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::math::CVodeOptions self) -> CVodeOptions  CVodeOptions()
";


// File: structcmf_1_1math_1_1_c_vode_options.xml
%feature("docstring") cmf::math::CVodeOptions "

A set of options for all CVode3 solver.

Negative numbers indicate that this option stays on the default value.
For the meaning of the options see CVODE-UD, section 4.5.6

See Hindmarsh, A., Serban, R. and Reynolds, D.: User Documentation for
cvode v3.1.0, 2017, UCRL-SM-208108

Usage example: >>>solver = CVodeDens(p, 1e-9)
>>>solver.options.max_order = 2

C++ includes: cvode.h ";

%feature("docstring")  cmf::math::CVodeOptions::CVodeOptions "CVodeOptions() ";


// File: classcmf__core_1_1_darcy.xml
%feature("docstring") cmf_core::Darcy "

Calculates the lateral flow using the gravitational potential gradient
only.    .. math::       q_{lat} = \\\\\\\\frac{\\\\\\\\Delta
\\\\\\\\Psi_G}{\\\\\\\\|C_1-C_2\\\\\\\\|}     \\\\\\\\frac 12
(T(C_1)+T(C_2)) w   where  :math:`\\\\\\\\Delta \\\\\\\\Psi_G` is the
gravitational potential difference  :math:`\\\\\\\\|C_1-C_2\\\\\\\\|`
is the distance from Cell 1 to Cell 2  :math:`T(C)` is the
transmissivity of cell C, calculated by SoilType::Transmissivity
:math:`w` is the width of the connection of the cells  C++ includes:
subsurfacefluxes.h ";

%feature("docstring")  cmf_core::Darcy::__init__ "def __init__(self,
args, kwargs)

__init__(cmf::upslope::connections::Darcy self,
cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right,
real FlowWidth, real Distance=0) -> Darcy
Darcy(cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr
right, real FlowWidth, real Distance=0) ";

%feature("docstring")  cmf_core::Darcy::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::Darcy::__eq__ "def __eq__(self,
args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::Darcy::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::Darcy::__iter__ "def __iter__(self)
";

%feature("docstring")  cmf_core::Darcy::__repr__ "def __repr__(self)
";

%feature("docstring")  cmf_core::Darcy::conc "def conc(self, args,
kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::Darcy::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::Darcy::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::Darcy::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::Darcy::kill_me "def kill_me(self,
args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::Darcy::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::Darcy::q "def q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::Darcy::refresh "def refresh(self,
args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::Darcy::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::Darcy::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::Darcy::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::Darcy::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1connections_1_1_darcy.xml
%feature("docstring") cmf::upslope::connections::Darcy "

Calculates the lateral flow using the gravitational potential gradient
only.



.. math::

     q_{lat} = \\\\frac{\\\\Delta \\\\Psi_G}{\\\\|C_1-C_2\\\\|}
    \\\\frac 12 (T(C_1)+T(C_2)) w 

where  :math:`\\\\Delta \\\\Psi_G` is
the gravitational potential difference

:math:`\\\\|C_1-C_2\\\\|` is the distance from Cell 1 to Cell 2

:math:`T(C)` is the transmissivity of cell C, calculated by
SoilType::Transmissivity

:math:`w` is the width of the connection of the cells

C++ includes: subsurfacefluxes.h ";

%feature("docstring")  cmf::upslope::connections::Darcy::Darcy "Darcy(cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr
right, real FlowWidth, real Distance=0) ";

%feature("docstring")  cmf::upslope::connections::Darcy::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::Darcy::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::upslope::connections::Darcy::get_ptr "ptr
get_ptr() const ";

%feature("docstring")  cmf::upslope::connections::Darcy::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::connections::Darcy::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::Darcy::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::Darcy::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::connections::Darcy::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::upslope::connections::Darcy::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::connections::Darcy::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::connections::Darcy::refresh "void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::upslope::connections::Darcy::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::Darcy::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::Darcy::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf::upslope::connections::Darcy::short_string
"virtual std::string short_string() const ";

%feature("docstring")  cmf::upslope::connections::Darcy::to_string "virtual std::string to_string() const ";


// File: classcmf__core_1_1_darcy_kinematic.xml
%feature("docstring") cmf_core::DarcyKinematic "

A simple kinemtic wave model for subsurface flux.    .. math::       q
= \\\\\\\\frac{\\\\\\\\Delta z_{surface}}{d} K(\\\\\\\\theta)_{source}
A_{cross}   C++ includes: subsurfacefluxes.h ";

%feature("docstring")  cmf_core::DarcyKinematic::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::DarcyKinematic self,
cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right,
real FlowWidth, real Distance=0) -> DarcyKinematic
DarcyKinematic(cmf::upslope::SoilLayer::ptr left,
cmf::water::flux_node::ptr right, real FlowWidth, real Distance=0)
Creates the connection.  Parameters: -----------  left:  Left node of
the connection (needs to be soil water storage)  right:  Right node of
the connection (can be any node)  FlowWidth:  the width of the
connection - is multiplied by layer thickness to get the interface
area  Distance:  the length of the connection. If 0, the distance is
calculated from the position of the nodes ";

%feature("docstring")  cmf_core::DarcyKinematic::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::DarcyKinematic::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::DarcyKinematic::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::DarcyKinematic::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::DarcyKinematic::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::DarcyKinematic::conc "def conc(self,
args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::DarcyKinematic::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::DarcyKinematic::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::DarcyKinematic::get_tracer_filter "def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::DarcyKinematic::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::DarcyKinematic::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::DarcyKinematic::q "def q(self, args,
kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::DarcyKinematic::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::DarcyKinematic::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::DarcyKinematic::set_tracer_filter "def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::DarcyKinematic::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::DarcyKinematic::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1connections_1_1_darcy_kinematic.xml
%feature("docstring") cmf::upslope::connections::DarcyKinematic "

A simple kinemtic wave model for subsurface flux.



.. math::

     q = \\\\frac{\\\\Delta z_{surface}}{d} K(\\\\theta)_{source}
    A_{cross} 

C++ includes: subsurfacefluxes.h ";

%feature("docstring")
cmf::upslope::connections::DarcyKinematic::DarcyKinematic "DarcyKinematic(cmf::upslope::SoilLayer::ptr left,
cmf::water::flux_node::ptr right, real FlowWidth, real Distance=0)

Creates the connection.

Parameters:
-----------

left:  Left node of the connection (needs to be soil water storage)

right:  Right node of the connection (can be any node)

FlowWidth:  the width of the connection - is multiplied by layer
thickness to get the interface area

Distance:  the length of the connection. If 0, the distance is
calculated from the position of the nodes ";

%feature("docstring")  cmf::upslope::connections::DarcyKinematic::conc
"real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::DarcyKinematic::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::upslope::connections::DarcyKinematic::get_ptr "ptr get_ptr()
const ";

%feature("docstring")
cmf::upslope::connections::DarcyKinematic::get_target "flux_node::ptr
get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::DarcyKinematic::get_target "flux_node::ptr
get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::DarcyKinematic::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::DarcyKinematic::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::DarcyKinematic::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::DarcyKinematic::left_node "flux_node::ptr
left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::connections::DarcyKinematic::q "real q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::DarcyKinematic::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::DarcyKinematic::right_node "flux_node::ptr
right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::DarcyKinematic::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::DarcyKinematic::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::DarcyKinematic::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::DarcyKinematic::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_date.xml
%feature("docstring") cmf_core::Date "

An absolute time, not for calculation. Date and Time are
interchangable.  C++ includes: time.h ";

%feature("docstring")  cmf_core::Date::__init__ "def __init__(self,
args)

__init__(cmf::math::Date self, int _day, int _month, int _year, int
_hour=0, int _minute=0, int _second=0, int _ms=0) -> Date
__init__(cmf::math::Date self, Time time) -> Date  Date(const Time
&time)  Creates a new date from time (based on the 31.12.1899, like in
Excel(TM)) ";

%feature("docstring")  cmf_core::Date::__getstate__ "def
__getstate__(self) ";

%feature("docstring")  cmf_core::Date::__repr__ "def __repr__(self)
";

%feature("docstring")  cmf_core::Date::__setstate__ "def
__setstate__(self, data) ";

%feature("docstring")  cmf_core::Date::as_datetime "def
as_datetime(self) ";

%feature("docstring")  cmf_core::Date::AsPython "def AsPython(self)
";

%feature("docstring")  cmf_core::Date::DOY "def DOY(self, args,
kwargs)

DOY(Date self) -> double  double DOY()  Returns the day of year. ";

%feature("docstring")  cmf_core::Date::to_string "def to_string(self,
args, kwargs)

to_string(Date self) -> std::string  std::string to_string()  Returns
a string representing the date. ";

%feature("docstring")  cmf_core::Date::ToTime "def ToTime(self, args,
kwargs)

ToTime(Date self) -> Time  Time ToTime()  Converts a date to Time
(based on the 31.12.1899, like in Excel(TM) ";


// File: structcmf_1_1math_1_1_date.xml
%feature("docstring") cmf::math::Date "

An absolute time, not for calculation. Date and Time are
interchangable.

C++ includes: time.h ";

%feature("docstring")  cmf::math::Date::Date "Date(int _day, int
_month, int _year, int _hour=0, int _minute=0, int _second=0, int
_ms=0)

Creates a new date. ";

%feature("docstring")  cmf::math::Date::Date "Date(const Time &time)

Creates a new date from time (based on the 31.12.1899, like in
Excel(TM)) ";

%feature("docstring")  cmf::math::Date::DOY "double DOY()

Returns the day of year. ";

%feature("docstring")  cmf::math::Date::to_string "std::string
to_string()

Returns a string representing the date. ";

%feature("docstring")  cmf::math::Date::ToTime "Time ToTime()

Converts a date to Time (based on the 31.12.1899, like in Excel(TM) ";


// File: classcmf_1_1upslope_1_1connections_1_1_diffusive_macro_micro_exchange.xml
%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange "

A simple first order diffusive water exchange between MacroPore and
matrix ( SoilLayer)



.. math::

     q = \\\\omega (W_{ma} - W_{mi,eff}) V_{soil}

where:
:math:`\\\\omega` is the exchange rate in :math:`day^{-1}`

:math:`W_{ma}` is the filled fraction of the macropore system [-]

:math:`W_{mi,eff}` is the water filled pore space of the micropores above
the residual pF value [-], default 4.2

:math:`V_{soil} = A_{cell} d_{layer}` is the total volume of the soil layer
[ :math:`m^3`]

The residual micropore pF is used to determine a residual water
content of the micropores. Residual in this case means, that above
this pF value, water is not draining to the macro pores, even if they
are empty. Although the default value is at wilting point, lower pF
values are much more sensible, and should be rather lower than field
capacity (pF=1.8 - 2.5). However, since this equation is rather
conceptual than physical, this value can only be estimated or
calibrated.

cf. Simunek et al J. of Hydr. 2003

C++ includes: macropore.h ";

%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange::DiffusiveMacroMicroExchange
"DiffusiveMacroMicroExchange(cmf::upslope::MacroPore::ptr left,
cmf::upslope::SoilLayer::ptr right, real omega, real pFrmi=4.2) ";

%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange::exchange_target
"void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange::get_ptr "ptr
get_ptr() const ";

%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange::get_tracer_filter
"real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange::get_tracer_filter
"real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange::set_tracer_filter
"void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange::set_tracer_filter
"void set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange::short_string "virtual std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::DiffusiveMacroMicroExchange::to_string "virtual std::string to_string() const ";


// File: classcmf__core_1_1_diffusive_macro_micro_exchange.xml
%feature("docstring") cmf_core::DiffusiveMacroMicroExchange "

A simple first order diffusive water exchange between MacroPore and
matrix ( SoilLayer)    .. math::       q = \\\\\\\\omega (W_{ma} -
W_{mi,eff}) V_{soil}  where: :math:`\\\\\\\\omega` is the exchange
rate in :math:`day^{-1}`  :math:`W_{ma}` is the filled fraction of the
macropore system [-]  :math:`W_{mi,eff}` is the water filled pore
space of the micropores above the residual pF value [-], default 4.2
:math:`V_{soil} = A_{cell} d_{layer}` is the total volume of the soil
layer [ :math:`m^3`]  The residual micropore pF is used to determine a
residual water content of the micropores. Residual in this case means,
that above this pF value, water is not draining to the macro pores,
even if they are empty. Although the default value is at wilting
point, lower pF values are much more sensible, and should be rather
lower than field capacity (pF=1.8 - 2.5). However, since this equation
is rather conceptual than physical, this value can only be estimated
or calibrated.  cf. Simunek et al J. of Hydr. 2003  C++ includes:
macropore.h ";

%feature("docstring")  cmf_core::DiffusiveMacroMicroExchange::__init__
"def __init__(self, args, kwargs)

__init__(cmf::upslope::connections::DiffusiveMacroMicroExchange self,
cmf::upslope::MacroPore::ptr left, cmf::upslope::SoilLayer::ptr right,
real omega, real pFrmi=4.2) -> DiffusiveMacroMicroExchange
DiffusiveMacroMicroExchange(cmf::upslope::MacroPore::ptr left,
cmf::upslope::SoilLayer::ptr right, real omega, real pFrmi=4.2) ";

%feature("docstring")
cmf_core::DiffusiveMacroMicroExchange::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::DiffusiveMacroMicroExchange::__eq__ "def __eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")
cmf_core::DiffusiveMacroMicroExchange::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::DiffusiveMacroMicroExchange::__iter__
"def __iter__(self) ";

%feature("docstring")  cmf_core::DiffusiveMacroMicroExchange::__repr__
"def __repr__(self) ";

%feature("docstring")  cmf_core::DiffusiveMacroMicroExchange::conc "def conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::DiffusiveMacroMicroExchange::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf_core::DiffusiveMacroMicroExchange::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::DiffusiveMacroMicroExchange::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::DiffusiveMacroMicroExchange::kill_me
"def kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")
cmf_core::DiffusiveMacroMicroExchange::left_node "def left_node(self,
args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::DiffusiveMacroMicroExchange::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::DiffusiveMacroMicroExchange::refresh
"def refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")
cmf_core::DiffusiveMacroMicroExchange::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::DiffusiveMacroMicroExchange::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf_core::DiffusiveMacroMicroExchange::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")
cmf_core::DiffusiveMacroMicroExchange::to_string "def to_string(self,
args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1connections_1_1_diffusive_surface_runoff.xml
%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff "

A connection to route water from a SurfaceWater storage to another
node following the gradient of the water level.



.. math::

    q_{runoff} = A_{cross} d_{eff}^{2/3}
    \\\\frac{\\\\sqrt{S}}{n}

where:  :math:`q_{runoff}` is the surface
runoff

:math:`A_{cross}` is the wetted crossectional flux area, given as :math:`d_{eff} \\\\cdot w`

:math:`w` is the width of the shared boundary between the surface water
storage and the target node

:math:`d_{eff}` is the effective flow depth of the surface water.The
effective flow depth is defined as either the mean of the effective
depth of the left and the right node (when use_depthmax=false) or the
maximum of the efficitve depth. The effective depth for a surfacewater
is always defined as: 

.. math::

    d_{eff} = \\\\begin{cases}
    V/A-d_{puddle}\\\\ & V/A>d_{puddle} \\\\\\\\ 0.0 & V/A<=d_{puddle}
    \\\\end{cases}

The right node might be not a surfacewater. If the
right node is an OpenWaterStorage, then the effective depth is the
depth of the OWS above the cell height of the left surfacewater, given
by: 

.. math::

    d_{eff,ows} = \\\\Psi_{ows} - z_{cell}

In case of
another node, the right node depth equals the effective depth of the
left node.

:math:`V` the volume of stored water in the surface in :math:`m^3`

:math:`A` the area of the cell in :math:`m^2`

:math:`d_{puddle}=V_{puddle}/A` the average depth of water in the surface
water needed to start run off

:math:`S = \\\\|\\\\frac{\\\\Delta h\\\\|}{d}` the slope between
surfacewater center potential and the target node potential

:math:`n` the manning roughness

The DiffusiveSurfaceRunoff can be used as a cell connecting flux as
in: This results in a connection of the surfacewater storage of each
cell with the surface water storages of its neighborssee

C++ includes: surfacewater.h ";

%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff::DiffusiveSurfaceRunoff
"DiffusiveSurfaceRunoff(cmf::upslope::SurfaceWater::ptr left,
cmf::water::flux_node::ptr right, real flowwidth, real distance=-1) ";

%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff::exchange_target "void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff::get_ptr "ptr
get_ptr() const ";

%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff::get_tracer_filter "real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff::get_tracer_filter "real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff::set_tracer_filter "void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff::set_tracer_filter "void set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff::short_string "virtual std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::DiffusiveSurfaceRunoff::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_diffusive_surface_runoff.xml
%feature("docstring") cmf_core::DiffusiveSurfaceRunoff "

A connection to route water from a SurfaceWater storage to another
node following the gradient of the water level.    .. math::
q_{runoff} = A_{cross} d_{eff}^{2/3} \\\\\\\\frac{\\\\\\\\sqrt{S}}{n}
where:  :math:`q_{runoff}` is the surface runoff  :math:`A_{cross}` is
the wetted crossectional flux area, given as :math:`d_{eff}
\\\\\\\\cdot w`  :math:`w` is the width of the shared boundary between
the surface water storage and the target node  :math:`d_{eff}` is the
effective flow depth of the surface water.The effective flow depth is
defined as either the mean of the effective depth of the left and the
right node (when use_depthmax=false) or the maximum of the efficitve
depth. The effective depth for a surfacewater is always defined as:
.. math:: d_{eff} = \\\\\\\\begin{cases}     V/A-d_{puddle}\\\\\\\\ &
V/A>d_{puddle} \\\\\\\\\\\\\\\\ 0.0 & V/A<=d_{puddle}
\\\\\\\\end{cases}  The right node might be not a surfacewater. If the
right node is an OpenWaterStorage, then the effective depth is the
depth of the OWS above the cell height of the left surfacewater, given
by:   .. math::      d_{eff,ows} = \\\\\\\\Psi_{ows} - z_{cell}  In
case of another node, the right node depth equals the effective depth
of the left node.  :math:`V` the volume of stored water in the surface
in :math:`m^3`  :math:`A` the area of the cell in :math:`m^2`
:math:`d_{puddle}=V_{puddle}/A` the average depth of water in the
surface water needed to start run off  :math:`S =
\\\\\\\\|\\\\\\\\frac{\\\\\\\\Delta h\\\\\\\\|}{d}` the slope between
surfacewater center potential and the target node potential  :math:`n`
the manning roughness  The DiffusiveSurfaceRunoff can be used as a
cell connecting flux as in: This results in a connection of the
surfacewater storage of each cell with the surface water storages of
its neighborssee  C++ includes: surfacewater.h ";

%feature("docstring")  cmf_core::DiffusiveSurfaceRunoff::__init__ "def __init__(self, args, kwargs)

__init__(cmf::upslope::connections::DiffusiveSurfaceRunoff self,
cmf::upslope::SurfaceWater::ptr left, cmf::water::flux_node::ptr
right, real flowwidth, real distance=-1) -> DiffusiveSurfaceRunoff
DiffusiveSurfaceRunoff(cmf::upslope::SurfaceWater::ptr left,
cmf::water::flux_node::ptr right, real flowwidth, real distance=-1) ";

%feature("docstring")  cmf_core::DiffusiveSurfaceRunoff::__contains__
"def __contains__(self, cmp) ";

%feature("docstring")  cmf_core::DiffusiveSurfaceRunoff::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::DiffusiveSurfaceRunoff::__getitem__ "def __getitem__(self, index) ";

%feature("docstring")  cmf_core::DiffusiveSurfaceRunoff::__iter__ "def __iter__(self) ";

%feature("docstring")  cmf_core::DiffusiveSurfaceRunoff::__repr__ "def __repr__(self) ";

%feature("docstring")  cmf_core::DiffusiveSurfaceRunoff::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::DiffusiveSurfaceRunoff::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf_core::DiffusiveSurfaceRunoff::get_linear_slope "def
get_linear_slope(args, kwargs)

get_linear_slope() -> real ";

%feature("docstring")  cmf_core::DiffusiveSurfaceRunoff::get_target "def get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::DiffusiveSurfaceRunoff::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::DiffusiveSurfaceRunoff::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::DiffusiveSurfaceRunoff::left_node "def left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::DiffusiveSurfaceRunoff::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::DiffusiveSurfaceRunoff::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::DiffusiveSurfaceRunoff::right_node "def right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::DiffusiveSurfaceRunoff::set_linear_slope "def
set_linear_slope(args, kwargs)

set_linear_slope(real width) ";

%feature("docstring")
cmf_core::DiffusiveSurfaceRunoff::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::DiffusiveSurfaceRunoff::short_string
"def short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::DiffusiveSurfaceRunoff::to_string "def to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf__core_1_1_dirichlet_boundary.xml
%feature("docstring") cmf_core::DirichletBoundary "

Dirichlet (constant head) boundary condition.  This boundary condition
can be used either as a pure sink boundary condition or as a
conditional source / sink boundary condition. The constant head of the
boundary condition is interpreted and handled by the connections of
the boundary condition. Not head aware connections, should not be
used, since they are ignoring the constant head.  C++ includes:
boundary_condition.h ";

%feature("docstring")  cmf_core::DirichletBoundary::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::water::DirichletBoundary self, project _p, real
potential, point Location) -> DirichletBoundary
DirichletBoundary(cmf::project &_p, real potential,
cmf::geometry::point Location=cmf::geometry::point()) ";

%feature("docstring")  cmf_core::DirichletBoundary::__call__ "def
__call__(self, args, kwargs)

__call__(flux_node self, Time t) -> real ";

%feature("docstring")  cmf_core::DirichletBoundary::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_node self, flux_node other) -> bool ";

%feature("docstring")  cmf_core::DirichletBoundary::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::DirichletBoundary::conc "def
conc(self, args, kwargs)

conc(flux_node self, Time t, solute Solute) -> real  virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const
Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf_core::DirichletBoundary::connected_nodes "def connected_nodes(self) ";

%feature("docstring")  cmf_core::DirichletBoundary::connection_to "def connection_to(self, args, kwargs)

connection_to(flux_node self, flux_node target) -> flux_connection
cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)  Returns the connection between this and target. ";

%feature("docstring")  cmf_core::DirichletBoundary::flux3d_to "def
flux3d_to(self, args, kwargs)

flux3d_to(flux_node self, flux_node target, Time t) -> point
cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf_core::DirichletBoundary::flux_to "def
flux_to(self, args, kwargs)

flux_to(flux_node self, flux_node target, Time t) -> real  real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)
Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf_core::DirichletBoundary::fluxes "def
fluxes(self, t) ";

%feature("docstring")  cmf_core::DirichletBoundary::get_3d_flux "def
get_3d_flux(self, args, kwargs)

get_3d_flux(flux_node self, Time t) -> point  cmf::geometry::point
get_3d_flux(cmf::math::Time t)  Returns the sum of all flux vectors.
";

%feature("docstring")  cmf_core::DirichletBoundary::is_empty "def
is_empty(self, args, kwargs)

is_empty(flux_node self) -> double  virtual double is_empty() const
Returns true if the node has no water. ";

%feature("docstring")  cmf_core::DirichletBoundary::is_storage "def
is_storage(self, args, kwargs)

is_storage(flux_node self) -> bool  virtual bool is_storage() const
true, if this is a waterstorage ";

%feature("docstring")  cmf_core::DirichletBoundary::RecalcFluxes "def
RecalcFluxes(self, args, kwargs)

RecalcFluxes(DirichletBoundary self, Time t) -> bool  virtual bool
RecalcFluxes(cmf::math::Time t)  Pure flux_nodes do not influence
fluxes, therefore no recalculation of fluxes is required by flux_node.
WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf_core::DirichletBoundary::remove_connection
"def remove_connection(self, args, kwargs)

remove_connection(flux_node self, cmf::water::flux_node::ptr To) ->
bool  bool remove_connection(cmf::water::flux_node::ptr To)  Remove
the connection. ";

%feature("docstring")  cmf_core::DirichletBoundary::set_conc "def
set_conc(self, args, kwargs)

set_conc(DirichletBoundary self, solute _Solute, double value) virtual
void set_conc(const cmf::water::solute &_Solute, double value) ";

%feature("docstring")  cmf_core::DirichletBoundary::to_string "def
to_string(self, args, kwargs)

to_string(flux_node self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::DirichletBoundary::waterbalance "def
waterbalance(self, args, kwargs)

waterbalance(flux_node self, Time t, flux_connection Without=None) ->
real  real waterbalance(cmf::math::Time t, const flux_connection
*Without=0) const  Returns the sum of all fluxes (positive and
negative) at time t.  Single fluxes can be excluded from the
calculation  Parameters: -----------  t:  Time of the query  Without:
A flux_connection that is excluded from the waterbalance (e.g. to
prevent closed circuits) ";


// File: classcmf_1_1water_1_1_dirichlet_boundary.xml
%feature("docstring") cmf::water::DirichletBoundary "

Dirichlet (constant head) boundary condition.

This boundary condition can be used either as a pure sink boundary
condition or as a conditional source / sink boundary condition. The
constant head of the boundary condition is interpreted and handled by
the connections of the boundary condition. Not head aware connections,
should not be used, since they are ignoring the constant head.

C++ includes: boundary_condition.h ";

%feature("docstring")
cmf::water::DirichletBoundary::DirichletBoundary "DirichletBoundary(cmf::project &_p, real potential,
cmf::geometry::point Location=cmf::geometry::point()) ";

%feature("docstring")  cmf::water::DirichletBoundary::conc "virtual
real conc(cmf::math::Time t, const cmf::water::solute &_Solute) const

Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf::water::DirichletBoundary::connection_to "cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::water::DirichletBoundary::flux3d_to "cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf::water::DirichletBoundary::flux_to "real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf::water::DirichletBoundary::get_3d_flux "cmf::geometry::point get_3d_flux(cmf::math::Time t)

Returns the sum of all flux vectors. ";

%feature("docstring")  cmf::water::DirichletBoundary::get_connections
"cmf::water::connection_list get_connections() const ";

%feature("docstring")  cmf::water::DirichletBoundary::get_potential "real get_potential() const

Returns the water potential of the node in m waterhead.

The base class water storage always returns the height of the location
";

%feature("docstring")  cmf::water::DirichletBoundary::get_project "cmf::project& get_project() const

Returns the project, this node is part of. ";

%feature("docstring")  cmf::water::DirichletBoundary::is_empty "double is_empty() const

Returns true if the node has no water. ";

%feature("docstring")  cmf::water::DirichletBoundary::is_storage "virtual bool is_storage() const

true, if this is a waterstorage ";

%feature("docstring")  cmf::water::DirichletBoundary::RecalcFluxes "bool RecalcFluxes(cmf::math::Time t) const ";

%feature("docstring")  cmf::water::DirichletBoundary::RecalcFluxes "virtual bool RecalcFluxes(cmf::math::Time t)

Pure flux_nodes do not influence fluxes, therefore no recalculation of
fluxes is required by flux_node.

WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")
cmf::water::DirichletBoundary::remove_connection "bool
remove_connection(cmf::water::flux_node::ptr To)

Remove the connection. ";

%feature("docstring")  cmf::water::DirichletBoundary::set_conc "virtual void set_conc(const cmf::water::solute &_Solute, double value)
";

%feature("docstring")  cmf::water::DirichletBoundary::set_potential "void set_potential(real new_potential)

Sets the potential of this flux node. ";

%feature("docstring")  cmf::water::DirichletBoundary::to_string "virtual std::string to_string() const ";

%feature("docstring")  cmf::water::DirichletBoundary::waterbalance "real waterbalance(cmf::math::Time t, const flux_connection *Without=0)
const

Returns the sum of all fluxes (positive and negative) at time t.

Single fluxes can be excluded from the calculation

Parameters:
-----------

t:  Time of the query

Without:  A flux_connection that is excluded from the waterbalance
(e.g. to prevent closed circuits) ";


// File: classcmf__core_1_1_energy_budget_snow_melt.xml
%feature("docstring") cmf_core::EnergyBudgetSnowMelt "

Calculates snow melt using the surface energy budget method.  C++
includes: surfacefluxes.h ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::EnergyBudgetSnowMelt self,
cmf::water::WaterStorage::ptr snow, cmf::water::flux_node::ptr
surface_water, Cell cell) -> EnergyBudgetSnowMelt
EnergyBudgetSnowMelt(cmf::water::WaterStorage::ptr snow,
cmf::water::flux_node::ptr surface_water, cmf::upslope::Cell &cell) ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt::__contains__ "def __contains__(self, cmp) ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt::__getitem__ "def __getitem__(self, index) ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt::exchange_target
"def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt::get_target "def get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::EnergyBudgetSnowMelt::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt::right_node "def right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::EnergyBudgetSnowMelt::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt::short_string "def short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt::use_for_cell "def use_for_cell(args, kwargs)

use_for_cell(Cell cell) ";


// File: classcmf_1_1upslope_1_1connections_1_1_energy_budget_snow_melt.xml
%feature("docstring") cmf::upslope::connections::EnergyBudgetSnowMelt
"

Calculates snow melt using the surface energy budget method.

C++ includes: surfacefluxes.h ";

%feature("docstring")
cmf::upslope::connections::EnergyBudgetSnowMelt::EnergyBudgetSnowMelt
"EnergyBudgetSnowMelt(cmf::water::WaterStorage::ptr snow,
cmf::water::flux_node::ptr surface_water, cmf::upslope::Cell &cell) ";

%feature("docstring")
cmf::upslope::connections::EnergyBudgetSnowMelt::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::EnergyBudgetSnowMelt::exchange_target "void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")
cmf::upslope::connections::EnergyBudgetSnowMelt::get_ptr "ptr
get_ptr() const ";

%feature("docstring")
cmf::upslope::connections::EnergyBudgetSnowMelt::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::EnergyBudgetSnowMelt::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::EnergyBudgetSnowMelt::get_tracer_filter "real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::EnergyBudgetSnowMelt::get_tracer_filter "real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::EnergyBudgetSnowMelt::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::EnergyBudgetSnowMelt::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")
cmf::upslope::connections::EnergyBudgetSnowMelt::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::EnergyBudgetSnowMelt::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::EnergyBudgetSnowMelt::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::EnergyBudgetSnowMelt::set_tracer_filter "void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::EnergyBudgetSnowMelt::set_tracer_filter "void set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::EnergyBudgetSnowMelt::short_string "virtual std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::EnergyBudgetSnowMelt::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_explicit_euler__fixed.xml
%feature("docstring") cmf_core::ExplicitEuler_fixed "

An explicit Euler integrator, with a fixed time step.  C++ includes:
explicit_euler.h ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::__init__ "def
__init__(self, args)

__init__(cmf::math::ExplicitEuler_fixed self, StateVariableOwner
states) -> ExplicitEuler_fixed __init__(cmf::math::ExplicitEuler_fixed
self) -> ExplicitEuler_fixed __init__(cmf::math::ExplicitEuler_fixed
self, Integrator copy) -> ExplicitEuler_fixed
ExplicitEuler_fixed(const Integrator &copy)  copy constructor ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::__call__ "def
__call__(self, t, dt=None, reset=False)

Advances the integration until `t`  A shortcut to .integrate_until
Parameters ---------- t : cmf.Time     The time step to advance to. If
t < current time, the solver will     advance to self.t + t dt :
cmf.Time, optional     The timestep for the integration. If not given
try to integrate in one step reset : bool, optional     If True, the
solver will perform a reset before starting  Returns ------- cmf.Time
The new time stamp ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::__getitem__ "def __getitem__(self, args, kwargs)

__getitem__(Integrator self, long position) ->
cmf::math::StateVariable::ptr ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::__len__ "def
__len__(self, args, kwargs)

__len__(Integrator self) -> size_t ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::add_single_state
"def add_single_state(self, args, kwargs)

add_single_state(Integrator self, cmf::math::StateVariable::ptr state)
virtual void add_single_state(cmf::math::StateVariable::ptr state)
Adds a single state variable to the integrator. ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::add_states "def
add_states(self, args, kwargs)

add_states(Integrator self, StateVariableOwner stateOwner)  virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)  Add state
variables from a StateVariableOwner. ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::copy "def
copy(self, args, kwargs)

copy(Integrator self) -> Integrator  virtual Integrator* copy() const
=0  Polymorphic copy constructor. ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::get_dt "def
get_dt(self, args, kwargs)

get_dt(Integrator self) -> Time  cmf::math::Time get_dt() const
Returns the last time step. ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::get_dxdt "def
get_dxdt(self, args, kwargs)

get_dxdt(Integrator self, Time time) -> cmf::math::num_array
cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::get_state "def
get_state(self, args, kwargs)

get_state(Integrator self, ptrdiff_t position) -> real  real
get_state(ptrdiff_t position) const  Returns the statevariable at
position Simplifies the assessment of state variables. ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::get_states "def
get_states(self, args)

get_states(Integrator self) -> cmf::math::num_array
get_states(Integrator self) -> StateVariableList  StateVariableList
get_states()  gets the state variables of the integrator ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::get_t "def
get_t(self, args, kwargs)

get_t(Integrator self) -> Time  cmf::math::Time get_t() const  Returns
the current model time. ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::integrate "def
integrate(self, args, kwargs)

integrate(Integrator self, Time t_max, Time dt) -> int  virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)=0  Integrates the
vector of state variables.  Parameters: -----------  t_max:  To stop
the model (if running in a model framework) at time steps of value
exchange e.g. full hours, the next value exchange time can be given
dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::integrate_until
"def integrate_until(self, args, kwargs)

integrate_until(Integrator self, Time t_max, Time dt, bool
reset=False)  void integrate_until(cmf::math::Time t_max,
cmf::math::Time dt=Time(), bool reset=false)  Integrates the vector of
state variables until t_max.  Parameters: -----------  t_max:   Time,
the solver should run to  dt:   Time step (may be omitted)  reset:  If
true, solver is reseted before integration starts ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::reset "def
reset(self, args, kwargs)

reset(Integrator self)  virtual void reset()  Resets any saved history
(for multistep methods) ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::run "def
run(self, start=None, end=None, step=day *1, max_errors=0,
reset=False)

Returns an iterator over the timesteps start..end  **Examples:**  >>>
solver=cmf.CVodeIntegrator(...) >>> for t in solver.run(solver.t,
solver.t + cmf.week, cmf.h): >>>    print(t, solver[0].state) or with
list comprehension >>> states = [solver[0].state for t in
solver.run(solver.t, solver.t + cmf.week, cmf.h)]  Parameters
---------- start : cmf.Time, optional Start time for the solver
iteration end : cmf.Time, optional End time of the iteration step :
cmf.Time, optional Step size for the integration max_errors: int
Number of tolerated errors. If >0, up to these number of runtime
errors will be saved with their time and the integration proceeds
after a reset of the solver. Some systems operate with values close to
their physical limits and inifinite values in the integration can
easily occur. For these kind of systems set max_errors to eg. 10. A
larger number of errors should be eliminated usually. reset: bool If
True, the solver performs a `reset` at every time step  Yields ------
cmf.Time      the actual timestep ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::set_state "def
set_state(self, args, kwargs)

set_state(Integrator self, ptrdiff_t position, real newState)  void
set_state(ptrdiff_t position, real newState)  Simplifies the
assessment of state variables. ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::set_t "def
set_t(self, args, kwargs)

set_t(Integrator self, Time val)  void set_t(cmf::math::Time val) Sets
the current model time. ";

%feature("docstring")  cmf_core::ExplicitEuler_fixed::size "def
size(self, args, kwargs)

size(Integrator self) -> size_t  size_t size() const  returns the
number of state variables ";


// File: classcmf_1_1math_1_1_explicit_euler__fixed.xml
%feature("docstring") cmf::math::ExplicitEuler_fixed "

An explicit Euler integrator, with a fixed time step.

C++ includes: explicit_euler.h ";

/*  Accuracy parameters  */

/*  model time  */

%feature("docstring")  cmf::math::ExplicitEuler_fixed::get_t "cmf::math::Time get_t() const

Returns the current model time. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::set_t "void
set_t(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::get_dt "cmf::math::Time get_dt() const

Returns the last time step. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::reset "virtual
void reset()

Resets any saved history (for multistep methods) ";

/*  Integrate  */

%feature("docstring")  cmf::math::ExplicitEuler_fixed::integrate_until
"void integrate_until(cmf::math::Time t_max, cmf::math::Time
dt=Time(), bool reset=false)

Integrates the vector of state variables until t_max.

Parameters:
-----------

t_max:   Time, the solver should run to

dt:   Time step (may be omitted)

reset:  If true, solver is reseted before integration starts ";

%feature("docstring")
cmf::math::ExplicitEuler_fixed::ExplicitEuler_fixed "ExplicitEuler_fixed(StateVariableOwner &states)

Constructs a new ExplicitEuler_fixed from a pointer to a vector of
state variables.

The Integrator becomes the owner of states

Parameters:
-----------

states:  Statevariables of the system ";

%feature("docstring")
cmf::math::ExplicitEuler_fixed::ExplicitEuler_fixed "ExplicitEuler_fixed()

Constructs a new ExplicitEuler_fixed. ";

%feature("docstring")
cmf::math::ExplicitEuler_fixed::ExplicitEuler_fixed "ExplicitEuler_fixed(const Integrator &copy)

copy constructor ";

%feature("docstring")
cmf::math::ExplicitEuler_fixed::~ExplicitEuler_fixed "virtual
~ExplicitEuler_fixed() ";

%feature("docstring")
cmf::math::ExplicitEuler_fixed::add_single_state "virtual void
add_single_state(cmf::math::StateVariable::ptr state)

Adds a single state variable to the integrator. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::add_states "void add_states(cmf::math::StateVariableOwner &stateOwner)

Add state variables from a StateVariableOwner. ";

%feature("docstring")
cmf::math::ExplicitEuler_fixed::add_values_to_states "void
add_values_to_states(const num_array &operands)

Adds the values in operands to the current states. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::copy "virtual
Integrator* copy() const

Polymorphic copy constructor. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::copy_dxdt "void copy_dxdt(Time time, num_array &destination, real factor=1) const

Copies the derivatives at time step \"time\" to a numeric vector using
use_OpenMP.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Vector to be overwritten by the results

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::copy_dxdt "void copy_dxdt(Time time, real *destination, real factor=1) const

Copies the derivatives at time step \"time\" to an preallocated c
array.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Allocated c array

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::copy_states "void copy_states(num_array &destination) const

Copies the states to a numeric vector using use_OpenMP. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::copy_states "void copy_states(real *destination) const ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::get_dxdt "cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::get_state "real get_state(ptrdiff_t position) const

Returns the statevariable at position Simplifies the assessment of
state variables. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::get_states "cmf::math::num_array get_states() const ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::get_states "StateVariableList get_states()

gets the state variables of the integrator ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::integrate "int
integrate(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

Integrates the vector of state variables.

Parameters:
-----------

MaxTime:  (ignored) To stop the model (if running in a model
framework) at time steps of value exchange e.g. full hours, the next
value exchange time can be given

TimeStep:  Takes the proposed time step ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::set_state "void set_state(ptrdiff_t position, real newState)

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::set_states "void set_states(const num_array &newStates)

Copies the new states to the actual states. ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::set_states "void set_states(real *newStates) ";

%feature("docstring")  cmf::math::ExplicitEuler_fixed::size "size_t
size() const

returns the number of state variables ";


// File: classcmf__core_1_1_exponential_decline_connection.xml
%feature("docstring") cmf_core::ExponentialDeclineConnection "

A conceptual TOPmodel inspired connection.    .. math::       q = Q_0
\\\\\\\\cdot e^{(V-V_0)/m}   C++ includes: simple_connections.h ";

%feature("docstring")
cmf_core::ExponentialDeclineConnection::__init__ "def __init__(self,
args, kwargs)

__init__(cmf::water::ExponentialDeclineConnection self,
cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr
target, real Q0, real V0, real m) -> ExponentialDeclineConnection
ExponentialDeclineConnection(WaterStorage::ptr source, flux_node::ptr
target, real Q0, real V0, real m)  creates the exponential decline
connection ";

%feature("docstring")
cmf_core::ExponentialDeclineConnection::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::ExponentialDeclineConnection::__eq__
"def __eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")
cmf_core::ExponentialDeclineConnection::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")
cmf_core::ExponentialDeclineConnection::__iter__ "def __iter__(self)
";

%feature("docstring")
cmf_core::ExponentialDeclineConnection::__repr__ "def __repr__(self)
";

%feature("docstring")  cmf_core::ExponentialDeclineConnection::conc "def conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::ExponentialDeclineConnection::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf_core::ExponentialDeclineConnection::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::ExponentialDeclineConnection::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::ExponentialDeclineConnection::kill_me
"def kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")
cmf_core::ExponentialDeclineConnection::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::ExponentialDeclineConnection::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::ExponentialDeclineConnection::refresh
"def refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")
cmf_core::ExponentialDeclineConnection::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::ExponentialDeclineConnection::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf_core::ExponentialDeclineConnection::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")
cmf_core::ExponentialDeclineConnection::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1water_1_1_exponential_decline_connection.xml
%feature("docstring") cmf::water::ExponentialDeclineConnection "

A conceptual TOPmodel inspired connection.



.. math::

     q = Q_0 \\\\cdot e^{(V-V_0)/m} 

C++ includes: simple_connections.h ";

%feature("docstring")
cmf::water::ExponentialDeclineConnection::ExponentialDeclineConnection
"ExponentialDeclineConnection(WaterStorage::ptr source,
flux_node::ptr target, real Q0, real V0, real m)

creates the exponential decline connection ";

%feature("docstring")  cmf::water::ExponentialDeclineConnection::conc
"real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::water::ExponentialDeclineConnection::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::water::ExponentialDeclineConnection::get_ptr "ptr get_ptr()
const ";

%feature("docstring")
cmf::water::ExponentialDeclineConnection::get_target "flux_node::ptr
get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::water::ExponentialDeclineConnection::get_target "flux_node::ptr
get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::water::ExponentialDeclineConnection::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::ExponentialDeclineConnection::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::water::ExponentialDeclineConnection::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::water::ExponentialDeclineConnection::left_node "flux_node::ptr
left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::water::ExponentialDeclineConnection::q "real q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::water::ExponentialDeclineConnection::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::water::ExponentialDeclineConnection::right_node "flux_node::ptr
right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::water::ExponentialDeclineConnection::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::ExponentialDeclineConnection::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::water::ExponentialDeclineConnection::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::water::ExponentialDeclineConnection::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1external__control__connection.xml
%feature("docstring") cmf_core::external_control_connection "

Flux from one node to another, controlled by the user or an external
program, by changing the flux constant.  It is easy to create negative
volumes in water storages with this connection, which can be hazard to
the solver, since most connections rely on a positive volume in a
storage. Handle with care!  C++ includes: simple_connections.h ";

%feature("docstring")  cmf_core::external_control_connection::__init__
"def __init__(self, args, kwargs)

__init__(cmf::water::external_control_connection self,
cmf::water::flux_node::ptr source, cmf::water::flux_node::ptr target,
real flux_value=0) -> external_control_connection
external_control_connection(flux_node::ptr source, flux_node::ptr
target, real flux_value=0) ";

%feature("docstring")
cmf_core::external_control_connection::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::external_control_connection::__eq__ "def __eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")
cmf_core::external_control_connection::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::external_control_connection::__iter__
"def __iter__(self) ";

%feature("docstring")  cmf_core::external_control_connection::__repr__
"def __repr__(self) ";

%feature("docstring")  cmf_core::external_control_connection::conc "def conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::external_control_connection::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf_core::external_control_connection::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::external_control_connection::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::external_control_connection::kill_me
"def kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")
cmf_core::external_control_connection::left_node "def left_node(self,
args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::external_control_connection::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::external_control_connection::refresh
"def refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")
cmf_core::external_control_connection::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::external_control_connection::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf_core::external_control_connection::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")
cmf_core::external_control_connection::to_string "def to_string(self,
args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1water_1_1external__control__connection.xml
%feature("docstring") cmf::water::external_control_connection "

Flux from one node to another, controlled by the user or an external
program, by changing the flux constant.

It is easy to create negative volumes in water storages with this
connection, which can be hazard to the solver, since most connections
rely on a positive volume in a storage. Handle with care!

C++ includes: simple_connections.h ";

%feature("docstring")
cmf::water::external_control_connection::external_control_connection "external_control_connection(flux_node::ptr source, flux_node::ptr
target, real flux_value=0) ";

%feature("docstring")  cmf::water::external_control_connection::conc "real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::water::external_control_connection::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::water::external_control_connection::get_ptr "ptr get_ptr() const
";

%feature("docstring")
cmf::water::external_control_connection::get_target "flux_node::ptr
get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::water::external_control_connection::get_target "flux_node::ptr
get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::water::external_control_connection::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::external_control_connection::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::water::external_control_connection::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::water::external_control_connection::left_node "flux_node::ptr
left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::water::external_control_connection::q "real q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::water::external_control_connection::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::water::external_control_connection::right_node "flux_node::ptr
right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::water::external_control_connection::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::external_control_connection::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::water::external_control_connection::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::water::external_control_connection::to_string "virtual
std::string to_string() const ";


// File: classcmf_1_1fit__retention__curve_1_1_fit_brooks_corey.xml
%feature("docstring") cmf::fit_retention_curve::FitBrooksCorey "";

%feature("docstring")
cmf::fit_retention_curve::FitBrooksCorey::__init__ "def
__init__(self, theta, pF, verbose=False) ";

%feature("docstring")
cmf::fit_retention_curve::FitBrooksCorey::__call__ "def
__call__(self, count=1) ";

%feature("docstring")
cmf::fit_retention_curve::FitBrooksCorey::create_rc "def
create_rc(self, params) ";

%feature("docstring")
cmf::fit_retention_curve::FitBrooksCorey::get_error "def
get_error(self, params) ";


// File: classcmf_1_1fit__retention__curve_1_1_fit_retention_curve.xml
%feature("docstring") cmf::fit_retention_curve::FitRetentionCurve "";

%feature("docstring")
cmf::fit_retention_curve::FitRetentionCurve::__init__ "def
__init__(self, rc_class, theta, pF, verbose=False) ";

%feature("docstring")
cmf::fit_retention_curve::FitRetentionCurve::__call__ "def
__call__(self, count=1) ";

%feature("docstring")
cmf::fit_retention_curve::FitRetentionCurve::create_rc "def
create_rc(self, params) ";

%feature("docstring")
cmf::fit_retention_curve::FitRetentionCurve::get_error "def
get_error(self, params) ";


// File: classcmf_1_1fit__retention__curve_1_1_fit_van_genuchten_mualem.xml
%feature("docstring") cmf::fit_retention_curve::FitVanGenuchtenMualem
"";

%feature("docstring")
cmf::fit_retention_curve::FitVanGenuchtenMualem::__init__ "def
__init__(self, theta, pF, fit_theta_r=False, fit_m=False,
verbose=False) ";

%feature("docstring")
cmf::fit_retention_curve::FitVanGenuchtenMualem::__call__ "def
__call__(self, count=1) ";

%feature("docstring")
cmf::fit_retention_curve::FitVanGenuchtenMualem::create_rc "def
create_rc(self, params) ";

%feature("docstring")
cmf::fit_retention_curve::FitVanGenuchtenMualem::get_error "def
get_error(self, params) ";


// File: classcmf__core_1_1flux__connection.xml
%feature("docstring") cmf_core::flux_connection "

The connections in cmf hold the processes for the calculation of
fluxes between water storages and model boundaries.  Todo Elaborate on
this Represents a connection between flux_nodes, where water fluxes
occur.  C++ includes: flux_connection.h ";

%feature("docstring")  cmf_core::flux_connection::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::flux_connection::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::flux_connection::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::flux_connection::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::flux_connection::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::flux_connection::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::flux_connection::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::flux_connection::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::flux_connection::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::flux_connection::get_tracer_filter "def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::flux_connection::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::flux_connection::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::flux_connection::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::flux_connection::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::flux_connection::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::flux_connection::set_tracer_filter "def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::flux_connection::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::flux_connection::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1water_1_1flux__connection.xml
%feature("docstring") cmf::water::flux_connection "

The connections in cmf hold the processes for the calculation of
fluxes between water storages and model boundaries.

Todo Elaborate on this Represents a connection between flux_nodes,
where water fluxes occur.

C++ includes: flux_connection.h ";

%feature("docstring")  cmf::water::flux_connection::flux_connection "flux_connection(flux_node::ptr left, flux_node::ptr right, std::string
_type)

Creates a flux connection between the flux_node left and right.

Parameters:
-----------

left:   flux_node on the one side of the connection

right:   flux_node on the other side of the connection

_type:  Type of the flux connection ";

%feature("docstring")  cmf::water::flux_connection::~flux_connection "virtual ~flux_connection() ";

%feature("docstring")  cmf::water::flux_connection::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")  cmf::water::flux_connection::exchange_target "void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")  cmf::water::flux_connection::get_ptr "ptr
get_ptr() const ";

%feature("docstring")  cmf::water::flux_connection::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::water::flux_connection::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")  cmf::water::flux_connection::get_tracer_filter
"real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")  cmf::water::flux_connection::get_tracer_filter
"real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::water::flux_connection::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::water::flux_connection::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::water::flux_connection::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::water::flux_connection::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::water::flux_connection::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")  cmf::water::flux_connection::set_tracer_filter
"void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")  cmf::water::flux_connection::set_tracer_filter
"void set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf::water::flux_connection::short_string "virtual std::string short_string() const ";

%feature("docstring")  cmf::water::flux_connection::to_string "virtual std::string to_string() const ";


// File: classcmf__core_1_1flux__integrator.xml
%feature("docstring") cmf_core::flux_integrator "

The flux_integrator is an integratable for precise output of average
fluxes over time.  It can be added to solver (any
cmf::math::Integrator), which is then calling the integrate method at
each substep.  C++ includes: flux_connection.h ";

%feature("docstring")  cmf_core::flux_integrator::__init__ "def
__init__(self, args)

__init__(cmf::water::flux_integrator self, flux_connection connection)
-> flux_integrator __init__(cmf::water::flux_integrator self,
cmf::water::flux_node::ptr left, cmf::water::flux_node::ptr right) ->
flux_integrator  flux_integrator(cmf::water::flux_node::ptr left,
cmf::water::flux_node::ptr right)  Creates a flux_integrator from the
endpoints of a connection. Throws if there is no connection between
the endpoints. ";

%feature("docstring")  cmf_core::flux_integrator::avg "def avg(self,
args, kwargs)

avg(integratable self) -> double  virtual double avg() const =0
Returns average of the integrated variable (eg. flux) from the last
reset until the last call of integrate. ";

%feature("docstring")  cmf_core::flux_integrator::connection "def
connection(self, args, kwargs)

connection(flux_integrator self) -> cmf::water::flux_connection::ptr
flux_connection::ptr connection() const  Returns the flux_connection.
";

%feature("docstring")  cmf_core::flux_integrator::integrate "def
integrate(self, args, kwargs)

integrate(integratable self, Time t)  virtual void integrate(Time t)=0
Integrates the variable until time t. ";

%feature("docstring")  cmf_core::flux_integrator::integration_t "def
integration_t(self, args, kwargs)

integration_t(flux_integrator self) -> Time  cmf::math::Time
integration_t() const  Returns the duration of the integration. ";

%feature("docstring")  cmf_core::flux_integrator::reset "def
reset(self, args, kwargs)

reset(integratable self, Time t)  virtual void reset(Time t)=0  Sets
the start time of the integral. ";

%feature("docstring")  cmf_core::flux_integrator::sum "def sum(self,
args, kwargs)

sum(integratable self) -> double  virtual double sum() const =0  Get
the integral from the last reset until the last call of integrate. ";

%feature("docstring")  cmf_core::flux_integrator::t0 "def t0(self,
args, kwargs)

t0(flux_integrator self) -> Time  cmf::math::Time t0() const  Returns
the start time of the integration. ";


// File: classcmf_1_1water_1_1flux__integrator.xml
%feature("docstring") cmf::water::flux_integrator "

The flux_integrator is an integratable for precise output of average
fluxes over time.

It can be added to solver (any cmf::math::Integrator), which is then
calling the integrate method at each substep.

C++ includes: flux_connection.h ";

%feature("docstring")  cmf::water::flux_integrator::flux_integrator "flux_integrator(cmf::water::flux_connection &connection)

Creates a flux_integrator from an connection. ";

%feature("docstring")  cmf::water::flux_integrator::flux_integrator "flux_integrator(cmf::water::flux_node::ptr left,
cmf::water::flux_node::ptr right)

Creates a flux_integrator from the endpoints of a connection. Throws
if there is no connection between the endpoints. ";

%feature("docstring")  cmf::water::flux_integrator::avg "double avg()
const

Returns the average flux of the integration time in m3/day. ";

%feature("docstring")  cmf::water::flux_integrator::connection "flux_connection::ptr connection() const

Returns the flux_connection. ";

%feature("docstring")  cmf::water::flux_integrator::integrate "void
integrate(cmf::math::Time until)

Integrates the flux a timestep further. Note: until is an absolute
time. If until is before t0, the integration is initilized again. ";

%feature("docstring")  cmf::water::flux_integrator::integration_t "cmf::math::Time integration_t() const

Returns the duration of the integration. ";

%feature("docstring")  cmf::water::flux_integrator::reset "void
reset(cmf::math::Time t)

Initializes the integration. ";

%feature("docstring")  cmf::water::flux_integrator::sum "double sum()
const

Returns the amount of water along this connection in the integration
time in m3. ";

%feature("docstring")  cmf::water::flux_integrator::t0 "cmf::math::Time t0() const

Returns the start time of the integration. ";


// File: classcmf__core_1_1flux__node.xml
%feature("docstring") cmf_core::flux_node "

Base class for everything that can be connected by fluxes.  Flux nodes
can be WaterStorages, flux end points, sinks, sources and bridges to
other model domains (e.g. Ponded water to river system). The base
class can be used where a simple routing, potentially with mixing, is
needed.  C++ includes: flux_node.h ";

%feature("docstring")  cmf_core::flux_node::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::water::flux_node self, project _project, point location)
-> flux_node  flux_node(cmf::project &_project, cmf::geometry::point
location=cmf::geometry::point()) ";

%feature("docstring")  cmf_core::flux_node::__call__ "def
__call__(self, args, kwargs)

__call__(flux_node self, Time t) -> real ";

%feature("docstring")  cmf_core::flux_node::__eq__ "def __eq__(self,
args, kwargs)

__eq__(flux_node self, flux_node other) -> bool ";

%feature("docstring")  cmf_core::flux_node::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::flux_node::conc "def conc(self,
args, kwargs)

conc(flux_node self, Time t, solute Solute) -> real  virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const
Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf_core::flux_node::connected_nodes "def
connected_nodes(self) ";

%feature("docstring")  cmf_core::flux_node::connection_to "def
connection_to(self, args, kwargs)

connection_to(flux_node self, flux_node target) -> flux_connection
cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)  Returns the connection between this and target. ";

%feature("docstring")  cmf_core::flux_node::flux3d_to "def
flux3d_to(self, args, kwargs)

flux3d_to(flux_node self, flux_node target, Time t) -> point
cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf_core::flux_node::flux_to "def
flux_to(self, args, kwargs)

flux_to(flux_node self, flux_node target, Time t) -> real  real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)
Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf_core::flux_node::fluxes "def fluxes(self,
t) ";

%feature("docstring")  cmf_core::flux_node::get_3d_flux "def
get_3d_flux(self, args, kwargs)

get_3d_flux(flux_node self, Time t) -> point  cmf::geometry::point
get_3d_flux(cmf::math::Time t)  Returns the sum of all flux vectors.
";

%feature("docstring")  cmf_core::flux_node::is_empty "def
is_empty(self, args, kwargs)

is_empty(flux_node self) -> double  virtual double is_empty() const
Returns true if the node has no water. ";

%feature("docstring")  cmf_core::flux_node::is_storage "def
is_storage(self, args, kwargs)

is_storage(flux_node self) -> bool  virtual bool is_storage() const
true, if this is a waterstorage ";

%feature("docstring")  cmf_core::flux_node::RecalcFluxes "def
RecalcFluxes(self, args, kwargs)

RecalcFluxes(flux_node self, Time t) -> bool  virtual bool
RecalcFluxes(cmf::math::Time t)  Pure flux_nodes do not influence
fluxes, therefore no recalculation of fluxes is required by flux_node.
WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf_core::flux_node::remove_connection "def
remove_connection(self, args, kwargs)

remove_connection(flux_node self, cmf::water::flux_node::ptr To) ->
bool  bool remove_connection(cmf::water::flux_node::ptr To)  Remove
the connection. ";

%feature("docstring")  cmf_core::flux_node::to_string "def
to_string(self, args, kwargs)

to_string(flux_node self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::flux_node::waterbalance "def
waterbalance(self, args, kwargs)

waterbalance(flux_node self, Time t, flux_connection Without=None) ->
real  real waterbalance(cmf::math::Time t, const flux_connection
*Without=0) const  Returns the sum of all fluxes (positive and
negative) at time t.  Single fluxes can be excluded from the
calculation  Parameters: -----------  t:  Time of the query  Without:
A flux_connection that is excluded from the waterbalance (e.g. to
prevent closed circuits) ";


// File: classcmf_1_1water_1_1flux__node.xml
%feature("docstring") cmf::water::flux_node "

Base class for everything that can be connected by fluxes.

Flux nodes can be WaterStorages, flux end points, sinks, sources and
bridges to other model domains (e.g. Ponded water to river system).
The base class can be used where a simple routing, potentially with
mixing, is needed.

C++ includes: flux_node.h ";

%feature("docstring")  cmf::water::flux_node::flux_node "flux_node(cmf::project &_project, cmf::geometry::point
location=cmf::geometry::point()) ";

%feature("docstring")  cmf::water::flux_node::~flux_node "virtual
~flux_node()

The destructor deletes all connections. ";

%feature("docstring")  cmf::water::flux_node::conc "virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const

Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf::water::flux_node::connection_to "cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::water::flux_node::flux3d_to "cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf::water::flux_node::flux_to "real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf::water::flux_node::get_3d_flux "cmf::geometry::point get_3d_flux(cmf::math::Time t)

Returns the sum of all flux vectors. ";

%feature("docstring")  cmf::water::flux_node::get_connections "cmf::water::connection_list get_connections() const ";

%feature("docstring")  cmf::water::flux_node::get_potential "virtual
real get_potential() const

Returns the water potential of the node in m waterhead.

The base class water storage always returns the height of the location
";

%feature("docstring")  cmf::water::flux_node::get_project "cmf::project& get_project() const

Returns the project, this node is part of. ";

%feature("docstring")  cmf::water::flux_node::is_empty "virtual
double is_empty() const

Returns true if the node has no water. ";

%feature("docstring")  cmf::water::flux_node::is_storage "virtual
bool is_storage() const

true, if this is a waterstorage ";

%feature("docstring")  cmf::water::flux_node::RecalcFluxes "virtual
bool RecalcFluxes(cmf::math::Time t)

Pure flux_nodes do not influence fluxes, therefore no recalculation of
fluxes is required by flux_node.

WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf::water::flux_node::remove_connection "bool
remove_connection(cmf::water::flux_node::ptr To)

Remove the connection. ";

%feature("docstring")  cmf::water::flux_node::set_potential "virtual
void set_potential(real new_potential)

Sets the potential of this flux node. ";

%feature("docstring")  cmf::water::flux_node::to_string "virtual
std::string to_string() const ";

%feature("docstring")  cmf::water::flux_node::waterbalance "real
waterbalance(cmf::math::Time t, const flux_connection *Without=0)
const

Returns the sum of all fluxes (positive and negative) at time t.

Single fluxes can be excluded from the calculation

Parameters:
-----------

t:  Time of the query

Without:  A flux_connection that is excluded from the waterbalance
(e.g. to prevent closed circuits) ";


// File: classcmf_1_1draw_1_1cellmap_1_1_flux_map.xml
%feature("docstring") cmf::draw::cellmap::FluxMap "

Draws for each cell an arrow indicating the direction and velocity of
flow through the cell (in horizontal direction). Uses plt.quiver  The
FluxMap can be updated by calling it with the new timestep  Usage: >>>
import cmf >>> p = cmf.project() >>> solver = cmf.RKFIntegrator(p,
1e-9) >>> fm = FluxMap(p, cmf.Time()) >>> for t in
solver.run(solver.t, solver.t + cmf.day * 30, cmf.h): ...     fm(t) ";

%feature("docstring")  cmf::draw::cellmap::FluxMap::__init__ "def
__init__(self, cells, t, kwargs)

Creates a new flux map :param cells: The cells to be used :param t:
The current time step :param kwargs: Keyword arguments for plt.quiver
";

%feature("docstring")  cmf::draw::cellmap::FluxMap::__call__ "def
__call__(self, t=None) ";


// File: classcmf__core_1_1_free_drainage_percolation.xml
%feature("docstring") cmf_core::FreeDrainagePercolation "

Calculates a free drainage (unit gradient) from a layer to somewhere
else.    .. math::       q = K(\\\\\\\\theta) A  where:  :math:`q`
Flux from the layer to the other side of the connection in
:math:`m^3/day`  :math:`K(\\\\\\\\theta)` Actual conductivity in
:math:`m/day` depending on the water content of the layer
:math:`\\\\\\\\theta`  :math:`A` Cell area in :math:`m^2`  C++
includes: Percolation.h ";

%feature("docstring")  cmf_core::FreeDrainagePercolation::__init__ "def __init__(self, args, kwargs)

__init__(cmf::upslope::connections::FreeDrainagePercolation self,
cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right)
-> FreeDrainagePercolation
FreeDrainagePercolation(cmf::upslope::SoilLayer::ptr left,
cmf::water::flux_node::ptr right) ";

%feature("docstring")  cmf_core::FreeDrainagePercolation::__contains__
"def __contains__(self, cmp) ";

%feature("docstring")  cmf_core::FreeDrainagePercolation::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::FreeDrainagePercolation::__getitem__
"def __getitem__(self, index) ";

%feature("docstring")  cmf_core::FreeDrainagePercolation::__iter__ "def __iter__(self) ";

%feature("docstring")  cmf_core::FreeDrainagePercolation::__repr__ "def __repr__(self) ";

%feature("docstring")  cmf_core::FreeDrainagePercolation::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::FreeDrainagePercolation::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::FreeDrainagePercolation::get_target "def get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::FreeDrainagePercolation::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::FreeDrainagePercolation::kill_me "def kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::FreeDrainagePercolation::left_node "def left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::FreeDrainagePercolation::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::FreeDrainagePercolation::refresh "def refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::FreeDrainagePercolation::right_node "def right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::FreeDrainagePercolation::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::FreeDrainagePercolation::short_string
"def short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::FreeDrainagePercolation::to_string "def to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1connections_1_1_free_drainage_percolation.xml
%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation "

Calculates a free drainage (unit gradient) from a layer to somewhere
else.



.. math::

     q = K(\\\\theta) A

where:  :math:`q` Flux from the layer to the
other side of the connection in :math:`m^3/day`

:math:`K(\\\\theta)` Actual conductivity in :math:`m/day` depending on the water
content of the layer :math:`\\\\theta`

:math:`A` Cell area in :math:`m^2`

C++ includes: Percolation.h ";

%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation::FreeDrainagePercolation
"FreeDrainagePercolation(cmf::upslope::SoilLayer::ptr left,
cmf::water::flux_node::ptr right) ";

%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation::exchange_target "void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation::get_ptr "ptr
get_ptr() const ";

%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation::get_tracer_filter
"real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation::get_tracer_filter
"real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation::set_tracer_filter
"void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation::set_tracer_filter
"void set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation::short_string "virtual std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::FreeDrainagePercolation::to_string "virtual std::string to_string() const ";


// File: classcmf__core_1_1_freundlich_adsorbtion.xml
%feature("docstring") cmf_core::FreundlichAdsorbtion "

This class calculates the adsorption equilibrium between sorbat and
sorbent using the Freundlich isotherme.  Freundlich isotherme:    ..
math::      \\\\\\\\frac{x_{ad}}{m} = K c^n  where  :math:`x_{ad} =
x_{tot} - x_{free}` is the adsorbed tracer mass  :math:`x_{tot}` is
the total tracer mass  :math:`x_{free}` is the dissolved tracer mass
:math:`m` is the mass of the sorbent in the same unit as the tracer
mass  :math:`K` is the Freundlich sorption coefficient  :math:`c =
\\\\\\\\frac{x_{free}}{V}` is the concentration of the tracer in
tracer mass per m3  :math:`n` is the Freundlich exponent  CMF stores
in a solute storage the total mass of a tracer and needs to calculate
the free tracer mass. The eq. above can not be rearanged to get
:math:`x_{free}` from :math:`x_{tot}`. Instead, the value is iterated
usingregula falsi. If n is near to 1, using LinearAdsorption will
speed up your calculations.Todo Check if an analytical solution is
available The simplest physically based adsorption model by Langmuir (
LangmuirAdsorption) has also a analytical solution and is hence
calculated faster then Freundlich.  C++ includes: adsorption.h ";

%feature("docstring")  cmf_core::FreundlichAdsorbtion::__init__ "def
__init__(self, args)

__init__(cmf::water::FreundlichAdsorbtion self, real K, real n, real
m, real epsilon=1e-12, int maxiter=100) -> FreundlichAdsorbtion
__init__(cmf::water::FreundlichAdsorbtion self, FreundlichAdsorbtion
other) -> FreundlichAdsorbtion  FreundlichAdsorbtion(const
FreundlichAdsorbtion &other) ";

%feature("docstring")  cmf_core::FreundlichAdsorbtion::copy "def
copy(self, args, kwargs)

copy(FreundlichAdsorbtion self, real m=-1) -> FreundlichAdsorbtion
FreundlichAdsorbtion* copy(real m=-1) const  returns a copy of the
Adsorption object.  If the adsorption is depending on the sorbent
mass, you can give a positive value for the sorbent mass m. If the
value is not given or negative, m is used from the original object. ";

%feature("docstring")  cmf_core::FreundlichAdsorbtion::freesolute "def freesolute(self, args, kwargs)

freesolute(Adsorption self, real xt, real V) -> real  virtual real
freesolute(real xt, real V) const =0  Returns the mass of dissolved
tracer as a function of the total tracer mass in the solute storage
and the water volume.  Parameters: -----------  xt:   :math:`x_t` the
total tracer mass in the storage  V:   :math:`V m^3` the water volume
in the storage  :math:`x_f` the dissolved mass of the tracer ";

%feature("docstring")  cmf_core::FreundlichAdsorbtion::totalsolute "def totalsolute(self, args, kwargs)

totalsolute(Adsorption self, real xf, real V) -> real  virtual real
totalsolute(real xf, real V) const =0  Returns the total mass of the
tracer from the dissolved concetration in tracer unit/m3.  Parameters:
-----------  xf:   :math:`x_f` the dissolved tracer mass in the
storage  V:   :math:`V m^3` the water volume in the storage
:math:`x_t` the total mass of the tracer ";


// File: classcmf_1_1water_1_1_freundlich_adsorbtion.xml
%feature("docstring") cmf::water::FreundlichAdsorbtion "

This class calculates the adsorption equilibrium between sorbat and
sorbent using the Freundlich isotherme.

Freundlich isotherme:



.. math::

    \\\\frac{x_{ad}}{m} = K c^n

where  :math:`x_{ad} = x_{tot} - x_{free}` is the adsorbed tracer mass  :math:`x_{tot}` is the total tracer
mass

:math:`x_{free}` is the dissolved tracer mass

:math:`m` is the mass of the sorbent in the same unit as the tracer mass

:math:`K` is the Freundlich sorption coefficient

:math:`c = \\\\frac{x_{free}}{V}` is the concentration of the tracer in
tracer mass per m3

:math:`n` is the Freundlich exponent

CMF stores in a solute storage the total mass of a tracer and needs to
calculate the free tracer mass. The eq. above can not be rearanged to
get :math:`x_{free}` from :math:`x_{tot}`. Instead, the value is iterated
usingregula falsi. If n is near to 1, using LinearAdsorption will
speed up your calculations.Todo Check if an analytical solution is
available The simplest physically based adsorption model by Langmuir (
LangmuirAdsorption) has also a analytical solution and is hence
calculated faster then Freundlich.

C++ includes: adsorption.h ";

%feature("docstring")
cmf::water::FreundlichAdsorbtion::FreundlichAdsorbtion "FreundlichAdsorbtion(real K, real n, real m, real epsilon=1e-12, int
maxiter=100)

Parameters:
-----------

K:  n:  Freundlich coefficents

m:  Mass of sorbent in units of tracer

epsilon:  Tolerance of regula falsi iteration for the calculation of
dissolved tracer from total trace, default = 1e-12

maxiter:  Maximum number of iterations, default = 100 ";

%feature("docstring")
cmf::water::FreundlichAdsorbtion::FreundlichAdsorbtion "FreundlichAdsorbtion(const FreundlichAdsorbtion &other) ";

%feature("docstring")
cmf::water::FreundlichAdsorbtion::~FreundlichAdsorbtion "virtual
~FreundlichAdsorbtion() ";

%feature("docstring")  cmf::water::FreundlichAdsorbtion::copy "FreundlichAdsorbtion* copy(real m=-1) const

returns a copy of the Adsorption object.

If the adsorption is depending on the sorbent mass, you can give a
positive value for the sorbent mass m. If the value is not given or
negative, m is used from the original object. ";

%feature("docstring")  cmf::water::FreundlichAdsorbtion::freesolute "real freesolute(real xt, real V) const

Returns the mass of dissolved tracer as a function of the total tracer
mass in the solute storage and the water volume.

Parameters:
-----------

xt:   :math:`x_t` the total tracer mass in the storage

V:   :math:`V m^3` the water volume in the storage

:math:`x_f` the dissolved mass of the tracer ";

%feature("docstring")  cmf::water::FreundlichAdsorbtion::totalsolute "real totalsolute(real xf, real V) const

Returns the total mass of the tracer from the dissolved concetration
in tracer unit/m3.

Parameters:
-----------

xf:   :math:`x_f` the dissolved tracer mass in the storage

V:   :math:`V m^3` the water volume in the storage

:math:`x_t` the total mass of the tracer ";


// File: classcmf__core_1_1generic__gradient__connection.xml
%feature("docstring") cmf_core::generic_gradient_connection "

A generic node-to-node gradient based connection.  This connection is
similar to the Darcy-connection, but there are no restrictions
concerning the type of nodes. However, the left side needs to be a
water storage   .. math::       q = K A
\\\\\\\\frac{\\\\\\\\Psi_{l}-\\\\\\\\Psi_{r}}{d}   where:  :math:`q`:
the resulting flux in :math:`m^3/day`  :math:`K`: the conductivity of
the connection  :math:`A`: the area of the connection cross section
:math:`\\\\\\\\Psi`: The hydraulic head of the (l)eft, resp. (r)ight
node of the connection  :math:`d`: The topographic length of the
connection in m  C++ includes: simple_connections.h ";

%feature("docstring")  cmf_core::generic_gradient_connection::__init__
"def __init__(self, args, kwargs)

__init__(cmf::water::generic_gradient_connection self,
cmf::water::WaterStorage::ptr left, cmf::water::WaterStorage::ptr
right, real K, real d=1.0, real A=1.0) -> generic_gradient_connection
generic_gradient_connection(cmf::water::WaterStorage::ptr left,
cmf::water::WaterStorage::ptr right, real K, real d=1.0, real A=1.0)
Creates a generic gradient based flux, if enough water is present in
the source.  Parameters: -----------  left:  The left node of the
connection  right:  The right node of the connection  K:  the
conductivity of the connection in m/day  d:  the topographic lenght of
the connection in m  A:  the area of the connection cross section in
m2 ";

%feature("docstring")
cmf_core::generic_gradient_connection::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::generic_gradient_connection::__eq__ "def __eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")
cmf_core::generic_gradient_connection::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::generic_gradient_connection::__iter__
"def __iter__(self) ";

%feature("docstring")  cmf_core::generic_gradient_connection::__repr__
"def __repr__(self) ";

%feature("docstring")  cmf_core::generic_gradient_connection::conc "def conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::generic_gradient_connection::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf_core::generic_gradient_connection::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::generic_gradient_connection::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::generic_gradient_connection::kill_me
"def kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")
cmf_core::generic_gradient_connection::left_node "def left_node(self,
args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::generic_gradient_connection::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::generic_gradient_connection::refresh
"def refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")
cmf_core::generic_gradient_connection::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::generic_gradient_connection::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf_core::generic_gradient_connection::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")
cmf_core::generic_gradient_connection::to_string "def to_string(self,
args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1water_1_1generic__gradient__connection.xml
%feature("docstring") cmf::water::generic_gradient_connection "

A generic node-to-node gradient based connection.

This connection is similar to the Darcy-connection, but there are no
restrictions concerning the type of nodes. However, the left side
needs to be a water storage 

.. math::

     q = K A
    \\\\frac{\\\\Psi_{l}-\\\\Psi_{r}}{d} 

where:  :math:`q`: the resulting
flux in :math:`m^3/day`

:math:`K`: the conductivity of the connection

:math:`A`: the area of the connection cross section

:math:`\\\\Psi`: The hydraulic head of the (l)eft, resp. (r)ight node of the
connection

:math:`d`: The topographic length of the connection in m

C++ includes: simple_connections.h ";

%feature("docstring")
cmf::water::generic_gradient_connection::generic_gradient_connection "generic_gradient_connection(cmf::water::WaterStorage::ptr left,
cmf::water::WaterStorage::ptr right, real K, real d=1.0, real A=1.0)

Creates a generic gradient based flux, if enough water is present in
the source.

Parameters:
-----------

left:  The left node of the connection

right:  The right node of the connection

K:  the conductivity of the connection in m/day

d:  the topographic lenght of the connection in m

A:  the area of the connection cross section in m2 ";

%feature("docstring")  cmf::water::generic_gradient_connection::conc "real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::water::generic_gradient_connection::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::water::generic_gradient_connection::get_ptr "ptr get_ptr() const
";

%feature("docstring")
cmf::water::generic_gradient_connection::get_target "flux_node::ptr
get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::water::generic_gradient_connection::get_target "flux_node::ptr
get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::water::generic_gradient_connection::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::generic_gradient_connection::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::water::generic_gradient_connection::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::water::generic_gradient_connection::left_node "flux_node::ptr
left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::water::generic_gradient_connection::q "real q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::water::generic_gradient_connection::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::water::generic_gradient_connection::right_node "flux_node::ptr
right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::water::generic_gradient_connection::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::generic_gradient_connection::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::water::generic_gradient_connection::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::water::generic_gradient_connection::to_string "virtual
std::string to_string() const ";


// File: classcmf_1_1upslope_1_1connections_1_1_gradient_macro_flow.xml
%feature("docstring") cmf::upslope::connections::GradientMacroFlow "

Gradient based flux from macro pore to macro pore.

Deprecated The MacroPore model is still very experimental and not
stable. Only for tryouts!



.. math::

     q = K(\\\\theta) \\\\frac{\\\\Delta \\\\Psi}{\\\\Delta z} 

C++ includes: macropore.h ";

%feature("docstring")
cmf::upslope::connections::GradientMacroFlow::GradientMacroFlow "GradientMacroFlow(cmf::upslope::MacroPore::ptr left,
cmf::water::flux_node::ptr right) ";

%feature("docstring")
cmf::upslope::connections::GradientMacroFlow::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::GradientMacroFlow::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::upslope::connections::GradientMacroFlow::get_ptr "ptr get_ptr()
const ";

%feature("docstring")
cmf::upslope::connections::GradientMacroFlow::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::GradientMacroFlow::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::GradientMacroFlow::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::GradientMacroFlow::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::GradientMacroFlow::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::GradientMacroFlow::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::connections::GradientMacroFlow::q
"real q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::GradientMacroFlow::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::GradientMacroFlow::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::GradientMacroFlow::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::GradientMacroFlow::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::GradientMacroFlow::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::GradientMacroFlow::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_gradient_macro_flow.xml
%feature("docstring") cmf_core::GradientMacroFlow "

Gradient based flux from macro pore to macro pore.  Deprecated The
MacroPore model is still very experimental and not stable. Only for
tryouts!    .. math::       q = K(\\\\\\\\theta)
\\\\\\\\frac{\\\\\\\\Delta \\\\\\\\Psi}{\\\\\\\\Delta z}   C++
includes: macropore.h ";

%feature("docstring")  cmf_core::GradientMacroFlow::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::GradientMacroFlow self,
cmf::upslope::MacroPore::ptr left, cmf::water::flux_node::ptr right)
-> GradientMacroFlow  GradientMacroFlow(cmf::upslope::MacroPore::ptr
left, cmf::water::flux_node::ptr right) ";

%feature("docstring")  cmf_core::GradientMacroFlow::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::GradientMacroFlow::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::GradientMacroFlow::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::GradientMacroFlow::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::GradientMacroFlow::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::GradientMacroFlow::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::GradientMacroFlow::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::GradientMacroFlow::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::GradientMacroFlow::get_tracer_filter
"def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::GradientMacroFlow::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::GradientMacroFlow::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::GradientMacroFlow::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::GradientMacroFlow::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::GradientMacroFlow::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::GradientMacroFlow::set_tracer_filter
"def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::GradientMacroFlow::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::GradientMacroFlow::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1connections_1_1_gradient_macro_micro_exchange.xml
%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange "

A gradient based exchange term between macropores and micropores,
using a fixed (air-) potential for macropores.



.. math::

    q = K \\\\frac{\\\\Delta\\\\Psi}{d/2} A 

where:  :math:`K` The
conductivity of the aggregate boundary

:math:`\\\\Delta\\\\Psi` The potential difference. Using the air potential
as the constant potential for the macro pores, you get:
:math:`\\\\Delta\\\\Psi = \\\\Psi_M(\\\\theta_{micro})`

:math:`d` the mean aggregate size in m

:math:`A` the crosssection area, given as the flow width (
cmf::upslope::MacroPore::get_flowwidth) times layer thickness

C++ includes: macropore.h ";

%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange::GradientMacroMicroExchange
"GradientMacroMicroExchange(cmf::upslope::SoilLayer::ptr left,
cmf::upslope::MacroPore::ptr right) ";

%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange::exchange_target
"void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange::get_ptr "ptr
get_ptr() const ";

%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange::get_tracer_filter
"real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange::get_tracer_filter
"real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange::set_tracer_filter
"void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange::set_tracer_filter
"void set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange::short_string "virtual std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::GradientMacroMicroExchange::to_string "virtual std::string to_string() const ";


// File: classcmf__core_1_1_gradient_macro_micro_exchange.xml
%feature("docstring") cmf_core::GradientMacroMicroExchange "

A gradient based exchange term between macropores and micropores,
using a fixed (air-) potential for macropores.    .. math::      q = K
\\\\\\\\frac{\\\\\\\\Delta\\\\\\\\Psi}{d/2} A   where:  :math:`K` The
conductivity of the aggregate boundary
:math:`\\\\\\\\Delta\\\\\\\\Psi` The potential difference. Using the
air potential as the constant potential for the macro pores, you get:
:math:`\\\\\\\\Delta\\\\\\\\Psi =
\\\\\\\\Psi_M(\\\\\\\\theta_{micro})`  :math:`d` the mean aggregate
size in m  :math:`A` the crosssection area, given as the flow width (
cmf::upslope::MacroPore::get_flowwidth) times layer thickness  C++
includes: macropore.h ";

%feature("docstring")  cmf_core::GradientMacroMicroExchange::__init__
"def __init__(self, args, kwargs)

__init__(cmf::upslope::connections::GradientMacroMicroExchange self,
cmf::upslope::SoilLayer::ptr left, cmf::upslope::MacroPore::ptr right)
-> GradientMacroMicroExchange
GradientMacroMicroExchange(cmf::upslope::SoilLayer::ptr left,
cmf::upslope::MacroPore::ptr right) ";

%feature("docstring")
cmf_core::GradientMacroMicroExchange::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::GradientMacroMicroExchange::__eq__ "def __eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")
cmf_core::GradientMacroMicroExchange::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::GradientMacroMicroExchange::__iter__
"def __iter__(self) ";

%feature("docstring")  cmf_core::GradientMacroMicroExchange::__repr__
"def __repr__(self) ";

%feature("docstring")  cmf_core::GradientMacroMicroExchange::conc "def conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::GradientMacroMicroExchange::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf_core::GradientMacroMicroExchange::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::GradientMacroMicroExchange::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::GradientMacroMicroExchange::kill_me "def kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::GradientMacroMicroExchange::left_node
"def left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::GradientMacroMicroExchange::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::GradientMacroMicroExchange::refresh "def refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")
cmf_core::GradientMacroMicroExchange::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::GradientMacroMicroExchange::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf_core::GradientMacroMicroExchange::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::GradientMacroMicroExchange::to_string
"def to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf__core_1_1_green_ampt_infiltration.xml
%feature("docstring") cmf_core::GreenAmptInfiltration "

Connects the surfacewater and the most upper layer using a Green-Ampt
equation like infiltration.  The Green-Ampt formula is given as:   ..
math::      q(t) = -K_s \\\\\\\\frac{dh}{dz}     A  where:
:math:`q(t)` is the infiltration rate in m3/day  :math:`K_s` is the
saturated conductivity in m/day  :math:`\\\\\\\\frac{dh}{dz}` is the
hydraulic gradient in the wetting front  :math:`A` is the surface area
of the cell  The gradient in the wetting front is calculated as:   ..
math::      \\\\\\\\frac{dh}{dz} = \\\\\\\\frac{h_f - h_0}{Z_f} =
\\\\\\\\frac{|\\\\\\\\Psi_f| + Z_f}{Z_f}  where:  :math:`h_f` is the
hydraulic head at the bottom of the wetting front in m  :math:`h_0` is
the hydraulic head at the surface in m  :math:`Z_f` is the length of
the wetting front in m  Since :math:`Z_f` is unknown, the depth of the
wetting front can be approximated by:   .. math::      Z_f =
\\\\\\\\frac{F}{\\\\\\\\theta_s -     \\\\\\\\theta_i}  with:
:math:`F` the accumulated volume per area of infiltrated water
:math:`\\\\\\\\theta_s, \\\\\\\\theta_i` the volumetric water content
at saturation resp. at start of the infiltration  If the surface water
is modeled by a distinct water storage, the actual infiltration is
given as the product of the potential infiltration with the coverage
of the surface water cmf::upslope::Cell::surface_water_coverage   ..
math::      q_{act} = q_{max}     \\\\\\\\frac{A_{water}}{A_{cell}} If
the surface water is no storage on its own, but just a water
distribution node, the actual infiltration is the minimum of the
potential infiltration and the current inflow (rain, snow melt) to the
surface   .. math::      q_{act} = \\\\\\\\min\\\\\\\\left(q_{max},
\\\\\\\\sum{q_{in,surfacewater}}\\\\\\\\right)  C++ includes:
infiltration.h ";

%feature("docstring")  cmf_core::GreenAmptInfiltration::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::GreenAmptInfiltration self,
cmf::upslope::SoilLayer::ptr soilwater, cmf::water::flux_node::ptr
surfacewater) -> GreenAmptInfiltration
GreenAmptInfiltration(cmf::upslope::SoilLayer::ptr soilwater,
cmf::water::flux_node::ptr surfacewater) ";

%feature("docstring")  cmf_core::GreenAmptInfiltration::__contains__ "def __contains__(self, cmp) ";

%feature("docstring")  cmf_core::GreenAmptInfiltration::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::GreenAmptInfiltration::__getitem__ "def __getitem__(self, index) ";

%feature("docstring")  cmf_core::GreenAmptInfiltration::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::GreenAmptInfiltration::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::GreenAmptInfiltration::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::GreenAmptInfiltration::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::GreenAmptInfiltration::get_target "def get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::GreenAmptInfiltration::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::GreenAmptInfiltration::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::GreenAmptInfiltration::left_node "def left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::GreenAmptInfiltration::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::GreenAmptInfiltration::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::GreenAmptInfiltration::right_node "def right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::GreenAmptInfiltration::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::GreenAmptInfiltration::short_string "def short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::GreenAmptInfiltration::to_string "def to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::GreenAmptInfiltration::use_for_cell "def use_for_cell(args, kwargs)

use_for_cell(Cell c) ";


// File: classcmf_1_1upslope_1_1connections_1_1_green_ampt_infiltration.xml
%feature("docstring") cmf::upslope::connections::GreenAmptInfiltration
"

Connects the surfacewater and the most upper layer using a Green-Ampt
equation like infiltration.

The Green-Ampt formula is given as: 

.. math::

    q(t) = -K_s \\\\frac{dh}{dz}
    A

where:  :math:`q(t)` is the infiltration rate in m3/day

:math:`K_s` is the saturated conductivity in m/day

:math:`\\\\frac{dh}{dz}` is the hydraulic gradient in the wetting front

:math:`A` is the surface area of the cell

The gradient in the wetting front is calculated as:


.. math::

    \\\\frac{dh}{dz} = \\\\frac{h_f - h_0}{Z_f} =
    \\\\frac{|\\\\Psi_f| + Z_f}{Z_f}

where:  :math:`h_f` is the hydraulic
head at the bottom of the wetting front in m

:math:`h_0` is the hydraulic head at the surface in m

:math:`Z_f` is the length of the wetting front in m

Since :math:`Z_f` is unknown, the depth of the wetting front can be
approximated by: 

.. math::

    Z_f = \\\\frac{F}{\\\\theta_s -
    \\\\theta_i}

with:  :math:`F` the accumulated volume per area of
infiltrated water

:math:`\\\\theta_s, \\\\theta_i` the volumetric water content at saturation
resp. at start of the infiltration

If the surface water is modeled by a distinct water storage, the
actual infiltration is given as the product of the potential
infiltration with the coverage of the surface water
cmf::upslope::Cell::surface_water_coverage 

.. math::

    q_{act} = q_{max}
    \\\\frac{A_{water}}{A_{cell}}

If the surface water is no storage on its own, but just a water
distribution node, the actual infiltration is the minimum of the
potential infiltration and the current inflow (rain, snow melt) to the
surface 

.. math::

    q_{act} = \\\\min\\\\left(q_{max},
    \\\\sum{q_{in,surfacewater}}\\\\right)

C++ includes: infiltration.h ";

%feature("docstring")
cmf::upslope::connections::GreenAmptInfiltration::GreenAmptInfiltration
"GreenAmptInfiltration(cmf::upslope::SoilLayer::ptr soilwater,
cmf::water::flux_node::ptr surfacewater) ";

%feature("docstring")
cmf::upslope::connections::GreenAmptInfiltration::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::GreenAmptInfiltration::exchange_target "void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")
cmf::upslope::connections::GreenAmptInfiltration::get_ptr "ptr
get_ptr() const ";

%feature("docstring")
cmf::upslope::connections::GreenAmptInfiltration::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::GreenAmptInfiltration::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::GreenAmptInfiltration::get_tracer_filter "real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::GreenAmptInfiltration::get_tracer_filter "real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::GreenAmptInfiltration::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::GreenAmptInfiltration::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")
cmf::upslope::connections::GreenAmptInfiltration::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::GreenAmptInfiltration::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::GreenAmptInfiltration::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::GreenAmptInfiltration::set_tracer_filter "void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::GreenAmptInfiltration::set_tracer_filter "void set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::GreenAmptInfiltration::short_string "virtual std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::GreenAmptInfiltration::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_hargreave_e_t.xml
%feature("docstring") cmf_core::HargreaveET "

Calculates the Evapotranspiration using Hargreave's equation.    ..
math::      ET_{rc} = 0.0135 K_T\\\\\\\\ s_0
\\\\\\\\sqrt{\\\\\\\\Delta T} (T +     17.8)  where:  :math:`ET_{rc}`
the reference crop evapotranspiration in mm/day  :math:`K_T =
0.00185{\\\\\\\\Delta T}^2 - 0.0433 \\\\\\\\Delta T + 0.4023`
Continentality factor as given in the reference  :math:`\\\\\\\\Delta
T = |T_{max} - T_{min}|[K]` Daily temperature range  :math:`T
[^\\\\\\\\circ C]` daily mean temperature  :math:`s_0 = 15.392 d_r
\\\\\\\\left(\\\\\\\\omega_s\\\\\\\\sin(\\\\\\\\Phi)
\\\\\\\\sin{\\\\\\\\gamma} +
\\\\\\\\cos{\\\\\\\\Phi}\\\\\\\\cos{\\\\\\\\gamma} *
\\\\\\\\sin(\\\\\\\\omega_s)\\\\\\\\right)` the extraterrestrial solar
radiation in mm/day  :math:`d_r = 1 + 0.0033
\\\\\\\\cos(DOY\\\\\\\\frac{2 \\\\\\\\pi}{365})` relative distance
between earth and sun  :math:`\\\\\\\\omega_s =
\\\\\\\\arccos(-\\\\\\\\tan{\\\\\\\\Phi} \\\\\\\\tan{\\\\\\\\gamma})`
sunset hour angle (radians)  :math:`\\\\\\\\gamma = 0.4039
\\\\\\\\sin(DOY\\\\\\\\frac{2 \\\\\\\\pi}{365} - 1.405)` solar
declination (radians)  :math:`\\\\\\\\Phi` geographic latitude
(radians)  See:  SAMANI, Zohrab.Estimating solar radiation and
evapotranspiration using minimum climatological data. Journal of
Irrigation and Drainage Engineering, 2000, 126. Jg., Nr. 4, S.
265-267.  Crop specific potential evapotranspiration is scaled by LAI:
:math:`ET_{pot} = ET_{rc} \\\\\\\\frac{LAI}{2.88}`.  C++ includes:
ET.h ";

%feature("docstring")  cmf_core::HargreaveET::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::ET::HargreaveET self,
cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr
ET_target, real latitude=51.0) -> HargreaveET
HargreaveET(cmf::upslope::SoilLayer::ptr source,
cmf::water::flux_node::ptr ET_target, real latitude=51.0) ";

%feature("docstring")  cmf_core::HargreaveET::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::HargreaveET::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::HargreaveET::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::HargreaveET::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::HargreaveET::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::HargreaveET::conc "def conc(self,
args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::HargreaveET::ETpot "def ETpot(self,
args, kwargs)

ETpot(stressedET self, Time t) -> real  virtual real
ETpot(cmf::math::Time t) const ";

%feature("docstring")  cmf_core::HargreaveET::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::HargreaveET::get_layer "def
get_layer(self, args, kwargs)

get_layer(stressedET self) -> cmf::upslope::SoilLayer::ptr
SoilLayer::ptr get_layer() const ";

%feature("docstring")  cmf_core::HargreaveET::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::HargreaveET::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::HargreaveET::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::HargreaveET::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::HargreaveET::q "def q(self, args,
kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::HargreaveET::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::HargreaveET::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::HargreaveET::set_stressfunction "def
set_stressfunction(self, args, kwargs)

set_stressfunction(stressedET self, RootUptakeStessFunction
stressfunction)  void set_stressfunction(const RootUptakeStessFunction
&stressfunction)  Sets the stress function to limit water uptake. ";

%feature("docstring")  cmf_core::HargreaveET::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::HargreaveET::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::HargreaveET::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::HargreaveET::use_for_cell "def
use_for_cell(args, kwargs)

use_for_cell(Cell cell) ";


// File: classcmf_1_1upslope_1_1_e_t_1_1_hargreave_e_t.xml
%feature("docstring") cmf::upslope::ET::HargreaveET "

Calculates the Evapotranspiration using Hargreave's equation.



.. math::

    ET_{rc} = 0.0135 K_T\\\\ s_0 \\\\sqrt{\\\\Delta T} (T +
    17.8)

where:  :math:`ET_{rc}` the reference crop evapotranspiration
in mm/day

:math:`K_T = 0.00185{\\\\Delta T}^2 - 0.0433 \\\\Delta T + 0.4023`
Continentality factor as given in the reference

:math:`\\\\Delta T = |T_{max} - T_{min}|[K]` Daily temperature range

:math:`T [^\\\\circ C]` daily mean temperature

:math:`s_0 = 15.392 d_r \\\\left(\\\\omega_s\\\\sin(\\\\Phi) \\\\sin{\\\\gamma} + \\\\cos{\\\\Phi}\\\\cos{\\\\gamma} * \\\\sin(\\\\omega_s)\\\\right)` the extraterrestrial solar radiation
in mm/day

:math:`d_r = 1 + 0.0033 \\\\cos(DOY\\\\frac{2 \\\\pi}{365})` relative
distance between earth and sun

:math:`\\\\omega_s = \\\\arccos(-\\\\tan{\\\\Phi} \\\\tan{\\\\gamma})`
sunset hour angle (radians)

:math:`\\\\gamma = 0.4039 \\\\sin(DOY\\\\frac{2 \\\\pi}{365} - 1.405)`
solar declination (radians)

:math:`\\\\Phi` geographic latitude (radians)

See:  SAMANI, Zohrab.Estimating solar radiation and evapotranspiration
using minimum climatological data. Journal of Irrigation and Drainage
Engineering, 2000, 126. Jg., Nr. 4, S. 265-267.  Crop specific
potential evapotranspiration is scaled by LAI: :math:`ET_{pot} = ET_{rc} \\\\frac{LAI}{2.88}`.

C++ includes: ET.h ";

%feature("docstring")  cmf::upslope::ET::HargreaveET::HargreaveET "HargreaveET(cmf::upslope::SoilLayer::ptr source,
cmf::water::flux_node::ptr ET_target, real latitude=51.0) ";

%feature("docstring")  cmf::upslope::ET::HargreaveET::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")  cmf::upslope::ET::HargreaveET::ETpot "real
ETpot(cmf::math::Time t) const ";

%feature("docstring")  cmf::upslope::ET::HargreaveET::exchange_target
"void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")  cmf::upslope::ET::HargreaveET::get_layer "SoilLayer::ptr get_layer() const ";

%feature("docstring")  cmf::upslope::ET::HargreaveET::get_ptr "ptr
get_ptr() const ";

%feature("docstring")  cmf::upslope::ET::HargreaveET::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::ET::HargreaveET::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::ET::HargreaveET::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::HargreaveET::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::ET::HargreaveET::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::upslope::ET::HargreaveET::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::ET::HargreaveET::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::ET::HargreaveET::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::upslope::ET::HargreaveET::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::ET::HargreaveET::set_stressfunction "void
set_stressfunction(const RootUptakeStessFunction &stressfunction)

Sets the stress function to limit water uptake. ";

%feature("docstring")
cmf::upslope::ET::HargreaveET::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::HargreaveET::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf::upslope::ET::HargreaveET::short_string "virtual std::string short_string() const ";

%feature("docstring")  cmf::upslope::ET::HargreaveET::to_string "std::string to_string() const ";


// File: classcmf__core_1_1_heun_integrator.xml
%feature("docstring") cmf_core::HeunIntegrator "

A simple predictor - corrector solver.  Not tested and very
experimentally :math:`y^{n+1} = y^n + \\\\\\\\alpha f(y^n +
f(y^n)dt)dt + (1-\\\\\\\\alpha)f(y^n)dt`  C++ includes:
explicit_euler.h ";

%feature("docstring")  cmf_core::HeunIntegrator::__init__ "def
__init__(self, args)

__init__(cmf::math::HeunIntegrator self, StateVariableOwner states,
real Alpha=0.5) -> HeunIntegrator __init__(cmf::math::HeunIntegrator
self, real Alpha=0.5) -> HeunIntegrator
__init__(cmf::math::HeunIntegrator self, Integrator copy) ->
HeunIntegrator  HeunIntegrator(const Integrator &copy)  copy
constructor ";

%feature("docstring")  cmf_core::HeunIntegrator::__call__ "def
__call__(self, t, dt=None, reset=False)

Advances the integration until `t`  A shortcut to .integrate_until
Parameters ---------- t : cmf.Time     The time step to advance to. If
t < current time, the solver will     advance to self.t + t dt :
cmf.Time, optional     The timestep for the integration. If not given
try to integrate in one step reset : bool, optional     If True, the
solver will perform a reset before starting  Returns ------- cmf.Time
The new time stamp ";

%feature("docstring")  cmf_core::HeunIntegrator::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(Integrator self, long position) ->
cmf::math::StateVariable::ptr ";

%feature("docstring")  cmf_core::HeunIntegrator::__len__ "def
__len__(self, args, kwargs)

__len__(Integrator self) -> size_t ";

%feature("docstring")  cmf_core::HeunIntegrator::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::HeunIntegrator::add_single_state "def add_single_state(self, args, kwargs)

add_single_state(Integrator self, cmf::math::StateVariable::ptr state)
virtual void add_single_state(cmf::math::StateVariable::ptr state)
Adds a single state variable to the integrator. ";

%feature("docstring")  cmf_core::HeunIntegrator::add_states "def
add_states(self, args, kwargs)

add_states(Integrator self, StateVariableOwner stateOwner)  virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)  Add state
variables from a StateVariableOwner. ";

%feature("docstring")  cmf_core::HeunIntegrator::copy "def copy(self,
args, kwargs)

copy(Integrator self) -> Integrator  virtual Integrator* copy() const
=0  Polymorphic copy constructor. ";

%feature("docstring")  cmf_core::HeunIntegrator::get_dt "def
get_dt(self, args, kwargs)

get_dt(Integrator self) -> Time  cmf::math::Time get_dt() const
Returns the last time step. ";

%feature("docstring")  cmf_core::HeunIntegrator::get_dxdt "def
get_dxdt(self, args, kwargs)

get_dxdt(Integrator self, Time time) -> cmf::math::num_array
cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf_core::HeunIntegrator::get_state "def
get_state(self, args, kwargs)

get_state(Integrator self, ptrdiff_t position) -> real  real
get_state(ptrdiff_t position) const  Returns the statevariable at
position Simplifies the assessment of state variables. ";

%feature("docstring")  cmf_core::HeunIntegrator::get_states "def
get_states(self, args)

get_states(Integrator self) -> cmf::math::num_array
get_states(Integrator self) -> StateVariableList  StateVariableList
get_states()  gets the state variables of the integrator ";

%feature("docstring")  cmf_core::HeunIntegrator::get_t "def
get_t(self, args, kwargs)

get_t(Integrator self) -> Time  cmf::math::Time get_t() const  Returns
the current model time. ";

%feature("docstring")  cmf_core::HeunIntegrator::integrate "def
integrate(self, args, kwargs)

integrate(Integrator self, Time t_max, Time dt) -> int  virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)=0  Integrates the
vector of state variables.  Parameters: -----------  t_max:  To stop
the model (if running in a model framework) at time steps of value
exchange e.g. full hours, the next value exchange time can be given
dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf_core::HeunIntegrator::integrate_until "def
integrate_until(self, args, kwargs)

integrate_until(Integrator self, Time t_max, Time dt, bool
reset=False)  void integrate_until(cmf::math::Time t_max,
cmf::math::Time dt=Time(), bool reset=false)  Integrates the vector of
state variables until t_max.  Parameters: -----------  t_max:   Time,
the solver should run to  dt:   Time step (may be omitted)  reset:  If
true, solver is reseted before integration starts ";

%feature("docstring")  cmf_core::HeunIntegrator::reset "def
reset(self, args, kwargs)

reset(Integrator self)  virtual void reset()  Resets any saved history
(for multistep methods) ";

%feature("docstring")  cmf_core::HeunIntegrator::run "def run(self,
start=None, end=None, step=day *1, max_errors=0, reset=False)

Returns an iterator over the timesteps start..end  **Examples:**  >>>
solver=cmf.CVodeIntegrator(...) >>> for t in solver.run(solver.t,
solver.t + cmf.week, cmf.h): >>>    print(t, solver[0].state) or with
list comprehension >>> states = [solver[0].state for t in
solver.run(solver.t, solver.t + cmf.week, cmf.h)]  Parameters
---------- start : cmf.Time, optional Start time for the solver
iteration end : cmf.Time, optional End time of the iteration step :
cmf.Time, optional Step size for the integration max_errors: int
Number of tolerated errors. If >0, up to these number of runtime
errors will be saved with their time and the integration proceeds
after a reset of the solver. Some systems operate with values close to
their physical limits and inifinite values in the integration can
easily occur. For these kind of systems set max_errors to eg. 10. A
larger number of errors should be eliminated usually. reset: bool If
True, the solver performs a `reset` at every time step  Yields ------
cmf.Time      the actual timestep ";

%feature("docstring")  cmf_core::HeunIntegrator::set_state "def
set_state(self, args, kwargs)

set_state(Integrator self, ptrdiff_t position, real newState)  void
set_state(ptrdiff_t position, real newState)  Simplifies the
assessment of state variables. ";

%feature("docstring")  cmf_core::HeunIntegrator::set_t "def
set_t(self, args, kwargs)

set_t(Integrator self, Time val)  void set_t(cmf::math::Time val) Sets
the current model time. ";

%feature("docstring")  cmf_core::HeunIntegrator::size "def size(self,
args, kwargs)

size(Integrator self) -> size_t  size_t size() const  returns the
number of state variables ";


// File: classcmf_1_1math_1_1_heun_integrator.xml
%feature("docstring") cmf::math::HeunIntegrator "

A simple predictor - corrector solver.

Not tested and very experimentally :math:`y^{n+1} = y^n + \\\\alpha f(y^n + f(y^n)dt)dt + (1-\\\\alpha)f(y^n)dt`

C++ includes: explicit_euler.h ";

/*  Accuracy parameters  */

/*  model time  */

%feature("docstring")  cmf::math::HeunIntegrator::get_t "cmf::math::Time get_t() const

Returns the current model time. ";

%feature("docstring")  cmf::math::HeunIntegrator::set_t "void
set_t(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::HeunIntegrator::get_dt "cmf::math::Time get_dt() const

Returns the last time step. ";

%feature("docstring")  cmf::math::HeunIntegrator::reset "virtual void
reset()

Resets any saved history (for multistep methods) ";

/*  Integrate  */

%feature("docstring")  cmf::math::HeunIntegrator::integrate_until "void integrate_until(cmf::math::Time t_max, cmf::math::Time dt=Time(),
bool reset=false)

Integrates the vector of state variables until t_max.

Parameters:
-----------

t_max:   Time, the solver should run to

dt:   Time step (may be omitted)

reset:  If true, solver is reseted before integration starts ";

%feature("docstring")  cmf::math::HeunIntegrator::HeunIntegrator "HeunIntegrator(StateVariableOwner &states, real Alpha=0.5)

Constructs a new PredictCorrectSimple from a pointer to a vector of
state variables.

The Integrator becomes the owner of states

Parameters:
-----------

states:  Statevariable owner of the system

Alpha:  Weight factor :math:`\\\\alpha` to weight :math:`f(y^n)` and :math:`f(y^{n+1})`
";

%feature("docstring")  cmf::math::HeunIntegrator::HeunIntegrator "HeunIntegrator(real Alpha=0.5)

Constructs a new PredictCorrectSimple.

Parameters:
-----------

Alpha:  Weight factor :math:`\\\\alpha` to weight :math:`f(y^n)` and :math:`f(y^{n+1})`
";

%feature("docstring")  cmf::math::HeunIntegrator::HeunIntegrator "HeunIntegrator(const Integrator &copy)

copy constructor ";

%feature("docstring")  cmf::math::HeunIntegrator::~HeunIntegrator "virtual ~HeunIntegrator() ";

%feature("docstring")  cmf::math::HeunIntegrator::add_single_state "virtual void add_single_state(cmf::math::StateVariable::ptr state)

Adds a single state variable to the integrator. ";

%feature("docstring")  cmf::math::HeunIntegrator::add_states "void
add_states(cmf::math::StateVariableOwner &stateOwner)

Add state variables from a StateVariableOwner. ";

%feature("docstring")  cmf::math::HeunIntegrator::add_values_to_states
"void add_values_to_states(const num_array &operands)

Adds the values in operands to the current states. ";

%feature("docstring")  cmf::math::HeunIntegrator::copy "virtual
Integrator* copy() const

Polymorphic copy constructor. ";

%feature("docstring")  cmf::math::HeunIntegrator::copy_dxdt "void
copy_dxdt(Time time, num_array &destination, real factor=1) const

Copies the derivatives at time step \"time\" to a numeric vector using
use_OpenMP.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Vector to be overwritten by the results

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::HeunIntegrator::copy_dxdt "void
copy_dxdt(Time time, real *destination, real factor=1) const

Copies the derivatives at time step \"time\" to an preallocated c
array.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Allocated c array

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::HeunIntegrator::copy_states "void
copy_states(num_array &destination) const

Copies the states to a numeric vector using use_OpenMP. ";

%feature("docstring")  cmf::math::HeunIntegrator::copy_states "void
copy_states(real *destination) const ";

%feature("docstring")  cmf::math::HeunIntegrator::get_dxdt "cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf::math::HeunIntegrator::get_state "real
get_state(ptrdiff_t position) const

Returns the statevariable at position Simplifies the assessment of
state variables. ";

%feature("docstring")  cmf::math::HeunIntegrator::get_states "cmf::math::num_array get_states() const ";

%feature("docstring")  cmf::math::HeunIntegrator::get_states "StateVariableList get_states()

gets the state variables of the integrator ";

%feature("docstring")  cmf::math::HeunIntegrator::integrate "int
integrate(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

Integrates the vector of state variables.

Parameters:
-----------

MaxTime:  (ignored) To stop the model (if running in a model
framework) at time steps of value exchange e.g. full hours, the next
value exchange time can be given

TimeStep:  Takes the proposed time step ";

%feature("docstring")  cmf::math::HeunIntegrator::set_state "void
set_state(ptrdiff_t position, real newState)

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::HeunIntegrator::set_states "void
set_states(const num_array &newStates)

Copies the new states to the actual states. ";

%feature("docstring")  cmf::math::HeunIntegrator::set_states "void
set_states(real *newStates) ";

%feature("docstring")  cmf::math::HeunIntegrator::size "size_t size()
const

returns the number of state variables ";


// File: classcmf_1_1draw_1_1hillplot_1_1_hill_plot.xml
%feature("docstring") cmf::draw::hillplot::HillPlot "

Plots a hillslope using colored sheared rectangles for each layer and
arrows (matplotlib.quiver) to show fluxes.  Properties:   -
evalfunction: a function returning the value of a layer to plot. The
value should be a float between 0..1 for scaling.     The default is:
lambda l: l.wetness  - q_sub:  The matplotlib.Quiver object for
subsurface fluxes  - q_surf: The matplotlib.Quiver object for
subsurface fluxes  - title:  Title of the plot  - scale:  The scale of
q_sub and q_surf ";

%feature("docstring")  cmf::draw::hillplot::HillPlot::__init__ "def
__init__(self, cells, t, solute=None, cmap=default_color_map)

Creates a new HillPlot on the active figure, showing the state of each
layer  - cells: The a sequence of cmf cells to use in this hill_plot.
You can   use the whole project if you like  - t:     Current time
step. Needed to retrieve the fluxes  - solute:The solute concentration
to show. If None, the wetness of the    layer will be shown  - cmap: a
matplotlib colormap (see module cm) for coloring ";

%feature("docstring")  cmf::draw::hillplot::HillPlot::__call__ "def
__call__(self, t, text='')

Updates the hill_plot at time t. You can provide a title for the
figure. If bool(title)==False, t is shown. ";

%feature("docstring")  cmf::draw::hillplot::HillPlot::get_animator "def get_animator(self, integration)

Returns a matplotlib.animation.FuncAnimator object that uses the
integration iteratable to advance your model to animate the HillPlot
Usage example:  >>>p=cmf.project() >>>solver = cmf.CVodeIntegrator(p,
1e-9) >>>hp = HillPlot(p, solver.t) >>>animator =
hp.get_animator(solver.run(datetime(2012, 1, 1), datetime(2012, 2, 1),
timedelta(hours=1)))  :param integration: An iterable that advances
the model and yields the current time :return: A
matplotlib.animation.FuncAnimator ";


// File: classcmf_1_1river_1_1_i_channel.xml
%feature("docstring") cmf::river::IChannel "

Structure for the description of structural parameters of a reach
Abstract base class for different IChannel geometries.

C++ includes: ReachType.h ";

%feature("docstring")  cmf::river::IChannel::~IChannel "virtual
~IChannel() ";

%feature("docstring")  cmf::river::IChannel::A "virtual double
A(double V) const

Returns the area of the surface for a given volume. ";

%feature("docstring")  cmf::river::IChannel::copy "virtual IChannel*
copy() const =0 ";

%feature("docstring")  cmf::river::IChannel::get_channel_width "virtual double get_channel_width(double depth) const =0

Calculates the flow width from a given actual depth [m] using the
actual IChannel geometry. ";

%feature("docstring")  cmf::river::IChannel::get_depth "virtual
double get_depth(double area) const =0

Calculates the actual depth of the reach using the IChannel geometry.

get_depth of the reach [m]

Parameters:
-----------

area:  Wetted area of a river cross section [m2], can be obtained by
V/l, where V is the stored volume and l is the reach length ";

%feature("docstring")  cmf::river::IChannel::get_flux_crossection "virtual double get_flux_crossection(double depth) const =0

Calculates the wetted area from a given depth using the IChannel
geometry.

In most cases use get_flux_crossection=V/l, where V is the stored
volume and l is the reach length Wetted area of a river cross section
[m2]

Parameters:
-----------

depth:  depth of the reach [m] ";

%feature("docstring")  cmf::river::IChannel::get_length "virtual
double get_length() const =0

Length of the reach. ";

%feature("docstring")  cmf::river::IChannel::get_nManning "virtual
double get_nManning() const =0 ";

%feature("docstring")  cmf::river::IChannel::get_wetted_perimeter "virtual double get_wetted_perimeter(double depth) const =0

Calculates the wetted perimeter from a given actual depth [m] using
the actual IChannel geometry. ";

%feature("docstring")  cmf::river::IChannel::h "virtual double
h(double V) const

Returns the depth of a given volume. ";

%feature("docstring")  cmf::river::IChannel::q "virtual double
q(double h, double slope) const ";

%feature("docstring")  cmf::river::IChannel::qManning "virtual double
qManning(double A, double slope) const

Calculates the flow rate from a given water volume in the reach


.. math::

     q_{Manning}&=& A R^{\\\\frac 2 3}
    \\\\sqrt{\\\\frac {\\\\Delta_z} n} \\\\\\\\ A &=& \\\\frac V l
    \\\\mbox{, (Crosssectional area of the wetted crossection, Volume per
    length)} \\\\\\\\ R &=& \\\\frac A {P(d)} \\\\\\\\ P(d) &=& \\\\mbox{
    the perimeter of the wetted crosssection, a function of reach depth}
    \\\\\\\\ d(V) &=& \\\\mbox{ the depth of the reach a function of the
    volume} \\\\\\\\ \\\\Delta_z &=& \\\\frac{z_{max} - z_{min}}{l}
    \\\\mbox{ Slope of the reach} 

.

Flow rate [m3/s]

Parameters:
-----------

A:  The area of the cross section [m2]

slope:  The slope of the reach [m/m] ";

%feature("docstring")  cmf::river::IChannel::set_nManning "virtual
void set_nManning(double val)=0 ";

%feature("docstring")  cmf::river::IChannel::typecode "virtual char
typecode() const =0 ";

%feature("docstring")  cmf::river::IChannel::V "virtual double
V(double h) const ";


// File: classcmf__core_1_1_i_channel.xml
%feature("docstring") cmf_core::IChannel "

Structure for the description of structural parameters of a reach
Abstract base class for different IChannel geometries.  C++ includes:
ReachType.h ";

%feature("docstring")  cmf_core::IChannel::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::IChannel::A "def A(self, args,
kwargs)

A(IVolumeHeightFunction self, double V) -> double  virtual double
A(double V) const =0  Returns the area of the surface for a given
volume. ";

%feature("docstring")  cmf_core::IChannel::copy "def copy(self, args,
kwargs)

copy(IChannel self) -> IChannel  virtual IChannel* copy() const =0 ";

%feature("docstring")  cmf_core::IChannel::get_channel_width "def
get_channel_width(self, args, kwargs)

get_channel_width(IChannel self, double depth) -> double  virtual
double get_channel_width(double depth) const =0  Calculates the flow
width from a given actual depth [m] using the actual IChannel
geometry. ";

%feature("docstring")  cmf_core::IChannel::get_depth "def
get_depth(self, args, kwargs)

get_depth(IChannel self, double area) -> double  virtual double
get_depth(double area) const =0  Calculates the actual depth of the
reach using the IChannel geometry.  get_depth of the reach [m]
Parameters: -----------  area:  Wetted area of a river cross section
[m2], can be obtained by V/l, where V is the stored volume and l is
the reach length ";

%feature("docstring")  cmf_core::IChannel::get_flux_crossection "def
get_flux_crossection(self, args, kwargs)

get_flux_crossection(IChannel self, double depth) -> double  virtual
double get_flux_crossection(double depth) const =0  Calculates the
wetted area from a given depth using the IChannel geometry.  In most
cases use get_flux_crossection=V/l, where V is the stored volume and l
is the reach length Wetted area of a river cross section [m2]
Parameters: -----------  depth:  depth of the reach [m] ";

%feature("docstring")  cmf_core::IChannel::get_length "def
get_length(self, args, kwargs)

get_length(IChannel self) -> double  virtual double get_length() const
=0  Length of the reach. ";

%feature("docstring")  cmf_core::IChannel::get_nManning "def
get_nManning(self, args, kwargs)

get_nManning(IChannel self) -> double  virtual double get_nManning()
const =0 ";

%feature("docstring")  cmf_core::IChannel::get_wetted_perimeter "def
get_wetted_perimeter(self, args, kwargs)

get_wetted_perimeter(IChannel self, double depth) -> double  virtual
double get_wetted_perimeter(double depth) const =0  Calculates the
wetted perimeter from a given actual depth [m] using the actual
IChannel geometry. ";

%feature("docstring")  cmf_core::IChannel::h "def h(self, args,
kwargs)

h(IVolumeHeightFunction self, double V) -> double  virtual double
h(double V) const =0  Returns the depth of a given volume. ";

%feature("docstring")  cmf_core::IChannel::q "def q(self, args,
kwargs)

q(IVolumeHeightFunction self, double h, double slope) -> double
virtual double q(double h, double slope) const ";

%feature("docstring")  cmf_core::IChannel::qManning "def
qManning(self, args, kwargs)

qManning(IChannel self, double A, double slope) -> double  virtual
double qManning(double A, double slope) const  Calculates the flow
rate from a given water volume in the reach   .. math:: q_{Manning}&=&
A R^{\\\\\\\\frac 2 3}     \\\\\\\\sqrt{\\\\\\\\frac {\\\\\\\\Delta_z}
n} \\\\\\\\\\\\\\\\ A &=& \\\\\\\\frac V l \\\\\\\\mbox{,
(Crosssectional area of the wetted crossection, Volume per
length)} \\\\\\\\\\\\\\\\ R &=& \\\\\\\\frac A {P(d)} \\\\\\\\\\\\\\\\
P(d) &=& \\\\\\\\mbox{     the perimeter of the wetted crosssection, a
function of reach depth}     \\\\\\\\\\\\\\\\ d(V) &=& \\\\\\\\mbox{
the depth of the reach a function of the volume} \\\\\\\\\\\\\\\\
\\\\\\\\Delta_z &=& \\\\\\\\frac{z_{max} - z_{min}}{l}
\\\\\\\\mbox{ Slope of the reach}   .  Flow rate [m3/s]  Parameters:
-----------  A:  The area of the cross section [m2]  slope:  The slope
of the reach [m/m] ";

%feature("docstring")  cmf_core::IChannel::set_nManning "def
set_nManning(self, args, kwargs)

set_nManning(IChannel self, double val)  virtual void
set_nManning(double val)=0 ";

%feature("docstring")  cmf_core::IChannel::typecode "def
typecode(self, args, kwargs)

typecode(IChannel self) -> char  virtual char typecode() const =0 ";

%feature("docstring")  cmf_core::IChannel::V "def V(self, args,
kwargs)

V(IVolumeHeightFunction self, double h) -> double  virtual double
V(double h) const =0 ";


// File: classcmf_1_1atmosphere_1_1_i_d_w___meteorology.xml
%feature("docstring") cmf::atmosphere::IDW_Meteorology "

Regionalizes meteorological measurements using a simple inverse
distance weighted (IDW) method.

See:  IDW

C++ includes: meteorology.h ";

%feature("docstring")
cmf::atmosphere::IDW_Meteorology::IDW_Meteorology "IDW_Meteorology(const cmf::geometry::point &position, const
MeteoStationList &stations, double z_weight, double power)

Creates an reference to a list of stations and interpolates the
weather using IDW.

Parameters:
-----------

position:  Position of reference

stations:  Meteo stations

z_weight:  Weight of height in IDW procedure

power:  Power of IDW procedure ";

%feature("docstring")
cmf::atmosphere::IDW_Meteorology::IDW_Meteorology "IDW_Meteorology(const IDW_Meteorology &copy)

Copy c'tor. ";

%feature("docstring")  cmf::atmosphere::IDW_Meteorology::copy "virtual IDW_Meteorology* copy() const

Returns a copy of the meteorology object. Pure virtual function, needs
to be implemented. ";

%feature("docstring")
cmf::atmosphere::IDW_Meteorology::get_instrument_height "virtual real
get_instrument_height() const

Returns the height of the instruments above canopy. ";

%feature("docstring")  cmf::atmosphere::IDW_Meteorology::get_weather "virtual Weather get_weather(cmf::math::Time t) const

Returns the Weather at time t. Pure virtual function. Must get
implemented by child functions. ";


// File: classcmf__core_1_1_i_d_w___meteorology.xml
%feature("docstring") cmf_core::IDW_Meteorology "

Regionalizes meteorological measurements using a simple inverse
distance weighted (IDW) method.  See:  IDW  C++ includes:
meteorology.h ";

%feature("docstring")  cmf_core::IDW_Meteorology::__init__ "def
__init__(self, args)

__init__(cmf::atmosphere::IDW_Meteorology self, point position,
MeteoStationList stations, double z_weight, double power) ->
IDW_Meteorology __init__(cmf::atmosphere::IDW_Meteorology self,
IDW_Meteorology copy) -> IDW_Meteorology  IDW_Meteorology(const
IDW_Meteorology &copy)  Copy c'tor. ";

%feature("docstring")  cmf_core::IDW_Meteorology::__call__ "def
__call__(self, args, kwargs)

__call__(Meteorology self, Time t) -> Weather ";

%feature("docstring")  cmf_core::IDW_Meteorology::copy "def
copy(self, args, kwargs)

copy(IDW_Meteorology self) -> IDW_Meteorology  virtual
IDW_Meteorology* copy() const  Returns a copy of the meteorology
object. Pure virtual function, needs to be implemented. ";

%feature("docstring")
cmf_core::IDW_Meteorology::get_instrument_height "def
get_instrument_height(self, args, kwargs)

get_instrument_height(Meteorology self) -> real  virtual real
get_instrument_height() const =0  Returns the height of the
instruments above canopy. ";

%feature("docstring")  cmf_core::IDW_Meteorology::get_weather "def
get_weather(self, args, kwargs)

get_weather(Meteorology self, Time t) -> Weather  virtual
cmf::atmosphere::Weather get_weather(cmf::math::Time t) const =0
Returns the Weather at time t. Pure virtual function. Must get
implemented by child functions. ";


// File: classcmf_1_1atmosphere_1_1_i_d_w_rainfall.xml
%feature("docstring") cmf::atmosphere::IDWRainfall "

A RainSource using a spatially interpolated rainfall intensity from
all stations.

Interpolation method is inverse distance weighted (IDW)

C++ includes: precipitation.h ";

%feature("docstring")  cmf::atmosphere::IDWRainfall::conc "real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const

Returns the concentration of a solute in the rainfall at time t. ";

%feature("docstring")  cmf::atmosphere::IDWRainfall::connection_to "cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::atmosphere::IDWRainfall::flux3d_to "cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf::atmosphere::IDWRainfall::flux_to "real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf::atmosphere::IDWRainfall::get_3d_flux "cmf::geometry::point get_3d_flux(cmf::math::Time t)

Returns the sum of all flux vectors. ";

%feature("docstring")  cmf::atmosphere::IDWRainfall::get_connections "cmf::water::connection_list get_connections() const ";

%feature("docstring")  cmf::atmosphere::IDWRainfall::get_intensity "real get_intensity(cmf::math::Time t) const

Returns the actual rainfall intensity in mm/day. ";

%feature("docstring")  cmf::atmosphere::IDWRainfall::get_potential "virtual real get_potential() const

Returns the water potential of the node in m waterhead.

The base class water storage always returns the height of the location
";

%feature("docstring")  cmf::atmosphere::IDWRainfall::get_project "cmf::project& get_project() const

Returns the project, this node is part of. ";

%feature("docstring")  cmf::atmosphere::IDWRainfall::is_empty "virtual double is_empty() const

Returns false. ";

%feature("docstring")  cmf::atmosphere::IDWRainfall::is_storage "virtual bool is_storage() const

true, if this is a waterstorage ";

%feature("docstring")  cmf::atmosphere::IDWRainfall::RecalcFluxes "virtual bool RecalcFluxes(cmf::math::Time t)

Pure flux_nodes do not influence fluxes, therefore no recalculation of
fluxes is required by flux_node.

WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf::atmosphere::IDWRainfall::remove_connection
"bool remove_connection(cmf::water::flux_node::ptr To)

Remove the connection. ";

%feature("docstring")  cmf::atmosphere::IDWRainfall::set_potential "virtual void set_potential(real new_potential)

Sets the potential of this flux node. ";

%feature("docstring")  cmf::atmosphere::IDWRainfall::to_string "virtual std::string to_string() const ";

%feature("docstring")  cmf::atmosphere::IDWRainfall::waterbalance "real waterbalance(cmf::math::Time t, const flux_connection *Without=0)
const

Returns the sum of all fluxes (positive and negative) at time t.

Single fluxes can be excluded from the calculation

Parameters:
-----------

t:  Time of the query

Without:  A flux_connection that is excluded from the waterbalance
(e.g. to prevent closed circuits) ";


// File: classcmf__core_1_1_i_d_w_rainfall.xml
%feature("docstring") cmf_core::IDWRainfall "

A RainSource using a spatially interpolated rainfall intensity from
all stations.  Interpolation method is inverse distance weighted (IDW)
C++ includes: precipitation.h ";

%feature("docstring")  cmf_core::IDWRainfall::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::IDWRainfall::__call__ "def
__call__(self, args, kwargs)

__call__(RainSource self, Time t) -> real ";

%feature("docstring")  cmf_core::IDWRainfall::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_node self, flux_node other) -> bool ";

%feature("docstring")  cmf_core::IDWRainfall::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::IDWRainfall::conc "def conc(self,
args, kwargs)

conc(flux_node self, Time t, solute Solute) -> real  virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const
Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf_core::IDWRainfall::connected_nodes "def
connected_nodes(self) ";

%feature("docstring")  cmf_core::IDWRainfall::connection_to "def
connection_to(self, args, kwargs)

connection_to(flux_node self, flux_node target) -> flux_connection
cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)  Returns the connection between this and target. ";

%feature("docstring")  cmf_core::IDWRainfall::create "def
create(args, kwargs)

create(project project, point position, double z_weight, double power)
-> cmf::atmosphere::RainSource::ptr ";

%feature("docstring")  cmf_core::IDWRainfall::flux3d_to "def
flux3d_to(self, args, kwargs)

flux3d_to(flux_node self, flux_node target, Time t) -> point
cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf_core::IDWRainfall::flux_to "def
flux_to(self, args, kwargs)

flux_to(flux_node self, flux_node target, Time t) -> real  real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)
Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf_core::IDWRainfall::fluxes "def
fluxes(self, t) ";

%feature("docstring")  cmf_core::IDWRainfall::get_3d_flux "def
get_3d_flux(self, args, kwargs)

get_3d_flux(flux_node self, Time t) -> point  cmf::geometry::point
get_3d_flux(cmf::math::Time t)  Returns the sum of all flux vectors.
";

%feature("docstring")  cmf_core::IDWRainfall::get_intensity "def
get_intensity(self, args, kwargs)

get_intensity(RainSource self, Time t) -> real  virtual real
get_intensity(cmf::math::Time t) const =0  Returns the actual rainfall
intensity in mm/day. ";

%feature("docstring")  cmf_core::IDWRainfall::is_empty "def
is_empty(self, args, kwargs)

is_empty(flux_node self) -> double  virtual double is_empty() const
Returns true if the node has no water. ";

%feature("docstring")  cmf_core::IDWRainfall::is_storage "def
is_storage(self, args, kwargs)

is_storage(flux_node self) -> bool  virtual bool is_storage() const
true, if this is a waterstorage ";

%feature("docstring")  cmf_core::IDWRainfall::RecalcFluxes "def
RecalcFluxes(self, args, kwargs)

RecalcFluxes(flux_node self, Time t) -> bool  virtual bool
RecalcFluxes(cmf::math::Time t)  Pure flux_nodes do not influence
fluxes, therefore no recalculation of fluxes is required by flux_node.
WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf_core::IDWRainfall::remove_connection "def
remove_connection(self, args, kwargs)

remove_connection(flux_node self, cmf::water::flux_node::ptr To) ->
bool  bool remove_connection(cmf::water::flux_node::ptr To)  Remove
the connection. ";

%feature("docstring")  cmf_core::IDWRainfall::to_string "def
to_string(self, args, kwargs)

to_string(flux_node self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::IDWRainfall::waterbalance "def
waterbalance(self, args, kwargs)

waterbalance(flux_node self, Time t, flux_connection Without=None) ->
real  real waterbalance(cmf::math::Time t, const flux_connection
*Without=0) const  Returns the sum of all fluxes (positive and
negative) at time t.  Single fluxes can be excluded from the
calculation  Parameters: -----------  t:  Time of the query  Without:
A flux_connection that is excluded from the waterbalance (e.g. to
prevent closed circuits) ";


// File: classcmf__core_1_1_implicit_euler.xml
%feature("docstring") cmf_core::ImplicitEuler "

An implicit (backward) Euler integrator using fixpoint iteration.  C++
includes: implicit_euler.h ";

%feature("docstring")  cmf_core::ImplicitEuler::__init__ "def
__init__(self, args)

__init__(cmf::math::ImplicitEuler self, StateVariableOwner states,
real epsilon=1e-9, Time tStepMin) -> ImplicitEuler
__init__(cmf::math::ImplicitEuler self, real epsilon=1e-9, Time
tStepMin) -> ImplicitEuler __init__(cmf::math::ImplicitEuler self,
Integrator arg2) -> ImplicitEuler  ImplicitEuler(const Integrator &)
copy constructor ";

%feature("docstring")  cmf_core::ImplicitEuler::__call__ "def
__call__(self, t, dt=None, reset=False)

Advances the integration until `t`  A shortcut to .integrate_until
Parameters ---------- t : cmf.Time     The time step to advance to. If
t < current time, the solver will     advance to self.t + t dt :
cmf.Time, optional     The timestep for the integration. If not given
try to integrate in one step reset : bool, optional     If True, the
solver will perform a reset before starting  Returns ------- cmf.Time
The new time stamp ";

%feature("docstring")  cmf_core::ImplicitEuler::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(Integrator self, long position) ->
cmf::math::StateVariable::ptr ";

%feature("docstring")  cmf_core::ImplicitEuler::__len__ "def
__len__(self, args, kwargs)

__len__(Integrator self) -> size_t ";

%feature("docstring")  cmf_core::ImplicitEuler::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::ImplicitEuler::add_single_state "def
add_single_state(self, args, kwargs)

add_single_state(Integrator self, cmf::math::StateVariable::ptr state)
virtual void add_single_state(cmf::math::StateVariable::ptr state)
Adds a single state variable to the integrator. ";

%feature("docstring")  cmf_core::ImplicitEuler::add_states "def
add_states(self, args, kwargs)

add_states(Integrator self, StateVariableOwner stateOwner)  virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)  Add state
variables from a StateVariableOwner. ";

%feature("docstring")  cmf_core::ImplicitEuler::copy "def copy(self,
args, kwargs)

copy(Integrator self) -> Integrator  virtual Integrator* copy() const
=0  Polymorphic copy constructor. ";

%feature("docstring")  cmf_core::ImplicitEuler::get_dt "def
get_dt(self, args, kwargs)

get_dt(Integrator self) -> Time  cmf::math::Time get_dt() const
Returns the last time step. ";

%feature("docstring")  cmf_core::ImplicitEuler::get_dxdt "def
get_dxdt(self, args, kwargs)

get_dxdt(Integrator self, Time time) -> cmf::math::num_array
cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf_core::ImplicitEuler::get_state "def
get_state(self, args, kwargs)

get_state(Integrator self, ptrdiff_t position) -> real  real
get_state(ptrdiff_t position) const  Returns the statevariable at
position Simplifies the assessment of state variables. ";

%feature("docstring")  cmf_core::ImplicitEuler::get_states "def
get_states(self, args)

get_states(Integrator self) -> cmf::math::num_array
get_states(Integrator self) -> StateVariableList  StateVariableList
get_states()  gets the state variables of the integrator ";

%feature("docstring")  cmf_core::ImplicitEuler::get_t "def
get_t(self, args, kwargs)

get_t(Integrator self) -> Time  cmf::math::Time get_t() const  Returns
the current model time. ";

%feature("docstring")  cmf_core::ImplicitEuler::integrate "def
integrate(self, args, kwargs)

integrate(Integrator self, Time t_max, Time dt) -> int  virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)=0  Integrates the
vector of state variables.  Parameters: -----------  t_max:  To stop
the model (if running in a model framework) at time steps of value
exchange e.g. full hours, the next value exchange time can be given
dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf_core::ImplicitEuler::integrate_until "def
integrate_until(self, args, kwargs)

integrate_until(Integrator self, Time t_max, Time dt, bool
reset=False)  void integrate_until(cmf::math::Time t_max,
cmf::math::Time dt=Time(), bool reset=false)  Integrates the vector of
state variables until t_max.  Parameters: -----------  t_max:   Time,
the solver should run to  dt:   Time step (may be omitted)  reset:  If
true, solver is reseted before integration starts ";

%feature("docstring")  cmf_core::ImplicitEuler::reset "def
reset(self, args, kwargs)

reset(Integrator self)  virtual void reset()  Resets any saved history
(for multistep methods) ";

%feature("docstring")  cmf_core::ImplicitEuler::run "def run(self,
start=None, end=None, step=day *1, max_errors=0, reset=False)

Returns an iterator over the timesteps start..end  **Examples:**  >>>
solver=cmf.CVodeIntegrator(...) >>> for t in solver.run(solver.t,
solver.t + cmf.week, cmf.h): >>>    print(t, solver[0].state) or with
list comprehension >>> states = [solver[0].state for t in
solver.run(solver.t, solver.t + cmf.week, cmf.h)]  Parameters
---------- start : cmf.Time, optional Start time for the solver
iteration end : cmf.Time, optional End time of the iteration step :
cmf.Time, optional Step size for the integration max_errors: int
Number of tolerated errors. If >0, up to these number of runtime
errors will be saved with their time and the integration proceeds
after a reset of the solver. Some systems operate with values close to
their physical limits and inifinite values in the integration can
easily occur. For these kind of systems set max_errors to eg. 10. A
larger number of errors should be eliminated usually. reset: bool If
True, the solver performs a `reset` at every time step  Yields ------
cmf.Time      the actual timestep ";

%feature("docstring")  cmf_core::ImplicitEuler::set_state "def
set_state(self, args, kwargs)

set_state(Integrator self, ptrdiff_t position, real newState)  void
set_state(ptrdiff_t position, real newState)  Simplifies the
assessment of state variables. ";

%feature("docstring")  cmf_core::ImplicitEuler::set_t "def
set_t(self, args, kwargs)

set_t(Integrator self, Time val)  void set_t(cmf::math::Time val) Sets
the current model time. ";

%feature("docstring")  cmf_core::ImplicitEuler::size "def size(self,
args, kwargs)

size(Integrator self) -> size_t  size_t size() const  returns the
number of state variables ";


// File: classcmf_1_1math_1_1_implicit_euler.xml
%feature("docstring") cmf::math::ImplicitEuler "

An implicit (backward) Euler integrator using fixpoint iteration.

C++ includes: implicit_euler.h ";

/*  Internal data storages  */

/*  Accuracy parameters  */

/*  model time  */

%feature("docstring")  cmf::math::ImplicitEuler::get_t "cmf::math::Time get_t() const

Returns the current model time. ";

%feature("docstring")  cmf::math::ImplicitEuler::set_t "void
set_t(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::ImplicitEuler::get_dt "cmf::math::Time get_dt() const

Returns the last time step. ";

%feature("docstring")  cmf::math::ImplicitEuler::reset "virtual void
reset()

Resets any saved history (for multistep methods) ";

/*  Integrate  */

%feature("docstring")  cmf::math::ImplicitEuler::integrate_until "void integrate_until(cmf::math::Time t_max, cmf::math::Time dt=Time(),
bool reset=false)

Integrates the vector of state variables until t_max.

Parameters:
-----------

t_max:   Time, the solver should run to

dt:   Time step (may be omitted)

reset:  If true, solver is reseted before integration starts ";

%feature("docstring")  cmf::math::ImplicitEuler::ImplicitEuler "ImplicitEuler(StateVariableOwner &states, real epsilon=1e-9,
cmf::math::Time tStepMin=cmf::math::timespan(10))

Constructs a new FixPointImplicitEuler from a pointer to a vector of
state variables.

The Integrator becomes the owner of states

Parameters:
-----------

states:  Statevariables of the system

epsilon:  relative error tolerance per time step (default=1e-9)

tStepMin:  minimum time step (default=10s) ";

%feature("docstring")  cmf::math::ImplicitEuler::ImplicitEuler "ImplicitEuler(real epsilon=1e-9, cmf::math::Time
tStepMin=cmf::math::timespan(10))

Constructs a new FixPointImplicitEuler.

Parameters:
-----------

epsilon:  relative error tolerance per time step (default=1e-9)

tStepMin:  minimum time step (default=10s) ";

%feature("docstring")  cmf::math::ImplicitEuler::ImplicitEuler "ImplicitEuler(const Integrator &)

copy constructor ";

%feature("docstring")  cmf::math::ImplicitEuler::add_single_state "virtual void add_single_state(cmf::math::StateVariable::ptr state)

Adds a single state variable to the integrator. ";

%feature("docstring")  cmf::math::ImplicitEuler::add_states "void
add_states(cmf::math::StateVariableOwner &stateOwner)

Add state variables from a StateVariableOwner. ";

%feature("docstring")  cmf::math::ImplicitEuler::add_values_to_states
"void add_values_to_states(const num_array &operands)

Adds the values in operands to the current states. ";

%feature("docstring")  cmf::math::ImplicitEuler::copy "virtual
Integrator* copy() const

Polymorphic copy constructor. ";

%feature("docstring")  cmf::math::ImplicitEuler::copy_dxdt "void
copy_dxdt(Time time, num_array &destination, real factor=1) const

Copies the derivatives at time step \"time\" to a numeric vector using
use_OpenMP.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Vector to be overwritten by the results

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::ImplicitEuler::copy_dxdt "void
copy_dxdt(Time time, real *destination, real factor=1) const

Copies the derivatives at time step \"time\" to an preallocated c
array.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Allocated c array

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::ImplicitEuler::copy_states "void
copy_states(num_array &destination) const

Copies the states to a numeric vector using use_OpenMP. ";

%feature("docstring")  cmf::math::ImplicitEuler::copy_states "void
copy_states(real *destination) const ";

%feature("docstring")  cmf::math::ImplicitEuler::get_dxdt "cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf::math::ImplicitEuler::get_state "real
get_state(ptrdiff_t position) const

Returns the statevariable at position Simplifies the assessment of
state variables. ";

%feature("docstring")  cmf::math::ImplicitEuler::get_states "cmf::math::num_array get_states() const ";

%feature("docstring")  cmf::math::ImplicitEuler::get_states "StateVariableList get_states()

gets the state variables of the integrator ";

%feature("docstring")  cmf::math::ImplicitEuler::integrate "int
integrate(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

Integrates the vector of state variables.

Parameters:
-----------

MaxTime:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

TimeStep:  Takes the proposed timestep, and changes it into the
effictivly used timestep according to the local stiffness of the
problem and MaxTime ";

%feature("docstring")  cmf::math::ImplicitEuler::set_state "void
set_state(ptrdiff_t position, real newState)

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::ImplicitEuler::set_states "void
set_states(const num_array &newStates)

Copies the new states to the actual states. ";

%feature("docstring")  cmf::math::ImplicitEuler::set_states "void
set_states(real *newStates) ";

%feature("docstring")  cmf::math::ImplicitEuler::size "size_t size()
const

returns the number of state variables ";


// File: classcmf__core_1_1integratable.xml
%feature("docstring") cmf_core::integratable "

integratable is a functionality for different classes for integrating
values over time.  Main usage of an integratable is the calculation of
average fluxes over time e.g.   .. math::
\\\\\\\\int_{t_0}^{t_{end}}q\\\\\\\\left(t,V_i,V_j\\\\\\\\right)dt C++
includes: statevariable.h ";

%feature("docstring")  cmf_core::integratable::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::integratable::avg "def avg(self,
args, kwargs)

avg(integratable self) -> double  virtual double avg() const =0
Returns average of the integrated variable (eg. flux) from the last
reset until the last call of integrate. ";

%feature("docstring")  cmf_core::integratable::integrate "def
integrate(self, args, kwargs)

integrate(integratable self, Time t)  virtual void integrate(Time t)=0
Integrates the variable until time t. ";

%feature("docstring")  cmf_core::integratable::reset "def reset(self,
args, kwargs)

reset(integratable self, Time t)  virtual void reset(Time t)=0  Sets
the start time of the integral. ";

%feature("docstring")  cmf_core::integratable::sum "def sum(self,
args, kwargs)

sum(integratable self) -> double  virtual double sum() const =0  Get
the integral from the last reset until the last call of integrate. ";


// File: classcmf_1_1math_1_1integratable.xml
%feature("docstring") cmf::math::integratable "

integratable is a functionality for different classes for integrating
values over time.

Main usage of an integratable is the calculation of average fluxes
over time e.g. 

.. math::

    
    \\\\int_{t_0}^{t_{end}}q\\\\left(t,V_i,V_j\\\\right)dt 

C++ includes: statevariable.h ";

%feature("docstring")  cmf::math::integratable::avg "virtual double
avg() const =0

Returns average of the integrated variable (eg. flux) from the last
reset until the last call of integrate. ";

%feature("docstring")  cmf::math::integratable::integrate "virtual
void integrate(Time t)=0

Integrates the variable until time t. ";

%feature("docstring")  cmf::math::integratable::reset "virtual void
reset(Time t)=0

Sets the start time of the integral. ";

%feature("docstring")  cmf::math::integratable::sum "virtual double
sum() const =0

Get the integral from the last reset until the last call of integrate.
";


// File: classcmf__core_1_1integratable__list.xml
%feature("docstring") cmf_core::integratable_list "

A list of cmf::math::integratable objects.  Todo TODO: Complete
collection interface (getitem with slicing etc.)  C++ includes:
statevariable.h ";

%feature("docstring")  cmf_core::integratable_list::__init__ "def
__init__(self, args)

__init__(cmf::math::integratable_list self) -> integratable_list
__init__(cmf::math::integratable_list self, integratable_list
for_copy) -> integratable_list  integratable_list(const
integratable_list &for_copy) ";

%feature("docstring")  cmf_core::integratable_list::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::integratable_list::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::integratable_list::__len__ "def
__len__(self, args, kwargs)

__len__(integratable_list self) -> size_t ";

%feature("docstring")  cmf_core::integratable_list::append "def
append(self, args, kwargs)

append(integratable_list self, cmf::math::integratable::ptr add)  void
append(cmf::math::integratable::ptr add)  Adds an integratable to the
list. ";

%feature("docstring")  cmf_core::integratable_list::avg "def
avg(self, args, kwargs)

avg(integratable_list self) -> cmf::math::num_array
cmf::math::num_array avg() const ";

%feature("docstring")  cmf_core::integratable_list::integrate "def
integrate(self, args, kwargs)

integrate(integratable_list self, Time t)  void integrate(Time t) ";

%feature("docstring")  cmf_core::integratable_list::remove "def
remove(self, args, kwargs)

remove(integratable_list self, cmf::math::integratable::ptr rm)  void
remove(cmf::math::integratable::ptr rm)  Removes an integratable from
the list. ";

%feature("docstring")  cmf_core::integratable_list::reset "def
reset(self, args, kwargs)

reset(integratable_list self, Time t)  void reset(Time t) ";

%feature("docstring")  cmf_core::integratable_list::size "def
size(self, args, kwargs)

size(integratable_list self) -> size_t  size_t size() const  Number of
integratables in the list. ";

%feature("docstring")  cmf_core::integratable_list::sum "def
sum(self, args, kwargs)

sum(integratable_list self) -> cmf::math::num_array
cmf::math::num_array sum() const ";


// File: classcmf_1_1math_1_1integratable__list.xml
%feature("docstring") cmf::math::integratable_list "

A list of cmf::math::integratable objects.

Todo TODO: Complete collection interface (getitem with slicing etc.)

C++ includes: statevariable.h ";

%feature("docstring")  cmf::math::integratable_list::integratable_list
"integratable_list() ";

%feature("docstring")  cmf::math::integratable_list::integratable_list
"integratable_list(const integratable_list &for_copy) ";

%feature("docstring")  cmf::math::integratable_list::append "void
append(cmf::math::integratable::ptr add)

Adds an integratable to the list. ";

%feature("docstring")  cmf::math::integratable_list::avg "cmf::math::num_array avg() const ";

%feature("docstring")  cmf::math::integratable_list::integrate "void
integrate(Time t) ";

%feature("docstring")  cmf::math::integratable_list::remove "void
remove(cmf::math::integratable::ptr rm)

Removes an integratable from the list. ";

%feature("docstring")  cmf::math::integratable_list::reset "void
reset(Time t) ";

%feature("docstring")  cmf::math::integratable_list::size "size_t
size() const

Number of integratables in the list. ";

%feature("docstring")  cmf::math::integratable_list::sum "cmf::math::num_array sum() const ";


// File: classcmf__core_1_1_integrator.xml
%feature("docstring") cmf_core::Integrator "

Base class for any kind of integrator.  Pure virtual functions:
Integrate  copy Please provide a custom copy constructor  C++
includes: integrator.h ";

%feature("docstring")  cmf_core::Integrator::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::Integrator::__call__ "def
__call__(self, t, dt=None, reset=False)

Advances the integration until `t`  A shortcut to .integrate_until
Parameters ---------- t : cmf.Time     The time step to advance to. If
t < current time, the solver will     advance to self.t + t dt :
cmf.Time, optional     The timestep for the integration. If not given
try to integrate in one step reset : bool, optional     If True, the
solver will perform a reset before starting  Returns ------- cmf.Time
The new time stamp ";

%feature("docstring")  cmf_core::Integrator::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(Integrator self, long position) ->
cmf::math::StateVariable::ptr ";

%feature("docstring")  cmf_core::Integrator::__len__ "def
__len__(self, args, kwargs)

__len__(Integrator self) -> size_t ";

%feature("docstring")  cmf_core::Integrator::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::Integrator::add_single_state "def
add_single_state(self, args, kwargs)

add_single_state(Integrator self, cmf::math::StateVariable::ptr state)
virtual void add_single_state(cmf::math::StateVariable::ptr state)
Adds a single state variable to the integrator. ";

%feature("docstring")  cmf_core::Integrator::add_states "def
add_states(self, args, kwargs)

add_states(Integrator self, StateVariableOwner stateOwner)  virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)  Add state
variables from a StateVariableOwner. ";

%feature("docstring")  cmf_core::Integrator::copy "def copy(self,
args, kwargs)

copy(Integrator self) -> Integrator  virtual Integrator* copy() const
=0  Polymorphic copy constructor. ";

%feature("docstring")  cmf_core::Integrator::get_dt "def get_dt(self,
args, kwargs)

get_dt(Integrator self) -> Time  cmf::math::Time get_dt() const
Returns the last time step. ";

%feature("docstring")  cmf_core::Integrator::get_dxdt "def
get_dxdt(self, args, kwargs)

get_dxdt(Integrator self, Time time) -> cmf::math::num_array
cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf_core::Integrator::get_state "def
get_state(self, args, kwargs)

get_state(Integrator self, ptrdiff_t position) -> real  real
get_state(ptrdiff_t position) const  Returns the statevariable at
position Simplifies the assessment of state variables. ";

%feature("docstring")  cmf_core::Integrator::get_states "def
get_states(self, args)

get_states(Integrator self) -> cmf::math::num_array
get_states(Integrator self) -> StateVariableList  StateVariableList
get_states()  gets the state variables of the integrator ";

%feature("docstring")  cmf_core::Integrator::get_t "def get_t(self,
args, kwargs)

get_t(Integrator self) -> Time  cmf::math::Time get_t() const  Returns
the current model time. ";

%feature("docstring")  cmf_core::Integrator::integrate "def
integrate(self, args, kwargs)

integrate(Integrator self, Time t_max, Time dt) -> int  virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)=0  Integrates the
vector of state variables.  Parameters: -----------  t_max:  To stop
the model (if running in a model framework) at time steps of value
exchange e.g. full hours, the next value exchange time can be given
dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf_core::Integrator::integrate_until "def
integrate_until(self, args, kwargs)

integrate_until(Integrator self, Time t_max, Time dt, bool
reset=False)  void integrate_until(cmf::math::Time t_max,
cmf::math::Time dt=Time(), bool reset=false)  Integrates the vector of
state variables until t_max.  Parameters: -----------  t_max:   Time,
the solver should run to  dt:   Time step (may be omitted)  reset:  If
true, solver is reseted before integration starts ";

%feature("docstring")  cmf_core::Integrator::reset "def reset(self,
args, kwargs)

reset(Integrator self)  virtual void reset()  Resets any saved history
(for multistep methods) ";

%feature("docstring")  cmf_core::Integrator::run "def run(self,
start=None, end=None, step=day *1, max_errors=0, reset=False)

Returns an iterator over the timesteps start..end  **Examples:**  >>>
solver=cmf.CVodeIntegrator(...) >>> for t in solver.run(solver.t,
solver.t + cmf.week, cmf.h): >>>    print(t, solver[0].state) or with
list comprehension >>> states = [solver[0].state for t in
solver.run(solver.t, solver.t + cmf.week, cmf.h)]  Parameters
---------- start : cmf.Time, optional Start time for the solver
iteration end : cmf.Time, optional End time of the iteration step :
cmf.Time, optional Step size for the integration max_errors: int
Number of tolerated errors. If >0, up to these number of runtime
errors will be saved with their time and the integration proceeds
after a reset of the solver. Some systems operate with values close to
their physical limits and inifinite values in the integration can
easily occur. For these kind of systems set max_errors to eg. 10. A
larger number of errors should be eliminated usually. reset: bool If
True, the solver performs a `reset` at every time step  Yields ------
cmf.Time      the actual timestep ";

%feature("docstring")  cmf_core::Integrator::set_state "def
set_state(self, args, kwargs)

set_state(Integrator self, ptrdiff_t position, real newState)  void
set_state(ptrdiff_t position, real newState)  Simplifies the
assessment of state variables. ";

%feature("docstring")  cmf_core::Integrator::set_t "def set_t(self,
args, kwargs)

set_t(Integrator self, Time val)  void set_t(cmf::math::Time val) Sets
the current model time. ";

%feature("docstring")  cmf_core::Integrator::size "def size(self,
args, kwargs)

size(Integrator self) -> size_t  size_t size() const  returns the
number of state variables ";


// File: classcmf_1_1math_1_1_integrator.xml
%feature("docstring") cmf::math::Integrator "

Base class for any kind of integrator.

Pure virtual functions: Integrate

copy Please provide a custom copy constructor

C++ includes: integrator.h ";

/*  Accuracy parameters  */

/*  model time  */

%feature("docstring")  cmf::math::Integrator::get_t "cmf::math::Time
get_t() const

Returns the current model time. ";

%feature("docstring")  cmf::math::Integrator::set_t "void
set_t(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::Integrator::get_dt "cmf::math::Time
get_dt() const

Returns the last time step. ";

%feature("docstring")  cmf::math::Integrator::reset "virtual void
reset()

Resets any saved history (for multistep methods) ";

/*  Constructors and Destructors  */

%feature("docstring")  cmf::math::Integrator::Integrator "Integrator(real epsilon=1e-9)

Constructs a new Integrator with a new own state vector.

Parameters:
-----------

epsilon:  relative error tolerance per time step (default=1e-9) ";

%feature("docstring")  cmf::math::Integrator::Integrator "Integrator(cmf::math::StateVariableOwner &states, real epsilon=1e-9)
";

%feature("docstring")  cmf::math::Integrator::Integrator "Integrator(const cmf::math::Integrator &other) ";

%feature("docstring")  cmf::math::Integrator::copy "virtual
Integrator* copy() const =0

Polymorphic copy constructor. ";

/*  Integrate  */

%feature("docstring")  cmf::math::Integrator::integrate "virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)=0

Integrates the vector of state variables.

Parameters:
-----------

t_max:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf::math::Integrator::integrate_until "void
integrate_until(cmf::math::Time t_max, cmf::math::Time dt=Time(), bool
reset=false)

Integrates the vector of state variables until t_max.

Parameters:
-----------

t_max:   Time, the solver should run to

dt:   Time step (may be omitted)

reset:  If true, solver is reseted before integration starts ";

%feature("docstring")  cmf::math::Integrator::~Integrator "virtual
~Integrator() ";

%feature("docstring")  cmf::math::Integrator::add_single_state "virtual void add_single_state(cmf::math::StateVariable::ptr state)

Adds a single state variable to the integrator. ";

%feature("docstring")  cmf::math::Integrator::add_states "virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)

Add state variables from a StateVariableOwner. ";

%feature("docstring")  cmf::math::Integrator::add_values_to_states "void add_values_to_states(const num_array &operands)

Adds the values in operands to the current states. ";

%feature("docstring")  cmf::math::Integrator::copy_dxdt "void
copy_dxdt(Time time, num_array &destination, real factor=1) const

Copies the derivatives at time step \"time\" to a numeric vector using
use_OpenMP.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Vector to be overwritten by the results

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::Integrator::copy_dxdt "void
copy_dxdt(Time time, real *destination, real factor=1) const

Copies the derivatives at time step \"time\" to an preallocated c
array.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Allocated c array

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::Integrator::copy_states "void
copy_states(num_array &destination) const

Copies the states to a numeric vector using use_OpenMP. ";

%feature("docstring")  cmf::math::Integrator::copy_states "void
copy_states(real *destination) const ";

%feature("docstring")  cmf::math::Integrator::get_dxdt "cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf::math::Integrator::get_state "real
get_state(ptrdiff_t position) const

Returns the statevariable at position Simplifies the assessment of
state variables. ";

%feature("docstring")  cmf::math::Integrator::get_states "cmf::math::num_array get_states() const ";

%feature("docstring")  cmf::math::Integrator::get_states "StateVariableList get_states()

gets the state variables of the integrator ";

%feature("docstring")  cmf::math::Integrator::set_state "void
set_state(ptrdiff_t position, real newState)

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::Integrator::set_states "void
set_states(const num_array &newStates)

Copies the new states to the actual states. ";

%feature("docstring")  cmf::math::Integrator::set_states "void
set_states(real *newStates) ";

%feature("docstring")  cmf::math::Integrator::size "size_t size()
const

returns the number of state variables ";


// File: classcmf_1_1math_1_1root__finding_1_1iteration__error.xml
%feature("docstring") cmf::math::root_finding::iteration_error "";

%feature("docstring")
cmf::math::root_finding::iteration_error::iteration_error "iteration_error(const std::string &msg) ";


// File: classcmf_1_1river_1_1_i_volume_height_function.xml
%feature("docstring") cmf::river::IVolumeHeightFunction "

Volume height relations are functional objects, which return a height
and a crosssectional area of a volume for different geometric bodies.

This is the abstract base class, where the geometries derive from

C++ includes: ReachType.h ";

%feature("docstring")
cmf::river::IVolumeHeightFunction::~IVolumeHeightFunction "virtual
~IVolumeHeightFunction() ";

%feature("docstring")  cmf::river::IVolumeHeightFunction::A "virtual
double A(double V) const =0

Returns the area of the surface for a given volume. ";

%feature("docstring")  cmf::river::IVolumeHeightFunction::copy "virtual IVolumeHeightFunction* copy() const =0 ";

%feature("docstring")  cmf::river::IVolumeHeightFunction::h "virtual
double h(double V) const =0

Returns the depth of a given volume. ";

%feature("docstring")  cmf::river::IVolumeHeightFunction::q "virtual
double q(double h, double slope) const ";

%feature("docstring")  cmf::river::IVolumeHeightFunction::V "virtual
double V(double h) const =0 ";


// File: classcmf__core_1_1_i_volume_height_function.xml
%feature("docstring") cmf_core::IVolumeHeightFunction "

Volume height relations are functional objects, which return a height
and a crosssectional area of a volume for different geometric bodies.
This is the abstract base class, where the geometries derive from  C++
includes: ReachType.h ";

%feature("docstring")  cmf_core::IVolumeHeightFunction::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::IVolumeHeightFunction::A "def
A(self, args, kwargs)

A(IVolumeHeightFunction self, double V) -> double  virtual double
A(double V) const =0  Returns the area of the surface for a given
volume. ";

%feature("docstring")  cmf_core::IVolumeHeightFunction::copy "def
copy(self, args, kwargs)

copy(IVolumeHeightFunction self) -> IVolumeHeightFunction  virtual
IVolumeHeightFunction* copy() const =0 ";

%feature("docstring")  cmf_core::IVolumeHeightFunction::h "def
h(self, args, kwargs)

h(IVolumeHeightFunction self, double V) -> double  virtual double
h(double V) const =0  Returns the depth of a given volume. ";

%feature("docstring")  cmf_core::IVolumeHeightFunction::q "def
q(self, args, kwargs)

q(IVolumeHeightFunction self, double h, double slope) -> double
virtual double q(double h, double slope) const ";

%feature("docstring")  cmf_core::IVolumeHeightFunction::V "def
V(self, args, kwargs)

V(IVolumeHeightFunction self, double h) -> double  virtual double
V(double h) const =0 ";


// File: classcmf_1_1jacobian_1_1_jacobian.xml
%feature("docstring") cmf::jacobian::Jacobian "

Approximates the jacobian for a cmf solver J[i,j] =
(dxdt(S_i,t)[j]-dxdt(S,t)[j])/delta S is the state vector S_i equals
S, except for S_i[i]=S[i]+delta delta is the finite difference to
approximate the Jacobian.     delta should be a small number, but big
enough to avoid floating point errors.      1e-6 to 1e-9 should be
nice values  Usage to show the jacobian:     # Allocate memory for the
jacobian     jac = Jacobian(solver,delta)     # Calculate the Jacobian
J = jac()     # Show the Jacobian
imshow(jac(),interpolation='nearest') ";

%feature("docstring")  cmf::jacobian::Jacobian::__init__ "def
__init__(self, solver, delta=1e-6)

solver is a cmf integrator, delta is the amount the state should be
changed ";

%feature("docstring")  cmf::jacobian::Jacobian::__call__ "def
__call__(self) ";

%feature("docstring")  cmf::jacobian::Jacobian::__len__ "def
__len__(self) ";

%feature("docstring")  cmf::jacobian::Jacobian::dxdt "def dxdt(self)

Returns the current right hand side of the ODE for the current states
and the current time ";

%feature("docstring")  cmf::jacobian::Jacobian::t "def t(self) ";


// File: classcmf_1_1upslope_1_1connections_1_1_jarvis_macro_flow.xml
%feature("docstring") cmf::upslope::connections::JarvisMacroFlow "

A physically based macropore to macropore connection according to
Jarvis & Leeds-Harrison 1987, JSS.



.. math::

    q_{i->j} [m/s]= \\\\rho \\\\frac G {12\\\\eta} w^2 \\\\frac{e_v-
    e_r}{1-e_r} S_{c,i}^\\\\beta\\\\ (1-S_{c,j})

where:  :math:`q_{i->j}`
the flow from macro pore layer i to macropore layer j

:math:`\\\\rho=10^{-3} kg/m^3` - the density of water

:math:`G=9.81 m/s^2` the earth acceleration

:math:`\\\\eta=1.0 kg/(m s)` the viscosity of water (at 20 degC)

:math:`w [m]` the crack width, a function of water content and crack
distance

:math:`e_v [-]` the crack porosity

:math:`e_r [-]` crack por

:math:`S_c [-]` the crack saturation of layer i resp. j

:math:`\\\\beta [-]` a conceptional exponent to shape the flow reaction

C++ includes: macropore.h ";

%feature("docstring")
cmf::upslope::connections::JarvisMacroFlow::JarvisMacroFlow "JarvisMacroFlow(cmf::water::WaterStorage::ptr left,
cmf::water::flux_node::ptr right, real beta=1., real
porefraction_r=0.0)

Constructs the connection.

Parameters:
-----------

left:  right:  the connected macropores

beta:  User defined parameter for the swelling reaction

porefraction_r:  Porefraction at which flow starts. For swelling soils
that are closing completely th ";

%feature("docstring")
cmf::upslope::connections::JarvisMacroFlow::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::JarvisMacroFlow::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::upslope::connections::JarvisMacroFlow::get_ptr "ptr get_ptr()
const ";

%feature("docstring")
cmf::upslope::connections::JarvisMacroFlow::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::JarvisMacroFlow::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::JarvisMacroFlow::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::JarvisMacroFlow::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::JarvisMacroFlow::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::JarvisMacroFlow::left_node "flux_node::ptr
left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::connections::JarvisMacroFlow::q "real q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::JarvisMacroFlow::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::JarvisMacroFlow::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::JarvisMacroFlow::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::JarvisMacroFlow::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::JarvisMacroFlow::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::JarvisMacroFlow::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_jarvis_macro_flow.xml
%feature("docstring") cmf_core::JarvisMacroFlow "

A physically based macropore to macropore connection according to
Jarvis & Leeds-Harrison 1987, JSS.    .. math::      q_{i->j} [m/s]=
\\\\\\\\rho \\\\\\\\frac G {12\\\\\\\\eta} w^2 \\\\\\\\frac{e_v-
e_r}{1-e_r} S_{c,i}^\\\\\\\\beta\\\\\\\\ (1-S_{c,j})  where:
:math:`q_{i->j}` the flow from macro pore layer i to macropore layer j
:math:`\\\\\\\\rho=10^{-3} kg/m^3` - the density of water
:math:`G=9.81 m/s^2` the earth acceleration  :math:`\\\\\\\\eta=1.0
kg/(m s)` the viscosity of water (at 20 degC)  :math:`w [m]` the crack
width, a function of water content and crack distance  :math:`e_v [-]`
the crack porosity  :math:`e_r [-]` crack por  :math:`S_c [-]` the
crack saturation of layer i resp. j  :math:`\\\\\\\\beta [-]` a
conceptional exponent to shape the flow reaction  C++ includes:
macropore.h ";

%feature("docstring")  cmf_core::JarvisMacroFlow::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::JarvisMacroFlow self,
cmf::water::WaterStorage::ptr left, cmf::water::flux_node::ptr right,
real beta=1., real porefraction_r=0.0) -> JarvisMacroFlow
JarvisMacroFlow(cmf::water::WaterStorage::ptr left,
cmf::water::flux_node::ptr right, real beta=1., real
porefraction_r=0.0)  Constructs the connection.  Parameters:
-----------  left:  right:  the connected macropores  beta:  User
defined parameter for the swelling reaction  porefraction_r:
Porefraction at which flow starts. For swelling soils that are closing
completely th ";

%feature("docstring")  cmf_core::JarvisMacroFlow::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::JarvisMacroFlow::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::JarvisMacroFlow::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::JarvisMacroFlow::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::JarvisMacroFlow::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::JarvisMacroFlow::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::JarvisMacroFlow::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::JarvisMacroFlow::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::JarvisMacroFlow::get_tracer_filter "def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::JarvisMacroFlow::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::JarvisMacroFlow::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::JarvisMacroFlow::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::JarvisMacroFlow::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::JarvisMacroFlow::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::JarvisMacroFlow::set_tracer_filter "def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::JarvisMacroFlow::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::JarvisMacroFlow::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf__core_1_1kinematic__wave.xml
%feature("docstring") cmf_core::kinematic_wave "

Calculates flux out of a storage as a linear function of its volume to
a power.  Deprecated  kinematic_wave is superseeded by
LinearStorageConnection and PowerLawConnection    .. math::       q =
\\\\\\\\frac 1 {t_r} {\\\\\\\\left(\\\\\\\\frac{V - V_{residual}}{V_0}
\\\\\\\\right)^\\\\\\\\beta}   where:  :math:`V_{residual} [m^3]` The
volume of water not flowing out (default = 0)  :math:`V_0` The
reference volume to scale the exponent (default = 1m3/day)
:math:`\\\\\\\\beta` A parameter to shape the response curve. In case
of :math:`\\\\\\\\beta \\\\\\\\neq 1`, :math:`t_r` is not a residence
time, but just a parameter.  :math:`t_r [days]` The residence time of
the water in this storage in days  WARNING:   :math:`\\\\\\\\beta <
0.5` may lead to numerical troubles and have a dubious hydrological
meaning. Please avoid.  C++ includes: simple_connections.h ";

%feature("docstring")  cmf_core::kinematic_wave::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::water::kinematic_wave self,
cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr
target, real residencetime, real exponent=1.0, real residual=0.0, real
V0=1.0) -> kinematic_wave  kinematic_wave(WaterStorage::ptr source,
flux_node::ptr target, real residencetime, real exponent=1.0, real
residual=0.0, real V0=1.0)  Creates a kinematic wave connection.    ..
math::       q = \\\\\\\\frac 1 {t_r} {\\\\\\\\left(\\\\\\\\frac{V -
V_{residual}}{V_0}     \\\\\\\\right)^\\\\\\\\beta}   Parameters:
-----------  source:  Water storage from which the water flows out.
Flux is a function of source.volume  target:  Target node (boundary
condition or storage). Does not influence the strength of the flow
residencetime:   :math:`t_r [days]` The residence time of the water in
this storage  exponent:   :math:`\\\\\\\\beta [-]` An empirical
exponent to shape the flux function (default = 1 (linear function))
residual:   :math:`V_{residual} [m^3]` The volume of water not flowing
out (default = 0)  V0:   :math:`V_0` The reference volume to scale the
exponent ";

%feature("docstring")  cmf_core::kinematic_wave::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::kinematic_wave::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::kinematic_wave::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::kinematic_wave::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::kinematic_wave::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::kinematic_wave::conc "def conc(self,
args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::kinematic_wave::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::kinematic_wave::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::kinematic_wave::get_tracer_filter "def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::kinematic_wave::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::kinematic_wave::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::kinematic_wave::q "def q(self, args,
kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::kinematic_wave::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::kinematic_wave::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::kinematic_wave::set_tracer_filter "def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::kinematic_wave::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::kinematic_wave::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1water_1_1kinematic__wave.xml
%feature("docstring") cmf::water::kinematic_wave "

Calculates flux out of a storage as a linear function of its volume to
a power.

Deprecated  kinematic_wave is superseeded by LinearStorageConnection
and PowerLawConnection



.. math::

     q = \\\\frac 1 {t_r} {\\\\left(\\\\frac{V - V_{residual}}{V_0}
    \\\\right)^\\\\beta} 

where:  :math:`V_{residual} [m^3]` The volume of
water not flowing out (default = 0)

:math:`V_0` The reference volume to scale the exponent (default = 1m3/day)

:math:`\\\\beta` A parameter to shape the response curve. In case of
:math:`\\\\beta \\\\neq 1`, :math:`t_r` is not a residence time, but just a
parameter.

:math:`t_r [days]` The residence time of the water in this storage in days

WARNING:   :math:`\\\\beta < 0.5` may lead to numerical troubles and have a
dubious hydrological meaning. Please avoid.

C++ includes: simple_connections.h ";

%feature("docstring")  cmf::water::kinematic_wave::kinematic_wave "kinematic_wave(WaterStorage::ptr source, flux_node::ptr target, real
residencetime, real exponent=1.0, real residual=0.0, real V0=1.0)

Creates a kinematic wave connection.



.. math::

     q = \\\\frac 1 {t_r} {\\\\left(\\\\frac{V - V_{residual}}{V_0}
    \\\\right)^\\\\beta} 

Parameters:
-----------

source:  Water storage from which the water flows out. Flux is a
function of source.volume

target:  Target node (boundary condition or storage). Does not
influence the strength of the flow

residencetime:   :math:`t_r [days]` The residence time of the water in this
storage

exponent:   :math:`\\\\beta [-]` An empirical exponent to shape the flux
function (default = 1 (linear function))

residual:   :math:`V_{residual} [m^3]` The volume of water not flowing out
(default = 0)

V0:   :math:`V_0` The reference volume to scale the exponent ";

%feature("docstring")  cmf::water::kinematic_wave::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")  cmf::water::kinematic_wave::exchange_target "void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")  cmf::water::kinematic_wave::get_ptr "ptr
get_ptr() const ";

%feature("docstring")  cmf::water::kinematic_wave::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::water::kinematic_wave::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")  cmf::water::kinematic_wave::get_tracer_filter "real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")  cmf::water::kinematic_wave::get_tracer_filter "real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::water::kinematic_wave::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::water::kinematic_wave::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::water::kinematic_wave::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::water::kinematic_wave::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::water::kinematic_wave::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")  cmf::water::kinematic_wave::set_tracer_filter "void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")  cmf::water::kinematic_wave::set_tracer_filter "void set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf::water::kinematic_wave::short_string "virtual std::string short_string() const ";

%feature("docstring")  cmf::water::kinematic_wave::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_kinematic_macro_flow.xml
%feature("docstring") cmf_core::KinematicMacroFlow "

Linear storage based flux from macro pore to macro pore.  Deprecated
The MacroPore model is still very experimental and not stable. Only
for tryouts!    .. math::       q = A_{cell} K_{macro}
\\\\\\\\left(\\\\\\\\frac{V_{upper}}{C_{upper}}\\\\\\\\right)^\\\\\\\\beta
\\\\\\\\left(1-\\\\\\\\frac{V_{lower}}{C_{lower}}\\\\\\\\right) where:
:math:`A_{cell}` is the area of the owning cell in m2
:math:`K_{macro}` is the conductivity of the macro pore storage
:math:`V` is the actual stored water volume in the upper resp. lower
macro pore storage  :math:`C` is the capacity of the upper resp. lower
macro pore storage  C++ includes: macropore.h ";

%feature("docstring")  cmf_core::KinematicMacroFlow::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::KinematicMacroFlow self,
cmf::water::WaterStorage::ptr left, cmf::water::flux_node::ptr right,
real beta=1.) -> KinematicMacroFlow
KinematicMacroFlow(cmf::water::WaterStorage::ptr left,
cmf::water::flux_node::ptr right, real beta=1.)  Creates the
connection.  Parameters: -----------  left:  right:  the nodes between
the connection should be created.  beta:  a conceptional curve shape
parameter for the relation between storage and outflow  Either left or
right needs to be a MacroPore, left needs to be a water storage ";

%feature("docstring")  cmf_core::KinematicMacroFlow::__contains__ "def __contains__(self, cmp) ";

%feature("docstring")  cmf_core::KinematicMacroFlow::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::KinematicMacroFlow::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::KinematicMacroFlow::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::KinematicMacroFlow::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::KinematicMacroFlow::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::KinematicMacroFlow::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::KinematicMacroFlow::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::KinematicMacroFlow::get_tracer_filter
"def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::KinematicMacroFlow::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::KinematicMacroFlow::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::KinematicMacroFlow::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::KinematicMacroFlow::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::KinematicMacroFlow::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::KinematicMacroFlow::set_tracer_filter
"def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::KinematicMacroFlow::short_string "def short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::KinematicMacroFlow::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1connections_1_1_kinematic_macro_flow.xml
%feature("docstring") cmf::upslope::connections::KinematicMacroFlow "

Linear storage based flux from macro pore to macro pore.

Deprecated The MacroPore model is still very experimental and not
stable. Only for tryouts!



.. math::

     q = A_{cell} K_{macro}
    \\\\left(\\\\frac{V_{upper}}{C_{upper}}\\\\right)^\\\\beta
    \\\\left(1-\\\\frac{V_{lower}}{C_{lower}}\\\\right) 

where:
:math:`A_{cell}` is the area of the owning cell in m2

:math:`K_{macro}` is the conductivity of the macro pore storage

:math:`V` is the actual stored water volume in the upper resp. lower macro
pore storage

:math:`C` is the capacity of the upper resp. lower macro pore storage

C++ includes: macropore.h ";

%feature("docstring")
cmf::upslope::connections::KinematicMacroFlow::KinematicMacroFlow "KinematicMacroFlow(cmf::water::WaterStorage::ptr left,
cmf::water::flux_node::ptr right, real beta=1.)

Creates the connection.

Parameters:
-----------

left:  right:  the nodes between the connection should be created.

beta:  a conceptional curve shape parameter for the relation between
storage and outflow

Either left or right needs to be a MacroPore, left needs to be a water
storage ";

%feature("docstring")
cmf::upslope::connections::KinematicMacroFlow::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::KinematicMacroFlow::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::upslope::connections::KinematicMacroFlow::get_ptr "ptr get_ptr()
const ";

%feature("docstring")
cmf::upslope::connections::KinematicMacroFlow::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::KinematicMacroFlow::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::KinematicMacroFlow::get_tracer_filter "real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::KinematicMacroFlow::get_tracer_filter "real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::KinematicMacroFlow::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::KinematicMacroFlow::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")
cmf::upslope::connections::KinematicMacroFlow::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::KinematicMacroFlow::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::KinematicMacroFlow::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::KinematicMacroFlow::set_tracer_filter "void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::KinematicMacroFlow::set_tracer_filter "void set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::KinematicMacroFlow::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::KinematicMacroFlow::to_string "virtual
std::string to_string() const ";


// File: classcmf_1_1upslope_1_1connections_1_1_kinematic_surface_runoff.xml
%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff "

A connection to route water from a SurfaceWater storage to another
node following a topographic gradient.



.. math::

    q_{runoff} = A_{cross} d_{eff}^{2/3}
    \\\\frac{\\\\sqrt{S}}{n}

where:  :math:`q_{runoff}` is the surface
runoff

:math:`A_{cross}` is the wetted crossectional flux area, given as :math:`d_{eff} \\\\cdot w`

:math:`w` is the width of the shared boundary between the surface water
storage and the target node

:math:`d_{eff}` is the effective flow depth of the surface water.The
effective flow depth is defined as 

.. math::

    d_{eff} = \\\\begin{cases}
    V/A-d_{puddle}\\\\ & V/A>d_{puddle} \\\\\\\\ 0.0 & V/A<=d_{puddle}
    \\\\end{cases}

:math:`V` the volume of stored water in the surface in :math:`m^3`

:math:`A` the area of the cell in :math:`m^2`

:math:`d_{puddle}=V_{puddle}/A` the average depth of water in the surface
water needed to start run off

:math:`S = \\\\|\\\\frac{\\\\Delta z\\\\|}{d}` the slope between
surfacewater center and the target node

:math:`n` the manning roughness

The KinematicSurfaceRunoff can be used as a cell connecting flux as
in: This results in a connection of the surfacewater storage of each
cell with the surface water storages of its neighborssee

C++ includes: surfacewater.h ";

%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff::KinematicSurfaceRunoff
"KinematicSurfaceRunoff(cmf::upslope::SurfaceWater::ptr left,
cmf::water::flux_node::ptr right, real flowwidth, real distance=-1)

Creates a KinematicSurfaceRunoff between a SurfaceWater (left) with
another (right) node.

Parameters:
-----------

left:  A surfacewater storage

right:  The target node

flowwidth:  the length of the shared boundary between left and right
in m

distance:  the distance between left and right in m. If d<=0m, the
distance is calculated according to the position of left and right ";

%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff::exchange_target "void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff::get_ptr "ptr
get_ptr() const ";

%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff::get_tracer_filter "real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff::get_tracer_filter "real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff::set_tracer_filter "void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff::set_tracer_filter "void set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff::short_string "virtual std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::KinematicSurfaceRunoff::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_kinematic_surface_runoff.xml
%feature("docstring") cmf_core::KinematicSurfaceRunoff "

A connection to route water from a SurfaceWater storage to another
node following a topographic gradient.    .. math::      q_{runoff} =
A_{cross} d_{eff}^{2/3}     \\\\\\\\frac{\\\\\\\\sqrt{S}}{n}  where:
:math:`q_{runoff}` is the surface runoff  :math:`A_{cross}` is the
wetted crossectional flux area, given as :math:`d_{eff} \\\\\\\\cdot
w`  :math:`w` is the width of the shared boundary between the surface
water storage and the target node  :math:`d_{eff}` is the effective
flow depth of the surface water.The effective flow depth is defined as
.. math::      d_{eff} = \\\\\\\\begin{cases} V/A-d_{puddle}\\\\\\\\ &
V/A>d_{puddle} \\\\\\\\\\\\\\\\ 0.0 & V/A<=d_{puddle}
\\\\\\\\end{cases}  :math:`V` the volume of stored water in the
surface in :math:`m^3`  :math:`A` the area of the cell in :math:`m^2`
:math:`d_{puddle}=V_{puddle}/A` the average depth of water in the
surface water needed to start run off  :math:`S =
\\\\\\\\|\\\\\\\\frac{\\\\\\\\Delta z\\\\\\\\|}{d}` the slope between
surfacewater center and the target node  :math:`n` the manning
roughness  The KinematicSurfaceRunoff can be used as a cell connecting
flux as in: This results in a connection of the surfacewater storage
of each cell with the surface water storages of its neighborssee  C++
includes: surfacewater.h ";

%feature("docstring")  cmf_core::KinematicSurfaceRunoff::__init__ "def __init__(self, args, kwargs)

__init__(cmf::upslope::connections::KinematicSurfaceRunoff self,
cmf::upslope::SurfaceWater::ptr left, cmf::water::flux_node::ptr
right, real flowwidth, real distance=-1) -> KinematicSurfaceRunoff
KinematicSurfaceRunoff(cmf::upslope::SurfaceWater::ptr left,
cmf::water::flux_node::ptr right, real flowwidth, real distance=-1)
Creates a KinematicSurfaceRunoff between a SurfaceWater (left) with
another (right) node.  Parameters: -----------  left:  A surfacewater
storage  right:  The target node  flowwidth:  the length of the shared
boundary between left and right in m  distance:  the distance between
left and right in m. If d<=0m, the distance is calculated according to
the position of left and right ";

%feature("docstring")  cmf_core::KinematicSurfaceRunoff::__contains__
"def __contains__(self, cmp) ";

%feature("docstring")  cmf_core::KinematicSurfaceRunoff::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::KinematicSurfaceRunoff::__getitem__ "def __getitem__(self, index) ";

%feature("docstring")  cmf_core::KinematicSurfaceRunoff::__iter__ "def __iter__(self) ";

%feature("docstring")  cmf_core::KinematicSurfaceRunoff::__repr__ "def __repr__(self) ";

%feature("docstring")  cmf_core::KinematicSurfaceRunoff::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::KinematicSurfaceRunoff::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::KinematicSurfaceRunoff::get_target "def get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::KinematicSurfaceRunoff::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::KinematicSurfaceRunoff::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::KinematicSurfaceRunoff::left_node "def left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::KinematicSurfaceRunoff::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::KinematicSurfaceRunoff::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::KinematicSurfaceRunoff::right_node "def right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::KinematicSurfaceRunoff::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::KinematicSurfaceRunoff::short_string
"def short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::KinematicSurfaceRunoff::to_string "def to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf__core_1_1_langmuir_adsorption.xml
%feature("docstring") cmf_core::LangmuirAdsorption "

This class calculates the adsorption equilibrium between sorbat and
sorbent using the Langmuir isotherme.  Langmuir Adsorption:    ..
math::      \\\\\\\\frac{x_{ad}}{m} = q = \\\\\\\\frac{K c}{1 + K c}
where :math:`x_{ad} = x_{tot} - x_{free}` is the adsorbed tracer mass
:math:`x_{tot}` is the total tracer mass  :math:`x_{free}` is the
dissolved tracer mass  :math:`m` is the mass of the sorbent in the
same unit as the tracer mass  :math:`K` is the Langmuir sorption
coefficient  :math:`c = \\\\\\\\frac{x_{free}}{V}` is the
concentration of the tracer in tracer mass per m3  CMF stores in a
solute storage the total mass of a tracer and needs to calculate the
free tracer mass. The analytical solution for :math:`x_{free}` from
:math:`x_{tot}` is implemented in freesolute and derived usingsympy.
If you really want to see it, look in the code.
http://en.wikipedia.org/wiki/Langmuir_equation  C++ includes:
adsorption.h ";

%feature("docstring")  cmf_core::LangmuirAdsorption::__init__ "def
__init__(self, args)

__init__(cmf::water::LangmuirAdsorption self, real K, real m) ->
LangmuirAdsorption __init__(cmf::water::LangmuirAdsorption self,
LangmuirAdsorption other) -> LangmuirAdsorption
LangmuirAdsorption(const LangmuirAdsorption &other) ";

%feature("docstring")  cmf_core::LangmuirAdsorption::copy "def
copy(self, args, kwargs)

copy(LangmuirAdsorption self, real m=-1) -> LangmuirAdsorption
LangmuirAdsorption* copy(real m=-1) const  returns a copy of the
Adsorption object.  If the adsorption is depending on the sorbent
mass, you can give a positive value for the sorbent mass m. If the
value is not given or negative, m is used from the original object. ";

%feature("docstring")  cmf_core::LangmuirAdsorption::freesolute "def
freesolute(self, args, kwargs)

freesolute(Adsorption self, real xt, real V) -> real  virtual real
freesolute(real xt, real V) const =0  Returns the mass of dissolved
tracer as a function of the total tracer mass in the solute storage
and the water volume.  Parameters: -----------  xt:   :math:`x_t` the
total tracer mass in the storage  V:   :math:`V m^3` the water volume
in the storage  :math:`x_f` the dissolved mass of the tracer ";

%feature("docstring")  cmf_core::LangmuirAdsorption::totalsolute "def
totalsolute(self, args, kwargs)

totalsolute(Adsorption self, real xf, real V) -> real  virtual real
totalsolute(real xf, real V) const =0  Returns the total mass of the
tracer from the dissolved concetration in tracer unit/m3.  Parameters:
-----------  xf:   :math:`x_f` the dissolved tracer mass in the
storage  V:   :math:`V m^3` the water volume in the storage
:math:`x_t` the total mass of the tracer ";


// File: classcmf_1_1water_1_1_langmuir_adsorption.xml
%feature("docstring") cmf::water::LangmuirAdsorption "

This class calculates the adsorption equilibrium between sorbat and
sorbent using the Langmuir isotherme.

Langmuir Adsorption:



.. math::

    \\\\frac{x_{ad}}{m} = q = \\\\frac{K c}{1 + K c}

where
:math:`x_{ad} = x_{tot} - x_{free}` is the adsorbed tracer mass  :math:`x_{tot}`
is the total tracer mass

:math:`x_{free}` is the dissolved tracer mass

:math:`m` is the mass of the sorbent in the same unit as the tracer mass

:math:`K` is the Langmuir sorption coefficient

:math:`c = \\\\frac{x_{free}}{V}` is the concentration of the tracer in
tracer mass per m3

CMF stores in a solute storage the total mass of a tracer and needs to
calculate the free tracer mass. The analytical solution for :math:`x_{free}`
from :math:`x_{tot}` is implemented in freesolute and derived usingsympy. If
you really want to see it, look in the code.

http://en.wikipedia.org/wiki/Langmuir_equation

C++ includes: adsorption.h ";

%feature("docstring")
cmf::water::LangmuirAdsorption::LangmuirAdsorption "LangmuirAdsorption(real K, real m) ";

%feature("docstring")
cmf::water::LangmuirAdsorption::LangmuirAdsorption "LangmuirAdsorption(const LangmuirAdsorption &other) ";

%feature("docstring")
cmf::water::LangmuirAdsorption::~LangmuirAdsorption "virtual
~LangmuirAdsorption() ";

%feature("docstring")  cmf::water::LangmuirAdsorption::copy "LangmuirAdsorption* copy(real m=-1) const

returns a copy of the Adsorption object.

If the adsorption is depending on the sorbent mass, you can give a
positive value for the sorbent mass m. If the value is not given or
negative, m is used from the original object. ";

%feature("docstring")  cmf::water::LangmuirAdsorption::freesolute "real freesolute(real xt, real V) const

Returns the mass of dissolved tracer as a function of the total tracer
mass in the solute storage and the water volume.

Parameters:
-----------

xt:   :math:`x_t` the total tracer mass in the storage

V:   :math:`V m^3` the water volume in the storage

:math:`x_f` the dissolved mass of the tracer ";

%feature("docstring")  cmf::water::LangmuirAdsorption::totalsolute "real totalsolute(real xf, real V) const

Returns the total mass of the tracer from the dissolved concetration
in tracer unit/m3.

Parameters:
-----------

xf:   :math:`x_f` the dissolved tracer mass in the storage

V:   :math:`V m^3` the water volume in the storage

:math:`x_t` the total mass of the tracer ";


// File: classcmf__core_1_1lateral__sub__surface__flux.xml
%feature("docstring") cmf_core::lateral_sub_surface_flux "

An abstract base class for lateral subsurface fluxes.  C++ includes:
subsurfacefluxes.h ";

%feature("docstring")  cmf_core::lateral_sub_surface_flux::__init__ "def __init__(self, args, kwargs) ";

%feature("docstring")
cmf_core::lateral_sub_surface_flux::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::lateral_sub_surface_flux::__eq__ "def __eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::lateral_sub_surface_flux::__getitem__
"def __getitem__(self, index) ";

%feature("docstring")  cmf_core::lateral_sub_surface_flux::__iter__ "def __iter__(self) ";

%feature("docstring")  cmf_core::lateral_sub_surface_flux::__repr__ "def __repr__(self) ";

%feature("docstring")  cmf_core::lateral_sub_surface_flux::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::lateral_sub_surface_flux::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::lateral_sub_surface_flux::get_target
"def get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::lateral_sub_surface_flux::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::lateral_sub_surface_flux::kill_me "def kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::lateral_sub_surface_flux::left_node "def left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::lateral_sub_surface_flux::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::lateral_sub_surface_flux::refresh "def refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::lateral_sub_surface_flux::right_node
"def right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::lateral_sub_surface_flux::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf_core::lateral_sub_surface_flux::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::lateral_sub_surface_flux::to_string "def to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1connections_1_1lateral__sub__surface__flux.xml
%feature("docstring")
cmf::upslope::connections::lateral_sub_surface_flux "

An abstract base class for lateral subsurface fluxes.

C++ includes: subsurfacefluxes.h ";

%feature("docstring")
cmf::upslope::connections::lateral_sub_surface_flux::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::lateral_sub_surface_flux::exchange_target "void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")
cmf::upslope::connections::lateral_sub_surface_flux::get_ptr "ptr
get_ptr() const ";

%feature("docstring")
cmf::upslope::connections::lateral_sub_surface_flux::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::lateral_sub_surface_flux::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::lateral_sub_surface_flux::get_tracer_filter
"real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::lateral_sub_surface_flux::get_tracer_filter
"real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::lateral_sub_surface_flux::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::lateral_sub_surface_flux::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")
cmf::upslope::connections::lateral_sub_surface_flux::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::lateral_sub_surface_flux::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::lateral_sub_surface_flux::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::lateral_sub_surface_flux::set_tracer_filter
"void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::lateral_sub_surface_flux::set_tracer_filter
"void set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::lateral_sub_surface_flux::short_string "virtual std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::lateral_sub_surface_flux::to_string "virtual std::string to_string() const ";


// File: classcmf_1_1upslope_1_1layer__list.xml
%feature("docstring") cmf::upslope::layer_list "

A vector of layers, with array access to the properties of the layers,
for fast data exchange.

C++ includes: layer_list.h ";

%feature("docstring")  cmf::upslope::layer_list::layer_list "layer_list(const layer_list &for_copy)

Copy constructor. ";

%feature("docstring")  cmf::upslope::layer_list::layer_list "layer_list()

Creates an empty layer list. ";

%feature("docstring")  cmf::upslope::layer_list::layer_list "layer_list(const cmf::water::node_list &for_copy)

Creates a list of all soil layers from a node_list. ";

%feature("docstring")  cmf::upslope::layer_list::append "layer_list&
append(SoilLayer::ptr l)

Appends a soil layer to the list. ";

%feature("docstring")  cmf::upslope::layer_list::begin "iterator
begin() ";

%feature("docstring")  cmf::upslope::layer_list::begin "const_iterator begin() const ";

%feature("docstring")  cmf::upslope::layer_list::clear "void clear()

Clears the list. ";

%feature("docstring")  cmf::upslope::layer_list::end "iterator end()
";

%feature("docstring")  cmf::upslope::layer_list::end "const_iterator
end() const ";

%feature("docstring")  cmf::upslope::layer_list::extend "layer_list&
extend(const layer_list &ll)

Appends all soil layers of layer_list to this. ";

%feature("docstring")  cmf::upslope::layer_list::extend "layer_list&
extend(const cmf::water::node_list &nl)

Appends all soil layers from a node_list to this. ";

%feature("docstring")
cmf::upslope::layer_list::get_gravitational_potential "cmf::math::num_array get_gravitational_potential() const

Returns an array containing the gravitational potential in m of all
layers in the list. ";

%feature("docstring")  cmf::upslope::layer_list::get_ice_fraction "cmf::math::num_array get_ice_fraction() const ";

%feature("docstring")  cmf::upslope::layer_list::get_K "cmf::math::num_array get_K() const

Returns an array containing the conductivity in m/day of all layers in
the list. ";

%feature("docstring")  cmf::upslope::layer_list::get_Ksat "cmf::math::num_array get_Ksat() const

Returns an array containing the saturated conductivity in m/day of all
layers in the list. ";

%feature("docstring")  cmf::upslope::layer_list::get_lower_boundary "cmf::math::num_array get_lower_boundary() const

Returns an array containing the lower boundary in m below surface of
all layers in the list. ";

%feature("docstring")  cmf::upslope::layer_list::get_matrix_potential
"cmf::math::num_array get_matrix_potential() const

Returns an array containing the matrix potential in m of all layers in
the list. ";

%feature("docstring")  cmf::upslope::layer_list::get_percolation "cmf::math::num_array get_percolation(cmf::math::Time t) const

Returns the flux to each layer from the upper layer, or, in case of
the first layer from the surface water. ";

%feature("docstring")  cmf::upslope::layer_list::get_porosity "cmf::math::num_array get_porosity() const

Returns an array containing the porosity in m3/m3 of all layers in the
list. ";

%feature("docstring")  cmf::upslope::layer_list::get_potential "cmf::math::num_array get_potential() const

Returns an array containing the potentials of all layers in the list.
";

%feature("docstring")  cmf::upslope::layer_list::get_rootfraction "cmf::math::num_array get_rootfraction() const

Returns an array containing the rootfraction of each layer. ";

%feature("docstring")  cmf::upslope::layer_list::get_slice "layer_list get_slice(size_t first=0, size_t last=1000000, size_t
step=1) ";

%feature("docstring")  cmf::upslope::layer_list::get_theta "cmf::math::num_array get_theta() const ";

%feature("docstring")  cmf::upslope::layer_list::get_thickness "cmf::math::num_array get_thickness() const

Returns an array containing the thickness in m of all layers in the
list. ";

%feature("docstring")  cmf::upslope::layer_list::get_upper_boundary "cmf::math::num_array get_upper_boundary() const

Returns an array containing the upper boundary in m below surface of
all layers in the list. ";

%feature("docstring")  cmf::upslope::layer_list::get_volume "cmf::math::num_array get_volume() const

Returns an array containing the volume in m3 of stored water of all
layers in the list. ";

%feature("docstring")  cmf::upslope::layer_list::get_wetness "cmf::math::num_array get_wetness() const

Returns an array containing the wetness in m3 H2O/m3 pore space of all
layers in the list. ";

%feature("docstring")  cmf::upslope::layer_list::pop "SoilLayer::ptr
pop()

Deletes the last layer from the list and returns it. ";

%feature("docstring")  cmf::upslope::layer_list::set_ice_fraction "void set_ice_fraction(const cmf::math::num_array &Value, size_t
offset=0)

Sets the fraction of the ice content of the soil water. ";

%feature("docstring")  cmf::upslope::layer_list::set_potential "void
set_potential(const cmf::math::num_array &Value, size_t offset=0)

Sets the potential (head) in m of layers [offset : arraysize]. ";

%feature("docstring")  cmf::upslope::layer_list::set_rootfraction "void set_rootfraction(const cmf::math::num_array &Value, size_t
offset=0)

Sets the fraction of roots in each layer. ";

%feature("docstring")  cmf::upslope::layer_list::set_theta "void
set_theta(const cmf::math::num_array &Value, size_t offset=0)

Sets the volumetric water content of the soil. ";

%feature("docstring")  cmf::upslope::layer_list::set_volume "void
set_volume(const cmf::math::num_array &Value, size_t offset=0)

Sets the Volume in m3 of layers [offset : arraysize]. ";

%feature("docstring")  cmf::upslope::layer_list::set_wetness "void
set_wetness(const cmf::math::num_array &Value, size_t offset=0)

Sets the wetness in m3/m3 of layers [offset : arraysize]. ";

%feature("docstring")  cmf::upslope::layer_list::size "size_t size()
const

Number of layers in the list. ";


// File: classcmf__core_1_1layer__list.xml
%feature("docstring") cmf_core::layer_list "

A vector of layers, with array access to the properties of the layers,
for fast data exchange.  C++ includes: layer_list.h ";

%feature("docstring")  cmf_core::layer_list::__init__ "def
__init__(self, args)

__init__(cmf::upslope::layer_list self, layer_list for_copy) ->
layer_list __init__(cmf::upslope::layer_list self) -> layer_list
__init__(cmf::upslope::layer_list self, node_list for_copy) ->
layer_list  layer_list(const cmf::water::node_list &for_copy)  Creates
a list of all soil layers from a node_list. ";

%feature("docstring")  cmf_core::layer_list::__add__ "def
__add__(self, other) ";

%feature("docstring")  cmf_core::layer_list::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::layer_list::__iadd__ "def
__iadd__(self, other) ";

%feature("docstring")  cmf_core::layer_list::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::layer_list::append "def append(self,
args, kwargs)

append(layer_list self, cmf::upslope::SoilLayer::ptr l) -> layer_list
layer_list& append(SoilLayer::ptr l)  Appends a soil layer to the
list. ";

%feature("docstring")  cmf_core::layer_list::clear "def clear(self,
args, kwargs)

clear(layer_list self)  void clear()  Clears the list. ";

%feature("docstring")  cmf_core::layer_list::extend "def extend(self,
args)

extend(layer_list self, layer_list ll) -> layer_list extend(layer_list
self, node_list nl) -> layer_list  layer_list& extend(const
cmf::water::node_list &nl)  Appends all soil layers from a node_list
to this. ";

%feature("docstring")  cmf_core::layer_list::get_percolation "def
get_percolation(self, args, kwargs)

get_percolation(layer_list self, Time t) -> cmf::math::num_array
cmf::math::num_array get_percolation(cmf::math::Time t) const  Returns
the flux to each layer from the upper layer, or, in case of the first
layer from the surface water. ";

%feature("docstring")  cmf_core::layer_list::get_slice "def
get_slice(self, args, kwargs)

get_slice(layer_list self, size_t first=0, size_t last=1000000, size_t
step=1) -> layer_list  layer_list get_slice(size_t first=0, size_t
last=1000000, size_t step=1) ";

%feature("docstring")  cmf_core::layer_list::pop "def pop(self, args,
kwargs)

pop(layer_list self) -> cmf::upslope::SoilLayer::ptr  SoilLayer::ptr
pop()  Deletes the last layer from the list and returns it. ";

%feature("docstring")  cmf_core::layer_list::set_ice_fraction "def
set_ice_fraction(self, args, kwargs)

set_ice_fraction(layer_list self, cmf::math::num_array const & Value,
size_t offset=0)  void set_ice_fraction(const cmf::math::num_array
&Value, size_t offset=0)  Sets the fraction of the ice content of the
soil water. ";

%feature("docstring")  cmf_core::layer_list::set_potential "def
set_potential(self, args, kwargs)

set_potential(layer_list self, cmf::math::num_array const & Value,
size_t offset=0)  void set_potential(const cmf::math::num_array
&Value, size_t offset=0)  Sets the potential (head) in m of layers
[offset : arraysize]. ";

%feature("docstring")  cmf_core::layer_list::set_rootfraction "def
set_rootfraction(self, args, kwargs)

set_rootfraction(layer_list self, cmf::math::num_array const & Value,
size_t offset=0)  void set_rootfraction(const cmf::math::num_array
&Value, size_t offset=0)  Sets the fraction of roots in each layer. ";

%feature("docstring")  cmf_core::layer_list::set_theta "def
set_theta(self, args, kwargs)

set_theta(layer_list self, cmf::math::num_array const & Value, size_t
offset=0)  void set_theta(const cmf::math::num_array &Value, size_t
offset=0)  Sets the volumetric water content of the soil. ";

%feature("docstring")  cmf_core::layer_list::set_volume "def
set_volume(self, args, kwargs)

set_volume(layer_list self, cmf::math::num_array const & Value, size_t
offset=0)  void set_volume(const cmf::math::num_array &Value, size_t
offset=0)  Sets the Volume in m3 of layers [offset : arraysize]. ";

%feature("docstring")  cmf_core::layer_list::set_wetness "def
set_wetness(self, args, kwargs)

set_wetness(layer_list self, cmf::math::num_array const & Value,
size_t offset=0)  void set_wetness(const cmf::math::num_array &Value,
size_t offset=0)  Sets the wetness in m3/m3 of layers [offset :
arraysize]. ";

%feature("docstring")  cmf_core::layer_list::size "def size(self,
args, kwargs)

size(layer_list self) -> size_t  size_t size() const  Number of layers
in the list. ";


// File: classcmf__core_1_1_layer_bypass.xml
%feature("docstring") cmf_core::LayerBypass "

A simplification of macro pore flux for swelling soils.  Connects the
surfacewater of the cell with deeper layers, assuming the presence of
cracks. At saturation level of the target layer, the cracks are closed
.. math::      q_{crack} = K_{max,crack}
\\\\\\\\left(1-\\\\\\\\left(\\\\\\\\frac{w-w_0}{1-w_0}\\\\\\\\right)^\\\\\\\\beta\\\\\\\\right)
A  where:  :math:`q_{crack}` is the flux from the surface water to the
target layer in m3/day  :math:`K_{max,crack}` is the maximum
conductivity of the cracks in m/day  :math:`w` is the actual wetness
of the target layer  :math:`w_0` is saturation, where the shrinkage of
the cracks starts  :math:`\\\\\\\\beta` is an empirical shape
parameter of the crack size/wetness relation  :math:`A` is the area of
the cell  C++ includes: Percolation.h ";

%feature("docstring")  cmf_core::LayerBypass::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::LayerBypass self,
cmf::water::flux_node::ptr left, cmf::upslope::SoilLayer::ptr right,
real Kmax=100., real w0=0.0, real beta=1.0) -> LayerBypass
LayerBypass(cmf::water::flux_node::ptr left,
cmf::upslope::SoilLayer::ptr right, real Kmax=100., real w0=0.0, real
beta=1.0)  Creates a layer bypass connection.  Parameters: -----------
left:  The source of the flux, usually the surfacewater of the cell
right:  The target soil layer  Kmax:  maximum conductivity of the
cracks in m/day  w0:  is the actual wetness of the target layer  beta:
is an empirical shape parameter of the crack size/wetness relation ";

%feature("docstring")  cmf_core::LayerBypass::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::LayerBypass::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::LayerBypass::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::LayerBypass::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::LayerBypass::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::LayerBypass::conc "def conc(self,
args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::LayerBypass::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::LayerBypass::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::LayerBypass::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::LayerBypass::K "def K(self, args,
kwargs)

K(LayerBypass self, real w) -> real  real K(real w)  the actual crack
conductivity  Parameters: -----------  w:  the wetness of the target
layer ";

%feature("docstring")  cmf_core::LayerBypass::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::LayerBypass::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::LayerBypass::q "def q(self, args,
kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::LayerBypass::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::LayerBypass::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::LayerBypass::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::LayerBypass::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::LayerBypass::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1connections_1_1_layer_bypass.xml
%feature("docstring") cmf::upslope::connections::LayerBypass "

A simplification of macro pore flux for swelling soils.

Connects the surfacewater of the cell with deeper layers, assuming the
presence of cracks. At saturation level of the target layer, the
cracks are closed 

.. math::

    q_{crack} = K_{max,crack}
    \\\\left(1-\\\\left(\\\\frac{w-w_0}{1-w_0}\\\\right)^\\\\beta\\\\right)
    A

where:  :math:`q_{crack}` is the flux from the surface water to the
target layer in m3/day

:math:`K_{max,crack}` is the maximum conductivity of the cracks in m/day

:math:`w` is the actual wetness of the target layer

:math:`w_0` is saturation, where the shrinkage of the cracks starts

:math:`\\\\beta` is an empirical shape parameter of the crack size/wetness
relation

:math:`A` is the area of the cell

C++ includes: Percolation.h ";

%feature("docstring")
cmf::upslope::connections::LayerBypass::LayerBypass "LayerBypass(cmf::water::flux_node::ptr left,
cmf::upslope::SoilLayer::ptr right, real Kmax=100., real w0=0.0, real
beta=1.0)

Creates a layer bypass connection.

Parameters:
-----------

left:  The source of the flux, usually the surfacewater of the cell

right:  The target soil layer

Kmax:  maximum conductivity of the cracks in m/day

w0:  is the actual wetness of the target layer

beta:  is an empirical shape parameter of the crack size/wetness
relation ";

%feature("docstring")  cmf::upslope::connections::LayerBypass::conc "real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::LayerBypass::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::upslope::connections::LayerBypass::get_ptr
"ptr get_ptr() const ";

%feature("docstring")
cmf::upslope::connections::LayerBypass::get_target "flux_node::ptr
get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::LayerBypass::get_target "flux_node::ptr
get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::LayerBypass::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::LayerBypass::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::connections::LayerBypass::K "real K(real w)

the actual crack conductivity

Parameters:
-----------

w:  the wetness of the target layer ";

%feature("docstring")  cmf::upslope::connections::LayerBypass::kill_me
"bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::LayerBypass::left_node "flux_node::ptr
left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::connections::LayerBypass::q "real q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::connections::LayerBypass::refresh
"void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::LayerBypass::right_node "flux_node::ptr
right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::LayerBypass::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::LayerBypass::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::LayerBypass::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::LayerBypass::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1linear__scale.xml
%feature("docstring") cmf_core::linear_scale "

A linear scaling functor, with slope and displacement.  C++ includes:
boundary_condition.h ";

%feature("docstring")  cmf_core::linear_scale::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::water::linear_scale self, real _slope=1, real
_displacement=0) -> linear_scale  linear_scale(real _slope=1, real
_displacement=0)  Creates a linear scale (by default it is a unity
scale, :math:`a=1; b=0`) ";

%feature("docstring")  cmf_core::linear_scale::__call__ "def
__call__(self, args, kwargs)

__call__(linear_scale self, real value) -> real ";


// File: classcmf_1_1water_1_1linear__scale.xml
%feature("docstring") cmf::water::linear_scale "

A linear scaling functor, with slope and displacement.

C++ includes: boundary_condition.h ";

%feature("docstring")  cmf::water::linear_scale::linear_scale "linear_scale(real _slope=1, real _displacement=0)

Creates a linear scale (by default it is a unity scale, :math:`a=1; b=0`) ";


// File: classcmf__core_1_1_linear_adsorption.xml
%feature("docstring") cmf_core::LinearAdsorption "

This class calculates the adsorption equilibrium between sorbat and
sorbent using the linear (Henry) isotherme.  Linear (Henry) isotherme:
.. math::      \\\\\\\\frac{x_{ad}}{m} = K c  where  :math:`x_{ad} =
x_{tot} - x_{free}` is the adsorbed tracer mass  :math:`x_{tot}` is
the total tracer mass  :math:`x_{free}` is the dissolved tracer mass
:math:`m` is the mass of the sorbent in the same unit as the tracer
mass  :math:`K` is the Henry sorption coefficient  :math:`c =
\\\\\\\\frac{x_{free}}{V}` is the concentration of the tracer in
tracer mass per m3  CMF stores in a solute storage the total mass of a
tracer and needs to calculate the free tracer mass. Calculating
:math:`x_{free}` from :math:`x_{tot}` gives from the eq. above:   ..
math::      x_{free} = x_{tot} \\\\\\\\frac{V}{K m +     V}  C++
includes: adsorption.h ";

%feature("docstring")  cmf_core::LinearAdsorption::__init__ "def
__init__(self, args)

__init__(cmf::water::LinearAdsorption self, real K, real m) ->
LinearAdsorption __init__(cmf::water::LinearAdsorption self,
LinearAdsorption other) -> LinearAdsorption  LinearAdsorption(const
LinearAdsorption &other) ";

%feature("docstring")  cmf_core::LinearAdsorption::copy "def
copy(self, args, kwargs)

copy(LinearAdsorption self, real m=-1) -> LinearAdsorption
LinearAdsorption* copy(real m=-1) const  returns a copy of the
Adsorption object.  If the adsorption is depending on the sorbent
mass, you can give a positive value for the sorbent mass m. If the
value is not given or negative, m is used from the original object. ";

%feature("docstring")  cmf_core::LinearAdsorption::freesolute "def
freesolute(self, args, kwargs)

freesolute(Adsorption self, real xt, real V) -> real  virtual real
freesolute(real xt, real V) const =0  Returns the mass of dissolved
tracer as a function of the total tracer mass in the solute storage
and the water volume.  Parameters: -----------  xt:   :math:`x_t` the
total tracer mass in the storage  V:   :math:`V m^3` the water volume
in the storage  :math:`x_f` the dissolved mass of the tracer ";

%feature("docstring")  cmf_core::LinearAdsorption::totalsolute "def
totalsolute(self, args, kwargs)

totalsolute(Adsorption self, real xf, real V) -> real  virtual real
totalsolute(real xf, real V) const =0  Returns the total mass of the
tracer from the dissolved concetration in tracer unit/m3.  Parameters:
-----------  xf:   :math:`x_f` the dissolved tracer mass in the
storage  V:   :math:`V m^3` the water volume in the storage
:math:`x_t` the total mass of the tracer ";


// File: classcmf_1_1water_1_1_linear_adsorption.xml
%feature("docstring") cmf::water::LinearAdsorption "

This class calculates the adsorption equilibrium between sorbat and
sorbent using the linear (Henry) isotherme.

Linear (Henry) isotherme:



.. math::

    \\\\frac{x_{ad}}{m} = K c

where  :math:`x_{ad} = x_{tot} - x_{free}` is the adsorbed tracer mass  :math:`x_{tot}` is the total tracer
mass

:math:`x_{free}` is the dissolved tracer mass

:math:`m` is the mass of the sorbent in the same unit as the tracer mass

:math:`K` is the Henry sorption coefficient

:math:`c = \\\\frac{x_{free}}{V}` is the concentration of the tracer in
tracer mass per m3

CMF stores in a solute storage the total mass of a tracer and needs to
calculate the free tracer mass. Calculating :math:`x_{free}` from :math:`x_{tot}`
gives from the eq. above: 

.. math::

    x_{free} = x_{tot} \\\\frac{V}{K m +
    V}

C++ includes: adsorption.h ";

%feature("docstring")  cmf::water::LinearAdsorption::LinearAdsorption
"LinearAdsorption(real K, real m) ";

%feature("docstring")  cmf::water::LinearAdsorption::LinearAdsorption
"LinearAdsorption(const LinearAdsorption &other) ";

%feature("docstring")  cmf::water::LinearAdsorption::~LinearAdsorption
"virtual ~LinearAdsorption() ";

%feature("docstring")  cmf::water::LinearAdsorption::copy "LinearAdsorption* copy(real m=-1) const

returns a copy of the Adsorption object.

If the adsorption is depending on the sorbent mass, you can give a
positive value for the sorbent mass m. If the value is not given or
negative, m is used from the original object. ";

%feature("docstring")  cmf::water::LinearAdsorption::freesolute "real
freesolute(real xt, real V) const

Returns the mass of dissolved tracer as a function of the total tracer
mass in the solute storage and the water volume.

Parameters:
-----------

xt:   :math:`x_t` the total tracer mass in the storage

V:   :math:`V m^3` the water volume in the storage

:math:`x_f` the dissolved mass of the tracer ";

%feature("docstring")  cmf::water::LinearAdsorption::totalsolute "real totalsolute(real xf, real V) const

Returns the total mass of the tracer from the dissolved concetration
in tracer unit/m3.

Parameters:
-----------

xf:   :math:`x_f` the dissolved tracer mass in the storage

V:   :math:`V m^3` the water volume in the storage

:math:`x_t` the total mass of the tracer ";


// File: classcmf__core_1_1_linear_retention.xml
%feature("docstring") cmf_core::LinearRetention "

The linear retention curve provides a simple linear relationship
between storage and head.  Head function (head in m, calculated from
upper side control volume)   .. math::       h(\\\\\\\\theta) =
-\\\\\\\\Delta z \\\\\\\\left( 1 - \\\\\\\\frac{\\\\\\\\theta -
\\\\\\\\theta_r}{\\\\\\\\theta_s - \\\\\\\\theta_r} \\\\\\\\right)
Conductivity function   .. math::       K(\\\\\\\\theta) = K_{sat}
\\\\\\\\left(\\\\\\\\frac{\\\\\\\\theta -
\\\\\\\\theta_r}{\\\\\\\\theta_s -
\\\\\\\\theta_r}\\\\\\\\right)^\\\\\\\\beta   C++ includes:
RetentionCurve.h ";

%feature("docstring")  cmf_core::LinearRetention::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::LinearRetention self, real ksat, real phi, real
thickness, real residual_wetness=0.1) -> LinearRetention
LinearRetention(real ksat, real phi, real thickness, real
residual_wetness=0.1) ";

%feature("docstring")  cmf_core::LinearRetention::copy "def
copy(self, args, kwargs)

copy(LinearRetention self) -> LinearRetention  LinearRetention* copy()
const ";

%feature("docstring")  cmf_core::LinearRetention::Diffusivity "def
Diffusivity(self, args)

Diffusivity(RetentionCurve self, real wetness) -> real
Diffusivity(RetentionCurve self, cmf::math::num_array & wetness) ->
cmf::math::num_array  cmf::math::num_array
Diffusivity(cmf::math::num_array &wetness) ";

%feature("docstring")  cmf_core::LinearRetention::dPsiM_dW "def
dPsiM_dW(self, args)

dPsiM_dW(RetentionCurve self, real wetness) -> real
dPsiM_dW(RetentionCurve self, cmf::math::num_array const & wetness) ->
cmf::math::num_array  cmf::math::num_array dPsiM_dW(const
cmf::math::num_array &wetness) const ";

%feature("docstring")  cmf_core::LinearRetention::FillHeight "def
FillHeight(self, args, kwargs)

FillHeight(RetentionCurve self, real lowerDepth, real Area, real
Volume) -> real  virtual real FillHeight(real lowerDepth, real Area,
real Volume) const  Returns the thickness of a soil column with a
certain pore volume. ";

%feature("docstring")  cmf_core::LinearRetention::K "def K(self,
args)

K(RetentionCurve self, real wetness) -> real K(RetentionCurve self,
cmf::math::num_array const & wetness) -> cmf::math::num_array
cmf::math::num_array K(const cmf::math::num_array &wetness) const ";

%feature("docstring")  cmf_core::LinearRetention::MatricPotential "def MatricPotential(self, args)

MatricPotential(RetentionCurve self, real wetness) -> real
MatricPotential(RetentionCurve self, cmf::math::num_array const &
wetness) -> cmf::math::num_array  cmf::math::num_array
MatricPotential(const cmf::math::num_array &wetness) const ";

%feature("docstring")  cmf_core::LinearRetention::Porosity "def
Porosity(self, args, kwargs)

Porosity(RetentionCurve self, real depth=0.0) -> real  virtual real
Porosity(real depth=0.0) const =0  Returns the porosity at a certain
depth. ";

%feature("docstring")  cmf_core::LinearRetention::theta "def
theta(self, args)

theta(RetentionCurve self, real wetness) -> real theta(RetentionCurve
self, cmf::math::num_array const & wetness) -> cmf::math::num_array
cmf::math::num_array theta(const cmf::math::num_array &wetness) const
";

%feature("docstring")  cmf_core::LinearRetention::Transmissivity "def
Transmissivity(self, args, kwargs)

Transmissivity(LinearRetention self, real upperDepth, real lowerDepth,
real wetness) -> real  virtual real Transmissivity(real upperDepth,
real lowerDepth, real wetness) const ";

%feature("docstring")  cmf_core::LinearRetention::VoidVolume "def
VoidVolume(self, args, kwargs)

VoidVolume(RetentionCurve self, real upperDepth, real lowerDepth, real
Area) -> real  virtual real VoidVolume(real upperDepth, real
lowerDepth, real Area) const  Returns the void volume of a soil
column. ";

%feature("docstring")  cmf_core::LinearRetention::Wetness "def
Wetness(self, args)

Wetness(RetentionCurve self, real suction) -> real
Wetness(RetentionCurve self, cmf::math::num_array const & suction) ->
cmf::math::num_array  cmf::math::num_array Wetness(const
cmf::math::num_array &suction) const ";

%feature("docstring")  cmf_core::LinearRetention::Wetness_eff "def
Wetness_eff(self, args, kwargs)

Wetness_eff(RetentionCurve self, real wetness, real pF_r=4.2) -> real
virtual real Wetness_eff(real wetness, real pF_r=4.2) const  Returns
the effective wetness, using a residual pF value   .. math:: w_{eff}
=
\\\\\\\\frac{w_{act}-w\\\\\\\\left(pF_r\\\\\\\\right)}{1-w\\\\\\\\left(pF_r\\\\\\\\right)}
. ";

%feature("docstring")  cmf_core::LinearRetention::Wetness_pF "def
Wetness_pF(self, args)

Wetness_pF(RetentionCurve self, real pF) -> real
Wetness_pF(RetentionCurve self, cmf::math::num_array const & pF) ->
cmf::math::num_array  cmf::math::num_array Wetness_pF(const
cmf::math::num_array &pF) const ";


// File: classcmf_1_1upslope_1_1_linear_retention.xml
%feature("docstring") cmf::upslope::LinearRetention "

The linear retention curve provides a simple linear relationship
between storage and head.

Head function (head in m, calculated from upper side control volume)


.. math::

     h(\\\\theta) = -\\\\Delta z \\\\left( 1 - \\\\frac{\\\\theta -
    \\\\theta_r}{\\\\theta_s - \\\\theta_r} \\\\right) 

Conductivity
function 

.. math::

     K(\\\\theta) = K_{sat} \\\\left(\\\\frac{\\\\theta -
    \\\\theta_r}{\\\\theta_s - \\\\theta_r}\\\\right)^\\\\beta 

C++ includes: RetentionCurve.h ";

%feature("docstring")  cmf::upslope::LinearRetention::LinearRetention
"LinearRetention(real ksat, real phi, real thickness, real
residual_wetness=0.1) ";

%feature("docstring")  cmf::upslope::LinearRetention::~LinearRetention
"virtual ~LinearRetention() ";

%feature("docstring")  cmf::upslope::LinearRetention::copy "LinearRetention* copy() const ";

%feature("docstring")  cmf::upslope::LinearRetention::Diffusivity "virtual real Diffusivity(real wetness) const

Returns the Diffusivity of the soil.

Not implemented for all retention curves. Diffusivity is used by
MACROlikeMacroMicroExchange ";

%feature("docstring")  cmf::upslope::LinearRetention::Diffusivity "cmf::math::num_array Diffusivity(cmf::math::num_array &wetness) ";

%feature("docstring")  cmf::upslope::LinearRetention::dPsiM_dW "virtual real dPsiM_dW(real wetness) const ";

%feature("docstring")  cmf::upslope::LinearRetention::dPsiM_dW "cmf::math::num_array dPsiM_dW(const cmf::math::num_array &wetness)
const ";

%feature("docstring")  cmf::upslope::LinearRetention::FillHeight "virtual real FillHeight(real lowerDepth, real Area, real Volume) const

Returns the thickness of a soil column with a certain pore volume. ";

%feature("docstring")  cmf::upslope::LinearRetention::K "cmf::math::num_array K(const cmf::math::num_array &wetness) const ";

%feature("docstring")  cmf::upslope::LinearRetention::K "virtual real
K(real wetness) const

Returns the conductivity in m/day at a certain depth and water
content. ";

%feature("docstring")  cmf::upslope::LinearRetention::MatricPotential
"cmf::math::num_array MatricPotential(const cmf::math::num_array
&wetness) const ";

%feature("docstring")  cmf::upslope::LinearRetention::MatricPotential
"virtual real MatricPotential(real wetness) const

Returns the potential below upper side of the control volume in m. ";

%feature("docstring")  cmf::upslope::LinearRetention::Porosity "virtual real Porosity(real depth) const

Returns the porosity at a certain depth. ";

%feature("docstring")  cmf::upslope::LinearRetention::theta "virtual
real theta(real wetness) const

returns the water content :math:`theta` for a given wetness ";

%feature("docstring")  cmf::upslope::LinearRetention::theta "cmf::math::num_array theta(const cmf::math::num_array &wetness) const
";

%feature("docstring")  cmf::upslope::LinearRetention::Transmissivity "virtual real Transmissivity(real upperDepth, real lowerDepth, real
wetness) const ";

%feature("docstring")  cmf::upslope::LinearRetention::VoidVolume "virtual real VoidVolume(real upperDepth, real lowerDepth, real Area)
const

Returns the void volume of a soil column. ";

%feature("docstring")  cmf::upslope::LinearRetention::Wetness "cmf::math::num_array Wetness(const cmf::math::num_array &suction)
const ";

%feature("docstring")  cmf::upslope::LinearRetention::Wetness "virtual real Wetness(real suction) const

Returns the wetness (water content per pore volume) at a given head.
";

%feature("docstring")  cmf::upslope::LinearRetention::Wetness_eff "virtual real Wetness_eff(real wetness, real pF_r=4.2) const

Returns the effective wetness, using a residual pF value 

.. math::

    w_{eff}
    =
    \\\\frac{w_{act}-w\\\\left(pF_r\\\\right)}{1-w\\\\left(pF_r\\\\right)}

.
";

%feature("docstring")  cmf::upslope::LinearRetention::Wetness_pF "real Wetness_pF(real pF) const

returns the volumetric water content at a given pF value ";

%feature("docstring")  cmf::upslope::LinearRetention::Wetness_pF "cmf::math::num_array Wetness_pF(const cmf::math::num_array &pF) const
";


// File: classcmf__core_1_1_linear_storage_connection.xml
%feature("docstring") cmf_core::LinearStorageConnection "

Calculates flux out of a storage as a linear function of its volume.
This connection serves the same purpose as the old kinematic_wave
connection, but the parameters are easier to explain    .. math:: q =
\\\\\\\\frac{V - V_{residual}}{t_r}   where:  :math:`V` The actual
volume of water stored in source  :math:`V_{residual} [m^3]` The
volume of water not flowing out (default = 0) :math:`t_r` is the
residence time in the source.  C++ includes: simple_connections.h ";

%feature("docstring")  cmf_core::LinearStorageConnection::__init__ "def __init__(self, args, kwargs)

__init__(cmf::water::LinearStorageConnection self,
cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr
target, real residencetime, real residual=0.0) ->
LinearStorageConnection  LinearStorageConnection(WaterStorage::ptr
source, flux_node::ptr target, real residencetime, real residual=0.0)
Creates a linear storage connection or Nash-box.    .. math::       q
= \\\\\\\\frac{V - V_{residual}}{t_r}}   Parameters: -----------
source:  Water storage from which the water flows out. Flux is a
function of source.volume  target:  Target node (boundary condition or
storage). Does not influence the strength of the flow  residencetime:
:math:`t_r [days]` The residence time of the water in this storage
residual:   :math:`V_{residual} [m^3]` The volume of water not flowing
out (default = 0) ";

%feature("docstring")  cmf_core::LinearStorageConnection::__contains__
"def __contains__(self, cmp) ";

%feature("docstring")  cmf_core::LinearStorageConnection::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::LinearStorageConnection::__getitem__
"def __getitem__(self, index) ";

%feature("docstring")  cmf_core::LinearStorageConnection::__iter__ "def __iter__(self) ";

%feature("docstring")  cmf_core::LinearStorageConnection::__repr__ "def __repr__(self) ";

%feature("docstring")  cmf_core::LinearStorageConnection::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::LinearStorageConnection::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::LinearStorageConnection::get_target "def get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::LinearStorageConnection::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::LinearStorageConnection::kill_me "def kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::LinearStorageConnection::left_node "def left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::LinearStorageConnection::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::LinearStorageConnection::refresh "def refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::LinearStorageConnection::right_node "def right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::LinearStorageConnection::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::LinearStorageConnection::short_string
"def short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::LinearStorageConnection::to_string "def to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1water_1_1_linear_storage_connection.xml
%feature("docstring") cmf::water::LinearStorageConnection "

Calculates flux out of a storage as a linear function of its volume.

This connection serves the same purpose as the old kinematic_wave
connection, but the parameters are easier to explain



.. math::

     q = \\\\frac{V - V_{residual}}{t_r} 

where:  :math:`V` The actual
volume of water stored in source

:math:`V_{residual} [m^3]` The volume of water not flowing out (default = 0)
:math:`t_r` is the residence time in the source.

C++ includes: simple_connections.h ";

%feature("docstring")
cmf::water::LinearStorageConnection::LinearStorageConnection "LinearStorageConnection(WaterStorage::ptr source, flux_node::ptr
target, real residencetime, real residual=0.0)

Creates a linear storage connection or Nash-box.



.. math::

     q = \\\\frac{V - V_{residual}}{t_r}} 

Parameters:
-----------

source:  Water storage from which the water flows out. Flux is a
function of source.volume

target:  Target node (boundary condition or storage). Does not
influence the strength of the flow

residencetime:   :math:`t_r [days]` The residence time of the water in this
storage

residual:   :math:`V_{residual} [m^3]` The volume of water not flowing out
(default = 0) ";

%feature("docstring")  cmf::water::LinearStorageConnection::conc "real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::water::LinearStorageConnection::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::water::LinearStorageConnection::get_ptr "ptr get_ptr() const ";

%feature("docstring")  cmf::water::LinearStorageConnection::get_target
"flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::water::LinearStorageConnection::get_target
"flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::water::LinearStorageConnection::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::LinearStorageConnection::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::water::LinearStorageConnection::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::water::LinearStorageConnection::left_node
"flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::water::LinearStorageConnection::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::water::LinearStorageConnection::refresh "void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::water::LinearStorageConnection::right_node
"flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::water::LinearStorageConnection::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::LinearStorageConnection::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::water::LinearStorageConnection::short_string "virtual
std::string short_string() const ";

%feature("docstring")  cmf::water::LinearStorageConnection::to_string
"virtual std::string to_string() const ";


// File: classcmf__core_1_1log__wind__profile.xml
%feature("docstring") cmf_core::log_wind_profile "

, A logarithmic wind profile  Todo Cite literature for this
windprofile and insert equation  C++ includes: ET.h ";

%feature("docstring")  cmf_core::log_wind_profile::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::atmosphere::log_wind_profile self, Cell _cell) ->
log_wind_profile  log_wind_profile(cmf::upslope::Cell &_cell) ";

%feature("docstring")
cmf_core::log_wind_profile::get_aerodynamic_resistance "def
get_aerodynamic_resistance(self, args, kwargs)

get_aerodynamic_resistance(aerodynamic_resistance self, double & r_ag,
double & r_ac, Time t)  virtual void get_aerodynamic_resistance(double
&r_ag, double &r_ac, cmf::math::Time t) const =0  aerodynamic
resistance from ground to atmosphere (r_ag) and from canopy to
atmosphere (r_ac) ";


// File: classcmf_1_1atmosphere_1_1log__wind__profile.xml
%feature("docstring") cmf::atmosphere::log_wind_profile "

, A logarithmic wind profile

Todo Cite literature for this windprofile and insert equation

C++ includes: ET.h ";

%feature("docstring")
cmf::atmosphere::log_wind_profile::log_wind_profile "log_wind_profile(cmf::upslope::Cell &_cell) ";

%feature("docstring")
cmf::atmosphere::log_wind_profile::~log_wind_profile "virtual
~log_wind_profile() ";

%feature("docstring")
cmf::atmosphere::log_wind_profile::get_aerodynamic_resistance "virtual void get_aerodynamic_resistance(double &r_ag, double &r_ac,
cmf::math::Time t) const

aerodynamic resistance from ground to atmosphere (r_ag) and from
canopy to atmosphere (r_ac) ";


// File: classcmf_1_1upslope_1_1connections_1_1_m_a_c_r_olike_macro_micro_exchange.xml
%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange "

This connection models the water exchange between macropores and
micropores as in the MACRO Model (Larsbo & Jarvis, 2003), which
follows Gerke & van Genuchten 1996.

WARNING:  Deprecated This connection uses the diffusivity of a soil
given by its retention curve. Since no retention curve provides a
valid value for Diffusivity in case of saturation this connection will
blow up the numerical solution for sure.

The exchange between Macropore and matrix is defined as follows:
(MACRO 5 Tech report, Larsbo & Jarvis 2003)



.. math::

    q = \\\\frac{G_f D_w \\\\gamma_w}{d^2}(\\\\theta_b -
    \\\\theta_{mi}) V_{layer}

where:  :math:`G_f` is the geometry factor.
Use 3 for a rectangular slab geometry

:math:`gamma_w` A scaling factor to fit analytical and numerical solution
(0.4)

:math:`d` is an effective diffusive path length related to aggregate size
and the influence of coatings on the aggregate surfaces in m

:math:`\\\\theta_b` the saturated water content of the matrix

:math:`\\\\theta_{mi}` the actual water content of the matrix

:math:`D_w = \\\\frac12(D(\\\\theta_b)+D(\\\\theta_{mi})W_{ma})` is the
effective water diffusivity in m2/day, as defined below  :math:`W_{ma}` is
the saturation of the macropores

C++ includes: macropore.h ";

%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange::MACROlikeMacroMicroExchange
"MACROlikeMacroMicroExchange(cmf::upslope::SoilLayer::ptr left,
cmf::upslope::MacroPore::ptr right, real _gamma_w=0.4, real _Gf=3) ";

%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange::exchange_target
"void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange::get_ptr "ptr
get_ptr() const ";

%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange::get_tracer_filter
"real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange::get_tracer_filter
"real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange::set_tracer_filter
"void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange::set_tracer_filter
"void set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange::short_string "virtual std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::MACROlikeMacroMicroExchange::to_string "virtual std::string to_string() const ";


// File: classcmf__core_1_1_m_a_c_r_olike_macro_micro_exchange.xml
%feature("docstring") cmf_core::MACROlikeMacroMicroExchange "

This connection models the water exchange between macropores and
micropores as in the MACRO Model (Larsbo & Jarvis, 2003), which
follows Gerke & van Genuchten 1996.  WARNING:  Deprecated This
connection uses the diffusivity of a soil given by its retention
curve. Since no retention curve provides a valid value for Diffusivity
in case of saturation this connection will blow up the numerical
solution for sure.  The exchange between Macropore and matrix is
defined as follows: (MACRO 5 Tech report, Larsbo & Jarvis 2003)    ..
math::      q = \\\\\\\\frac{G_f D_w
\\\\\\\\gamma_w}{d^2}(\\\\\\\\theta_b -     \\\\\\\\theta_{mi})
V_{layer}  where:  :math:`G_f` is the geometry factor. Use 3 for a
rectangular slab geometry  :math:`gamma_w` A scaling factor to fit
analytical and numerical solution (0.4)  :math:`d` is an effective
diffusive path length related to aggregate size and the influence of
coatings on the aggregate surfaces in m  :math:`\\\\\\\\theta_b` the
saturated water content of the matrix  :math:`\\\\\\\\theta_{mi}` the
actual water content of the matrix  :math:`D_w =
\\\\\\\\frac12(D(\\\\\\\\theta_b)+D(\\\\\\\\theta_{mi})W_{ma})` is the
effective water diffusivity in m2/day, as defined below :math:`W_{ma}`
is the saturation of the macropores  C++ includes: macropore.h ";

%feature("docstring")  cmf_core::MACROlikeMacroMicroExchange::__init__
"def __init__(self, args, kwargs)

__init__(cmf::upslope::connections::MACROlikeMacroMicroExchange self,
cmf::upslope::SoilLayer::ptr left, cmf::upslope::MacroPore::ptr right,
real _gamma_w=0.4, real _Gf=3) -> MACROlikeMacroMicroExchange
MACROlikeMacroMicroExchange(cmf::upslope::SoilLayer::ptr left,
cmf::upslope::MacroPore::ptr right, real _gamma_w=0.4, real _Gf=3) ";

%feature("docstring")
cmf_core::MACROlikeMacroMicroExchange::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::MACROlikeMacroMicroExchange::__eq__ "def __eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")
cmf_core::MACROlikeMacroMicroExchange::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::MACROlikeMacroMicroExchange::__iter__
"def __iter__(self) ";

%feature("docstring")  cmf_core::MACROlikeMacroMicroExchange::__repr__
"def __repr__(self) ";

%feature("docstring")  cmf_core::MACROlikeMacroMicroExchange::conc "def conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::MACROlikeMacroMicroExchange::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf_core::MACROlikeMacroMicroExchange::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::MACROlikeMacroMicroExchange::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::MACROlikeMacroMicroExchange::kill_me
"def kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")
cmf_core::MACROlikeMacroMicroExchange::left_node "def left_node(self,
args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::MACROlikeMacroMicroExchange::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::MACROlikeMacroMicroExchange::refresh
"def refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")
cmf_core::MACROlikeMacroMicroExchange::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::MACROlikeMacroMicroExchange::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf_core::MACROlikeMacroMicroExchange::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")
cmf_core::MACROlikeMacroMicroExchange::to_string "def to_string(self,
args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf__core_1_1_macro_pore.xml
%feature("docstring") cmf_core::MacroPore "

An additional water storage for a soil layer to model matrix water and
macro pore water seperately.  Deprecated The MacroPore model is still
very experimental and not stable. Only for tryouts!  If present, the
soil layer water storage holds the matrix water and the MacroPore
holds the water in the macro pore. Use cmf::upslope::Macropore::create
to create a macropore storage.  Use
cmf::upslope::connections::GradientMacroFlow or
cmf::upslope::connections::KinematicMacroFlow to model water flow
between macro pores and a lateral connection ( lateral subsurface
fluxes) like cmf::upslope::connections::Richards_lateral to connect
the macro pore with the matrix.  C++ includes: macropore.h ";

%feature("docstring")  cmf_core::MacroPore::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::MacroPore::__call__ "def
__call__(self, args, kwargs)

__call__(flux_node self, Time t) -> real ";

%feature("docstring")  cmf_core::MacroPore::__eq__ "def __eq__(self,
args, kwargs)

__eq__(flux_node self, flux_node other) -> bool ";

%feature("docstring")  cmf_core::MacroPore::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(WaterStorage self, solute X) -> SoluteStorage ";

%feature("docstring")  cmf_core::MacroPore::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::MacroPore::cast "def cast(args,
kwargs)

cast(cmf::water::flux_node::ptr node) -> cmf::upslope::MacroPore::ptr
";

%feature("docstring")  cmf_core::MacroPore::conc "def conc(self,
args, kwargs)

conc(flux_node self, Time t, solute Solute) -> real  virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const
Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf_core::MacroPore::conc "def conc(self,
args)

conc(WaterStorage self, solute _Solute) -> real conc(WaterStorage
self, Time t, solute _Solute) -> real conc(WaterStorage self, solute
_Solute, real NewConcetration)  void conc(const cmf::water::solute
&_Solute, real NewConcetration)  Sets a new concentration. ";

%feature("docstring")  cmf_core::MacroPore::connected_nodes "def
connected_nodes(self) ";

%feature("docstring")  cmf_core::MacroPore::connection_to "def
connection_to(self, args, kwargs)

connection_to(flux_node self, flux_node target) -> flux_connection
cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)  Returns the connection between this and target. ";

%feature("docstring")  cmf_core::MacroPore::create "def create(args,
kwargs)

create(cmf::upslope::SoilLayer::ptr layer, real porefraction=0.05,
real Ksat=10, real density=0.05, real porefraction_wilt=-1., real
K_shape=0.0) -> cmf::upslope::MacroPore::ptr ";

%feature("docstring")  cmf_core::MacroPore::dxdt "def dxdt(self,
args, kwargs)

dxdt(StateVariable self, Time time) -> real  virtual real dxdt(const
cmf::math::Time &time)=0  Returns the derivate of the state variable
at time time. ";

%feature("docstring")  cmf_core::MacroPore::flux3d_to "def
flux3d_to(self, args, kwargs)

flux3d_to(flux_node self, flux_node target, Time t) -> point
cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf_core::MacroPore::flux_to "def
flux_to(self, args, kwargs)

flux_to(flux_node self, flux_node target, Time t) -> real  real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)
Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf_core::MacroPore::fluxes "def fluxes(self,
t) ";

%feature("docstring")  cmf_core::MacroPore::from_node "def
from_node(args, kwargs)

from_node(cmf::water::flux_node::ptr node) -> std::shared_ptr<
cmf::water::WaterStorage > ";

%feature("docstring")  cmf_core::MacroPore::get_3d_flux "def
get_3d_flux(self, args, kwargs)

get_3d_flux(flux_node self, Time t) -> point  cmf::geometry::point
get_3d_flux(cmf::math::Time t)  Returns the sum of all flux vectors.
";

%feature("docstring")  cmf_core::MacroPore::get_abs_errtol "def
get_abs_errtol(self, args, kwargs)

get_abs_errtol(StateVariable self, real rel_errtol) -> real  virtual
real get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf_core::MacroPore::get_crackwidth "def
get_crackwidth(self, args, kwargs)

get_crackwidth(MacroPore self) -> real  virtual real get_crackwidth()
const  Returns the crack width for a prismatic crackstructure.  For a
prismatic crack structure, the porefraction in m3/m3 equals the
vertical crack area in m2/m2. The length of equally spaced cracks is
in one direction the inverse of the density and twice the length for
two directions.   .. math::       l_{crack} [m/m^2]= 2 \\\\\\\\frac
{1}{d[m]}  If we again ignore the fact that the spacing of the
cracking crossings is counted double, the crack width is:   .. math::
w_{crack}[m] =     \\\\\\\\frac{A_{crack}[m^2/m^2]}{l_{crack}[m/m^2]}
Combining both eq. above:   .. math::       w_{crack}[m] =
A_{crack}[m^2/m^2]\\\\\\\\frac{d[m]}{2} ";

%feature("docstring")  cmf_core::MacroPore::get_flowwidth "def
get_flowwidth(self, args, kwargs)

get_flowwidth(MacroPore self) -> real  real get_flowwidth() const  The
approximate length of the aggregate boundaries.    .. math::      l =
\\\\\\\\frac{2}{d_{macro}} A  where:  :math:`l` is the length of the
aggregate boundaries (in m)  :math:`2` is the number of directions
:math:`d_{macro}` is the mean distance between macropores (density) in
m  :math:`A` is the area of the cell ";

%feature("docstring")  cmf_core::MacroPore::get_K "def get_K(self,
args, kwargs)

get_K(MacroPore self, point direction) -> real  virtual real
get_K(cmf::geometry::point direction) const  Returns the actual
anisotropic conductivity along a direction :math:`K = (k_f
\\\\\\\\cdot d) K`. ";

%feature("docstring")  cmf_core::MacroPore::get_porefraction "def
get_porefraction(self, args, kwargs)

get_porefraction(MacroPore self) -> real  real get_porefraction()
const  The fraction of the macro pores in m3/m3. This adds to the
porosity of the layer. ";

%feature("docstring")  cmf_core::MacroPore::get_states "def
get_states(self, args, kwargs)

get_states(StateVariableOwner self) -> StateVariableList  virtual
StateVariableList get_states()=0  Add the state variables, owned by an
object derived from StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf_core::MacroPore::is_connected "def
is_connected(self, args, kwargs)

is_connected(StateVariable self, StateVariable other) -> bool  virtual
bool is_connected(const cmf::math::StateVariable &other) const ";

%feature("docstring")  cmf_core::MacroPore::is_empty "def
is_empty(self, args, kwargs)

is_empty(flux_node self) -> double  virtual double is_empty() const
Returns true if the node has no water. ";

%feature("docstring")  cmf_core::MacroPore::is_storage "def
is_storage(self, args, kwargs)

is_storage(flux_node self) -> bool  virtual bool is_storage() const
true, if this is a waterstorage ";

%feature("docstring")  cmf_core::MacroPore::RecalcFluxes "def
RecalcFluxes(self, args, kwargs)

RecalcFluxes(flux_node self, Time t) -> bool  virtual bool
RecalcFluxes(cmf::math::Time t)  Pure flux_nodes do not influence
fluxes, therefore no recalculation of fluxes is required by flux_node.
WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf_core::MacroPore::remove_connection "def
remove_connection(self, args, kwargs)

remove_connection(flux_node self, cmf::water::flux_node::ptr To) ->
bool  bool remove_connection(cmf::water::flux_node::ptr To)  Remove
the connection. ";

%feature("docstring")  cmf_core::MacroPore::Solute "def Solute(self,
args)

Solute(WaterStorage self, solute _Solute) -> SoluteStorage
Solute(WaterStorage self, solute _Solute) -> SoluteStorage  const
SoluteStorage& Solute(const cmf::water::solute _Solute) const ";

%feature("docstring")  cmf_core::MacroPore::to_string "def
to_string(self, args, kwargs)

to_string(StateVariable self) -> std::string  virtual std::string
to_string() const =0 ";

%feature("docstring")  cmf_core::MacroPore::to_string "def
to_string(self, args, kwargs)

to_string(flux_node self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::MacroPore::waterbalance "def
waterbalance(self, args, kwargs)

waterbalance(flux_node self, Time t, flux_connection Without=None) ->
real  real waterbalance(cmf::math::Time t, const flux_connection
*Without=0) const  Returns the sum of all fluxes (positive and
negative) at time t.  Single fluxes can be excluded from the
calculation  Parameters: -----------  t:  Time of the query  Without:
A flux_connection that is excluded from the waterbalance (e.g. to
prevent closed circuits) ";


// File: classcmf_1_1upslope_1_1_macro_pore.xml
%feature("docstring") cmf::upslope::MacroPore "

An additional water storage for a soil layer to model matrix water and
macro pore water seperately.

Deprecated The MacroPore model is still very experimental and not
stable. Only for tryouts!

If present, the soil layer water storage holds the matrix water and
the MacroPore holds the water in the macro pore. Use
cmf::upslope::Macropore::create to create a macropore storage.

Use cmf::upslope::connections::GradientMacroFlow or
cmf::upslope::connections::KinematicMacroFlow to model water flow
between macro pores and a lateral connection ( lateral subsurface
fluxes) like cmf::upslope::connections::Richards_lateral to connect
the macro pore with the matrix.

C++ includes: macropore.h ";

/*  Overrides of flux_node  */

%feature("docstring")  cmf::upslope::MacroPore::RecalcFluxes "virtual
bool RecalcFluxes(cmf::math::Time t)

Pure flux_nodes do not influence fluxes, therefore no recalculation of
fluxes is required by flux_node.

WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf::upslope::MacroPore::is_empty "virtual
double is_empty() const

Returns true if the node has no water. ";

%feature("docstring")  cmf::upslope::MacroPore::to_string "virtual
std::string to_string() const ";

%feature("docstring")  cmf::upslope::MacroPore::add_connected_states "virtual void add_connected_states(cmf::math::StateVariable::list
&states) ";

%feature("docstring")  cmf::upslope::MacroPore::conc "real conc(const
cmf::water::solute &_Solute) const

Returns the concentration of the given solute. ";

%feature("docstring")  cmf::upslope::MacroPore::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute) const

Returns the current WaterQuality (concentration of all solutes) ";

%feature("docstring")  cmf::upslope::MacroPore::conc "void conc(const
cmf::water::solute &_Solute, real NewConcetration)

Sets a new concentration. ";

%feature("docstring")  cmf::upslope::MacroPore::connection_to "cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::upslope::MacroPore::dxdt "virtual real
dxdt(const cmf::math::Time &time) ";

%feature("docstring")  cmf::upslope::MacroPore::flux3d_to "cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf::upslope::MacroPore::flux_to "real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf::upslope::MacroPore::get_3d_flux "cmf::geometry::point get_3d_flux(cmf::math::Time t)

Returns the sum of all flux vectors. ";

%feature("docstring")  cmf::upslope::MacroPore::get_abs_errtol "virtual real get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf::upslope::MacroPore::get_capacity "real
get_capacity() const

Returns the capacity of the macropores in m3.



.. math::

    V_{max} = \\\\Phi_{macro} A \\\\Delta z

where:  :math:`V_{max}` is
the water capacity of the macropore

:math:`\\\\Phi_{macro}` is the fraction of macro pores in the soil in :math:`m^3 macro pores/m^3 soil`

:math:`A \\\\Delta z` is the total volume of the soil layer (including all
pores) in :math:`m^3` ";

%feature("docstring")  cmf::upslope::MacroPore::get_cell "cmf::upslope::Cell& get_cell() const

The cell of this macropore. ";

%feature("docstring")  cmf::upslope::MacroPore::get_connections "cmf::water::connection_list get_connections() const ";

%feature("docstring")  cmf::upslope::MacroPore::get_crackwidth "virtual real get_crackwidth() const

Returns the crack width for a prismatic crackstructure.

For a prismatic crack structure, the porefraction in m3/m3 equals the
vertical crack area in m2/m2. The length of equally spaced cracks is
in one direction the inverse of the density and twice the length for
two directions. 

.. math::

     l_{crack} [m/m^2]= 2 \\\\frac {1}{d[m]}

If
we again ignore the fact that the spacing of the cracking crossings is
counted double, the crack width is: 

.. math::

     w_{crack}[m] =
    \\\\frac{A_{crack}[m^2/m^2]}{l_{crack}[m/m^2]} 

Combining both
eq. above: 

.. math::

     w_{crack}[m] = A_{crack}[m^2/m^2]\\\\frac{d[m]}{2}
    

";

%feature("docstring")  cmf::upslope::MacroPore::get_filled_fraction "real get_filled_fraction() const

Get the relative water content in the macro pore :math:`\\\\theta_{macro} = V_{macro}/V_{max}`. ";

%feature("docstring")  cmf::upslope::MacroPore::get_flowwidth "real
get_flowwidth() const

The approximate length of the aggregate boundaries.



.. math::

    l = \\\\frac{2}{d_{macro}} A

where:  :math:`l` is the length of
the aggregate boundaries (in m)

:math:`2` is the number of directions

:math:`d_{macro}` is the mean distance between macropores (density) in m

:math:`A` is the area of the cell ";

%feature("docstring")  cmf::upslope::MacroPore::get_K "virtual real
get_K() const

Returns the actual conductivity. ";

%feature("docstring")  cmf::upslope::MacroPore::get_K "virtual real
get_K(cmf::geometry::point direction) const

Returns the actual anisotropic conductivity along a direction :math:`K = (k_f \\\\cdot d) K`. ";

%feature("docstring")  cmf::upslope::MacroPore::get_layer "SoilLayer::ptr get_layer() const

Gets the soil layer (matrix water storage) for this macropore storage.
";

%feature("docstring")  cmf::upslope::MacroPore::get_porefraction "real get_porefraction() const

The fraction of the macro pores in m3/m3. This adds to the porosity of
the layer. ";

%feature("docstring")  cmf::upslope::MacroPore::get_potential "real
get_potential() const

Returns the actual water level in the macropore in m above reference.
";

%feature("docstring")  cmf::upslope::MacroPore::get_project "cmf::project& get_project() const

Returns the project, this node is part of. ";

%feature("docstring")  cmf::upslope::MacroPore::get_state "real
get_state() const ";

%feature("docstring")
cmf::upslope::MacroPore::get_state_variable_content "char
get_state_variable_content() const

A character indicating the integrated variable (either 'V' for Volume
or 'h' for head) ";

%feature("docstring")  cmf::upslope::MacroPore::get_states "cmf::math::StateVariableList get_states()

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf::upslope::MacroPore::get_volume "real
get_volume() const

Returns the actual stored volume in this macropore in m3. ";

%feature("docstring")  cmf::upslope::MacroPore::is_connected "virtual
bool is_connected(const cmf::math::StateVariable &other) const

Returns True if this waterstorage is effected by another state. ";

%feature("docstring")  cmf::upslope::MacroPore::is_storage "virtual
bool is_storage() const

Returns true, since this is a storage. ";

%feature("docstring")  cmf::upslope::MacroPore::remove_connection "bool remove_connection(cmf::water::flux_node::ptr To)

Remove the connection. ";

%feature("docstring")  cmf::upslope::MacroPore::set_potential "void
set_potential(real waterhead)

Sets the water level in the macropore. Be aware of not setting it
below the lower boundary. ";

%feature("docstring")  cmf::upslope::MacroPore::set_state "void
set_state(real newState) ";

%feature("docstring")
cmf::upslope::MacroPore::set_state_variable_content "void
set_state_variable_content(char content)

A character indicating the integrated variable (either 'V' for Volume
or 'h' for head) ";

%feature("docstring")  cmf::upslope::MacroPore::set_volume "void
set_volume(real volume)

Sets the volume of stored water in m3. ";

%feature("docstring")  cmf::upslope::MacroPore::Solute "SoluteStorage& Solute(const cmf::water::solute _Solute)

Returns the water quality of the water storage. ";

%feature("docstring")  cmf::upslope::MacroPore::Solute "const
SoluteStorage& Solute(const cmf::water::solute _Solute) const ";

%feature("docstring")  cmf::upslope::MacroPore::waterbalance "real
waterbalance(cmf::math::Time t, const flux_connection *Without=0)
const

Returns the sum of all fluxes (positive and negative) at time t.

Single fluxes can be excluded from the calculation

Parameters:
-----------

t:  Time of the query

Without:  A flux_connection that is excluded from the waterbalance
(e.g. to prevent closed circuits) ";


// File: classcmf__core_1_1_manning.xml
%feature("docstring") cmf_core::Manning "

Calculates the flux between two open water bodies, using Manning's
equation.  This is the base class for a kinematic wave approach
(topography driven) and a diffusive wave approach (water table
driven). The only difference between both approaches is the
calculation of the flux driving slope. For the model, one of
ManningKinematic or ManningDiffusive connection is selected   ..
math::       v = R^{\\\\\\\\frac 2 3}
\\\\\\\\frac{\\\\\\\\sqrt{\\\\\\\\Delta_z}}{n} \\\\\\\\\\\\\\\\ q = v
\\\\\\\\cdot A   Where:  :math:`A = \\\\\\\\frac V l`: Crosssectional
area of the wetted crossection, Volume per length  :math:`R =
\\\\\\\\frac A{P(d)}`: The hydraulic radius  :math:`P(d)`: the
perimeter of the wetted crosssection, a function of reach depth
:math:`d(V)`: the depth of the reach, a function of the volume
:math:`\\\\\\\\Delta_z = \\\\\\\\frac{|z_1 - z_2|}{l}`: Slope of the
reach  :math:`n`: Manning friction number  For the kinematic wave the
slope of the river bed is used as slope:   .. math:: \\\\\\\\Delta_z =
\\\\\\\\frac{|z_1 - z_2|}{l}  while for the diffusive wave the slope
is calculated from the actual water head: .. math::
\\\\\\\\Delta_z = \\\\\\\\frac{|h_1 - h_2|}{l}  C++ includes:
ManningConnection.h ";

%feature("docstring")  cmf_core::Manning::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::Manning::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::Manning::__eq__ "def __eq__(self,
args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::Manning::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::Manning::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::Manning::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::Manning::conc "def conc(self, args,
kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::Manning::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::Manning::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::Manning::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::Manning::kill_me "def kill_me(self,
args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::Manning::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::Manning::q "def q(self, args,
kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::Manning::refresh "def refresh(self,
args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::Manning::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::Manning::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::Manning::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::Manning::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1river_1_1_manning.xml
%feature("docstring") cmf::river::Manning "

Calculates the flux between two open water bodies, using Manning's
equation.

This is the base class for a kinematic wave approach (topography
driven) and a diffusive wave approach (water table driven). The only
difference between both approaches is the calculation of the flux
driving slope. For the model, one of ManningKinematic or
ManningDiffusive connection is selected 

.. math::

     v = R^{\\\\frac 2 3}
    \\\\frac{\\\\sqrt{\\\\Delta_z}}{n} \\\\\\\\ q = v \\\\cdot A 

Where:  :math:`A = \\\\frac V l`: Crosssectional area of the wetted
crossection, Volume per length

:math:`R = \\\\frac A{P(d)}`: The hydraulic radius

:math:`P(d)`: the perimeter of the wetted crosssection, a function of reach
depth

:math:`d(V)`: the depth of the reach, a function of the volume

:math:`\\\\Delta_z = \\\\frac{|z_1 - z_2|}{l}`: Slope of the reach

:math:`n`: Manning friction number

For the kinematic wave the slope of the river bed is used as slope:


.. math::

    \\\\Delta_z = \\\\frac{|z_1 - z_2|}{l}

while for the diffusive wave the slope is calculated from the actual
water head: 

.. math::

    \\\\Delta_z = \\\\frac{|h_1 - h_2|}{l}

C++ includes: ManningConnection.h ";

%feature("docstring")  cmf::river::Manning::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")  cmf::river::Manning::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::river::Manning::get_ptr "ptr get_ptr()
const ";

%feature("docstring")  cmf::river::Manning::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::river::Manning::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")  cmf::river::Manning::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")  cmf::river::Manning::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::river::Manning::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::river::Manning::left_node "flux_node::ptr
left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::river::Manning::q "real q(const flux_node
&inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::river::Manning::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::river::Manning::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")  cmf::river::Manning::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")  cmf::river::Manning::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf::river::Manning::short_string "virtual
std::string short_string() const ";

%feature("docstring")  cmf::river::Manning::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_manning___diffusive.xml
%feature("docstring") cmf_core::Manning_Diffusive "

Connecting surface water bodies using a diffusive wave.  This approach
might not be numerical stable for deep water with small gradient cmf
for experimental reasons   .. math::       q_{Manning}&=& A
R^{\\\\\\\\frac 2 3} \\\\\\\\sqrt{\\\\\\\\frac {\\\\\\\\Delta_z} n}
\\\\\\\\\\\\\\\\ A &=& \\\\\\\\frac V l \\\\\\\\mbox{, (Crosssectional
area of the     wetted crossection, Volume per length)}
\\\\\\\\\\\\\\\\ R &=& \\\\\\\\frac A     {P(d)} \\\\\\\\\\\\\\\\ P(d)
&=& \\\\\\\\mbox{ the perimeter of the wetted     crosssection, a
function of reach depth} \\\\\\\\\\\\\\\\ d(V) &=& \\\\\\\\mbox{ the
depth of the reach a function of the volume} \\\\\\\\\\\\\\\\
\\\\\\\\Delta_z     = \\\\\\\\|\\\\\\\\frac{h_1 - h_2}{l}
\\\\\\\\mbox{ Slope of the reach     waterlevels} \\\\\\\\\\\\\\\\
n&=&\\\\\\\\mbox{Manning friction number}     C++ includes:
ManningConnection.h ";

%feature("docstring")  cmf_core::Manning_Diffusive::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::river::Manning_Diffusive self,
cmf::river::OpenWaterStorage::ptr left, cmf::water::flux_node::ptr
right, IChannel reachtype) -> Manning_Diffusive
Manning_Diffusive(cmf::river::OpenWaterStorage::ptr left,
cmf::water::flux_node::ptr right, const cmf::river::IChannel
&reachtype)  Creates a diffusive wave connection between to open water
storages.  Parameters: -----------  left:  right:  The nodes to be
connected by the diffusive wave. Left needs to be an open water
storage  reachtype:  The channel geometry ";

%feature("docstring")  cmf_core::Manning_Diffusive::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::Manning_Diffusive::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::Manning_Diffusive::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::Manning_Diffusive::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::Manning_Diffusive::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::Manning_Diffusive::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::Manning_Diffusive::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::Manning_Diffusive::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::Manning_Diffusive::get_tracer_filter
"def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::Manning_Diffusive::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::Manning_Diffusive::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::Manning_Diffusive::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::Manning_Diffusive::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::Manning_Diffusive::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::Manning_Diffusive::set_tracer_filter
"def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::Manning_Diffusive::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::Manning_Diffusive::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1river_1_1_manning___diffusive.xml
%feature("docstring") cmf::river::Manning_Diffusive "

Connecting surface water bodies using a diffusive wave.

This approach might not be numerical stable for deep water with small
gradient cmf for experimental reasons 

.. math::

    
    q_{Manning}&=& A R^{\\\\frac 2 3} \\\\sqrt{\\\\frac {\\\\Delta_z} n}
    \\\\\\\\ A &=& \\\\frac V l \\\\mbox{, (Crosssectional area of the
    wetted crossection, Volume per length)} \\\\\\\\ R &=& \\\\frac A
    {P(d)} \\\\\\\\ P(d) &=& \\\\mbox{ the perimeter of the wetted
    crosssection, a function of reach depth} \\\\\\\\ d(V) &=& \\\\mbox{
    the depth of the reach a function of the volume} \\\\\\\\ \\\\Delta_z
    = \\\\|\\\\frac{h_1 - h_2}{l} \\\\mbox{ Slope of the reach
    waterlevels} \\\\\\\\ n&=&\\\\mbox{Manning friction number}
    



C++ includes: ManningConnection.h ";

%feature("docstring")
cmf::river::Manning_Diffusive::Manning_Diffusive "Manning_Diffusive(cmf::river::OpenWaterStorage::ptr left,
cmf::water::flux_node::ptr right, const cmf::river::IChannel
&reachtype)

Creates a diffusive wave connection between to open water storages.

Parameters:
-----------

left:  right:  The nodes to be connected by the diffusive wave. Left
needs to be an open water storage

reachtype:  The channel geometry ";

%feature("docstring")  cmf::river::Manning_Diffusive::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")  cmf::river::Manning_Diffusive::exchange_target
"void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")  cmf::river::Manning_Diffusive::get_ptr "ptr
get_ptr() const ";

%feature("docstring")  cmf::river::Manning_Diffusive::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::river::Manning_Diffusive::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::river::Manning_Diffusive::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::river::Manning_Diffusive::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::river::Manning_Diffusive::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::river::Manning_Diffusive::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::river::Manning_Diffusive::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::river::Manning_Diffusive::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::river::Manning_Diffusive::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::river::Manning_Diffusive::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::river::Manning_Diffusive::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf::river::Manning_Diffusive::short_string "virtual std::string short_string() const ";

%feature("docstring")  cmf::river::Manning_Diffusive::to_string "virtual std::string to_string() const ";


// File: classcmf__core_1_1_manning___kinematic.xml
%feature("docstring") cmf_core::Manning_Kinematic "

Connecting surface water bodies using a kinematic wave.  Note the
fixed gradient :math:`\\\\\\\\Delta_z`   .. math:: q_{Manning}&=& A
R^{\\\\\\\\frac 2 3} \\\\\\\\sqrt{\\\\\\\\frac {\\\\\\\\Delta_z} n}
\\\\\\\\\\\\\\\\ A &=& \\\\\\\\frac V l \\\\\\\\mbox{, (Crosssectional
area of the     wetted crossection, Volume per length)}
\\\\\\\\\\\\\\\\ R &=& \\\\\\\\frac A     {P(d)} \\\\\\\\\\\\\\\\ P(d)
&=& \\\\\\\\mbox{ the perimeter of the wetted crosssection, a function
of reach depth} \\\\\\\\\\\\\\\\ d(V) &=& \\\\\\\\mbox{     the depth
of the reach a function of the volume} \\\\\\\\\\\\\\\\
\\\\\\\\Delta_z     &=& \\\\\\\\frac{\\\\\\\\|z_1 - z_2\\\\\\\\|}{l}
\\\\\\\\mbox{ Slope of the reach} \\\\\\\\\\\\\\\\
n&=&\\\\\\\\mbox{Manning friction number}     C++ includes:
ManningConnection.h ";

%feature("docstring")  cmf_core::Manning_Kinematic::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::river::Manning_Kinematic self,
cmf::river::OpenWaterStorage::ptr left, cmf::water::flux_node::ptr
right, IChannel reachtype) -> Manning_Kinematic
Manning_Kinematic(cmf::river::OpenWaterStorage::ptr left,
cmf::water::flux_node::ptr right, const cmf::river::IChannel
&reachtype)  Creates a kinematic wave connection between to open water
storages.  Parameters: -----------  left:  right:  The nodes to be
connected by the kinematic wave. Left needs to be an open water
storage  reachtype:  The channel geometry ";

%feature("docstring")  cmf_core::Manning_Kinematic::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::Manning_Kinematic::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::Manning_Kinematic::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::Manning_Kinematic::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::Manning_Kinematic::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::Manning_Kinematic::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::Manning_Kinematic::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::Manning_Kinematic::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::Manning_Kinematic::get_tracer_filter
"def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::Manning_Kinematic::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::Manning_Kinematic::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::Manning_Kinematic::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::Manning_Kinematic::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::Manning_Kinematic::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::Manning_Kinematic::set_tracer_filter
"def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::Manning_Kinematic::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::Manning_Kinematic::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1river_1_1_manning___kinematic.xml
%feature("docstring") cmf::river::Manning_Kinematic "

Connecting surface water bodies using a kinematic wave.

Note the fixed gradient :math:`\\\\Delta_z` 

.. math::

    
    q_{Manning}&=& A R^{\\\\frac 2 3} \\\\sqrt{\\\\frac {\\\\Delta_z} n}
    \\\\\\\\ A &=& \\\\frac V l \\\\mbox{, (Crosssectional area of the
    wetted crossection, Volume per length)} \\\\\\\\ R &=& \\\\frac A
    {P(d)} \\\\\\\\ P(d) &=& \\\\mbox{ the perimeter of the wetted
    crosssection, a function of reach depth} \\\\\\\\ d(V) &=& \\\\mbox{
    the depth of the reach a function of the volume} \\\\\\\\ \\\\Delta_z
    &=& \\\\frac{\\\\|z_1 - z_2\\\\|}{l} \\\\mbox{ Slope of the reach}
    \\\\\\\\ n&=&\\\\mbox{Manning friction number} 



C++ includes: ManningConnection.h ";

%feature("docstring")
cmf::river::Manning_Kinematic::Manning_Kinematic "Manning_Kinematic(cmf::river::OpenWaterStorage::ptr left,
cmf::water::flux_node::ptr right, const cmf::river::IChannel
&reachtype)

Creates a kinematic wave connection between to open water storages.

Parameters:
-----------

left:  right:  The nodes to be connected by the kinematic wave. Left
needs to be an open water storage

reachtype:  The channel geometry ";

%feature("docstring")  cmf::river::Manning_Kinematic::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")  cmf::river::Manning_Kinematic::exchange_target
"void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")  cmf::river::Manning_Kinematic::get_ptr "ptr
get_ptr() const ";

%feature("docstring")  cmf::river::Manning_Kinematic::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::river::Manning_Kinematic::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::river::Manning_Kinematic::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::river::Manning_Kinematic::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::river::Manning_Kinematic::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::river::Manning_Kinematic::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::river::Manning_Kinematic::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::river::Manning_Kinematic::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::river::Manning_Kinematic::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::river::Manning_Kinematic::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::river::Manning_Kinematic::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf::river::Manning_Kinematic::short_string "virtual std::string short_string() const ";

%feature("docstring")  cmf::river::Manning_Kinematic::to_string "virtual std::string to_string() const ";


// File: classcmf_1_1maps_1_1_map.xml
%feature("docstring") cmf::maps::Map "

A Map is the base class for different spatial data distributions. The
base version contains returns always the default value  A Map should
implement the following functions: __iter__, returns an iterator over
the items of a map values(), returns an iterator over the different
objects of a map __call__(x,y,z), returns the object belonging to the
position x,y,z ";

%feature("docstring")  cmf::maps::Map::__init__ "def __init__(self,
default=None) ";

%feature("docstring")  cmf::maps::Map::__call__ "def __call__(self,
x, y, z=0)

returns default, regardless of the position given ";

%feature("docstring")  cmf::maps::Map::__iter__ "def __iter__(self)
";

%feature("docstring")  cmf::maps::Map::__nonzero__ "def
__nonzero__(self) ";

%feature("docstring")  cmf::maps::Map::values "def values(self) ";


// File: classcmf__core_1_1_matrix_infiltration.xml
%feature("docstring") cmf_core::MatrixInfiltration "

Connects the surfacewater and the most upper layer using a Richards
equation like infiltration model.  The potential infiltration is
calculated according to the Richards equation. The gradient is from
the cell surface to the center of the first layer and the conductivity
is the geometric mean of the wetted surface ( :math:`K_{sat}`) and the
conductivity of the layer center ( :math:`K(\\\\\\\\theta_{layer})` ..
math::       q_{max} &=&     \\\\\\\\frac{\\\\\\\\Psi_{surface} -
\\\\\\\\Psi_{soil}}{\\\\\\\\Delta z} K A_{cell}     \\\\\\\\\\\\\\\\ K
&=&
\\\\\\\\sqrt{K\\\\\\\\left(\\\\\\\\theta_{layer}\\\\\\\\right)K_{sat}}
\\\\\\\\\\\\\\\\ \\\\\\\\Delta z &=& z_{cell} - z_{layer center} If
the surface water is modeled by a distinct water storage, the actual
infiltration is given as the product of the potential infiltration
with the coverage of the surface water
cmf::upslope::Cell::surface_water_coverage   .. math::      q_{act} =
q_{max}     \\\\\\\\frac{A_{water}}{A_{cell}}  If the surface water is
no storage on its own, but just a water distribution node, the actual
infiltration is the minimum of the potential infiltration and the
current inflow (rain, snow melt) to the surface   .. math:: q_{act} =
\\\\\\\\min\\\\\\\\left(q_{max},
\\\\\\\\sum{q_{in,surfacewater}}\\\\\\\\right)  C++ includes:
infiltration.h ";

%feature("docstring")  cmf_core::MatrixInfiltration::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::MatrixInfiltration self,
cmf::upslope::SoilLayer::ptr soilwater, cmf::water::flux_node::ptr
surfacewater) -> MatrixInfiltration
MatrixInfiltration(cmf::upslope::SoilLayer::ptr soilwater,
cmf::water::flux_node::ptr surfacewater) ";

%feature("docstring")  cmf_core::MatrixInfiltration::__contains__ "def __contains__(self, cmp) ";

%feature("docstring")  cmf_core::MatrixInfiltration::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::MatrixInfiltration::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::MatrixInfiltration::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::MatrixInfiltration::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::MatrixInfiltration::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::MatrixInfiltration::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::MatrixInfiltration::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::MatrixInfiltration::get_tracer_filter
"def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::MatrixInfiltration::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::MatrixInfiltration::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::MatrixInfiltration::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::MatrixInfiltration::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::MatrixInfiltration::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::MatrixInfiltration::set_tracer_filter
"def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::MatrixInfiltration::short_string "def short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::MatrixInfiltration::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::MatrixInfiltration::use_for_cell "def use_for_cell(args, kwargs)

use_for_cell(Cell c) ";


// File: classcmf_1_1upslope_1_1connections_1_1_matrix_infiltration.xml
%feature("docstring") cmf::upslope::connections::MatrixInfiltration "

Connects the surfacewater and the most upper layer using a Richards
equation like infiltration model.

The potential infiltration is calculated according to the Richards
equation. The gradient is from the cell surface to the center of the
first layer and the conductivity is the geometric mean of the wetted
surface ( :math:`K_{sat}`) and the conductivity of the layer center (
:math:`K(\\\\theta_{layer})` 

.. math::

     q_{max} &=&
    \\\\frac{\\\\Psi_{surface} - \\\\Psi_{soil}}{\\\\Delta z} K A_{cell}
    \\\\\\\\ K &=& \\\\sqrt{K\\\\left(\\\\theta_{layer}\\\\right)K_{sat}}
    \\\\\\\\ \\\\Delta z &=& z_{cell} - z_{layer center}
    



If the surface water is modeled by a distinct water storage, the
actual infiltration is given as the product of the potential
infiltration with the coverage of the surface water
cmf::upslope::Cell::surface_water_coverage 

.. math::

    q_{act} = q_{max}
    \\\\frac{A_{water}}{A_{cell}}

If the surface water is no storage on its own, but just a water
distribution node, the actual infiltration is the minimum of the
potential infiltration and the current inflow (rain, snow melt) to the
surface 

.. math::

    q_{act} = \\\\min\\\\left(q_{max},
    \\\\sum{q_{in,surfacewater}}\\\\right)

C++ includes: infiltration.h ";

%feature("docstring")
cmf::upslope::connections::MatrixInfiltration::MatrixInfiltration "MatrixInfiltration(cmf::upslope::SoilLayer::ptr soilwater,
cmf::water::flux_node::ptr surfacewater) ";

%feature("docstring")
cmf::upslope::connections::MatrixInfiltration::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::MatrixInfiltration::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::upslope::connections::MatrixInfiltration::get_ptr "ptr get_ptr()
const ";

%feature("docstring")
cmf::upslope::connections::MatrixInfiltration::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::MatrixInfiltration::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::MatrixInfiltration::get_tracer_filter "real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::MatrixInfiltration::get_tracer_filter "real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::MatrixInfiltration::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::MatrixInfiltration::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")
cmf::upslope::connections::MatrixInfiltration::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::MatrixInfiltration::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::MatrixInfiltration::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::MatrixInfiltration::set_tracer_filter "void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::MatrixInfiltration::set_tracer_filter "void set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::MatrixInfiltration::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::MatrixInfiltration::to_string "virtual
std::string to_string() const ";


// File: classcmf_1_1river_1_1_mean_channel.xml
%feature("docstring") cmf::river::MeanChannel "

A combination of two channel geometries.

C++ includes: ReachType.h ";

%feature("docstring")  cmf::river::MeanChannel::MeanChannel "MeanChannel(const IChannel &channel1, const IChannel &channel2)

Creates the mean geometry from the two channel geometries. ";

%feature("docstring")  cmf::river::MeanChannel::MeanChannel "MeanChannel(const MeanChannel &meanChannel) ";

%feature("docstring")  cmf::river::MeanChannel::~MeanChannel "virtual
~MeanChannel() ";

%feature("docstring")  cmf::river::MeanChannel::A "virtual double
A(double V) const

Returns the area of the surface for a given volume. ";

%feature("docstring")  cmf::river::MeanChannel::copy "MeanChannel*
copy() const ";

%feature("docstring")  cmf::river::MeanChannel::get_channel_width "double get_channel_width(double depth) const

Calculates the flow width from a given actual depth [m] using the
actual IChannel geometry. ";

%feature("docstring")  cmf::river::MeanChannel::get_depth "double
get_depth(double area) const

Calculates the actual depth of the reach using the IChannel geometry.

get_depth of the reach [m]

Parameters:
-----------

area:  Wetted area of a river cross section [m2], can be obtained by
V/l, where V is the stored volume and l is the reach length ";

%feature("docstring")  cmf::river::MeanChannel::get_flux_crossection "double get_flux_crossection(double depth) const

Calculates the wetted area from a given depth using the IChannel
geometry.

In most cases use get_flux_crossection=V/l, where V is the stored
volume and l is the reach length Wetted area of a river cross section
[m2]

Parameters:
-----------

depth:  depth of the reach [m] ";

%feature("docstring")  cmf::river::MeanChannel::get_length "double
get_length() const

Length of the reach. ";

%feature("docstring")  cmf::river::MeanChannel::get_nManning "virtual
double get_nManning() const ";

%feature("docstring")  cmf::river::MeanChannel::get_wetted_perimeter "double get_wetted_perimeter(double depth) const

Calculates the wetted perimeter from a given actual depth [m] using
the actual IChannel geometry. ";

%feature("docstring")  cmf::river::MeanChannel::h "virtual double
h(double V) const

Returns the depth of a given volume. ";

%feature("docstring")  cmf::river::MeanChannel::q "virtual double
q(double h, double slope) const ";

%feature("docstring")  cmf::river::MeanChannel::qManning "virtual
double qManning(double A, double slope) const

Calculates the flow rate from a given water volume in the reach


.. math::

     q_{Manning}&=& A R^{\\\\frac 2 3}
    \\\\sqrt{\\\\frac {\\\\Delta_z} n} \\\\\\\\ A &=& \\\\frac V l
    \\\\mbox{, (Crosssectional area of the wetted crossection, Volume per
    length)} \\\\\\\\ R &=& \\\\frac A {P(d)} \\\\\\\\ P(d) &=& \\\\mbox{
    the perimeter of the wetted crosssection, a function of reach depth}
    \\\\\\\\ d(V) &=& \\\\mbox{ the depth of the reach a function of the
    volume} \\\\\\\\ \\\\Delta_z &=& \\\\frac{z_{max} - z_{min}}{l}
    \\\\mbox{ Slope of the reach} 

.

Flow rate [m3/s]

Parameters:
-----------

A:  The area of the cross section [m2]

slope:  The slope of the reach [m/m] ";

%feature("docstring")  cmf::river::MeanChannel::set_nManning "virtual
void set_nManning(double nManning) ";

%feature("docstring")  cmf::river::MeanChannel::typecode "char
typecode() const ";

%feature("docstring")  cmf::river::MeanChannel::V "virtual double
V(double h) const ";


// File: classcmf__core_1_1_mean_channel.xml
%feature("docstring") cmf_core::MeanChannel "

A combination of two channel geometries.  C++ includes: ReachType.h ";

%feature("docstring")  cmf_core::MeanChannel::__init__ "def
__init__(self, args)

__init__(cmf::river::MeanChannel self, IChannel channel1, IChannel
channel2) -> MeanChannel __init__(cmf::river::MeanChannel self,
MeanChannel meanChannel) -> MeanChannel  MeanChannel(const MeanChannel
&meanChannel) ";

%feature("docstring")  cmf_core::MeanChannel::A "def A(self, args,
kwargs)

A(IVolumeHeightFunction self, double V) -> double  virtual double
A(double V) const =0  Returns the area of the surface for a given
volume. ";

%feature("docstring")  cmf_core::MeanChannel::copy "def copy(self,
args, kwargs)

copy(MeanChannel self) -> MeanChannel  MeanChannel* copy() const ";

%feature("docstring")  cmf_core::MeanChannel::get_channel_width "def
get_channel_width(self, args, kwargs)

get_channel_width(IChannel self, double depth) -> double  virtual
double get_channel_width(double depth) const =0  Calculates the flow
width from a given actual depth [m] using the actual IChannel
geometry. ";

%feature("docstring")  cmf_core::MeanChannel::get_depth "def
get_depth(self, args, kwargs)

get_depth(IChannel self, double area) -> double  virtual double
get_depth(double area) const =0  Calculates the actual depth of the
reach using the IChannel geometry.  get_depth of the reach [m]
Parameters: -----------  area:  Wetted area of a river cross section
[m2], can be obtained by V/l, where V is the stored volume and l is
the reach length ";

%feature("docstring")  cmf_core::MeanChannel::get_flux_crossection "def get_flux_crossection(self, args, kwargs)

get_flux_crossection(IChannel self, double depth) -> double  virtual
double get_flux_crossection(double depth) const =0  Calculates the
wetted area from a given depth using the IChannel geometry.  In most
cases use get_flux_crossection=V/l, where V is the stored volume and l
is the reach length Wetted area of a river cross section [m2]
Parameters: -----------  depth:  depth of the reach [m] ";

%feature("docstring")  cmf_core::MeanChannel::get_length "def
get_length(self, args, kwargs)

get_length(IChannel self) -> double  virtual double get_length() const
=0  Length of the reach. ";

%feature("docstring")  cmf_core::MeanChannel::get_nManning "def
get_nManning(self, args, kwargs)

get_nManning(IChannel self) -> double  virtual double get_nManning()
const =0 ";

%feature("docstring")  cmf_core::MeanChannel::get_wetted_perimeter "def get_wetted_perimeter(self, args, kwargs)

get_wetted_perimeter(IChannel self, double depth) -> double  virtual
double get_wetted_perimeter(double depth) const =0  Calculates the
wetted perimeter from a given actual depth [m] using the actual
IChannel geometry. ";

%feature("docstring")  cmf_core::MeanChannel::h "def h(self, args,
kwargs)

h(IVolumeHeightFunction self, double V) -> double  virtual double
h(double V) const =0  Returns the depth of a given volume. ";

%feature("docstring")  cmf_core::MeanChannel::q "def q(self, args,
kwargs)

q(IVolumeHeightFunction self, double h, double slope) -> double
virtual double q(double h, double slope) const ";

%feature("docstring")  cmf_core::MeanChannel::qManning "def
qManning(self, args, kwargs)

qManning(IChannel self, double A, double slope) -> double  virtual
double qManning(double A, double slope) const  Calculates the flow
rate from a given water volume in the reach   .. math:: q_{Manning}&=&
A R^{\\\\\\\\frac 2 3}     \\\\\\\\sqrt{\\\\\\\\frac {\\\\\\\\Delta_z}
n} \\\\\\\\\\\\\\\\ A &=& \\\\\\\\frac V l \\\\\\\\mbox{,
(Crosssectional area of the wetted crossection, Volume per
length)} \\\\\\\\\\\\\\\\ R &=& \\\\\\\\frac A {P(d)} \\\\\\\\\\\\\\\\
P(d) &=& \\\\\\\\mbox{     the perimeter of the wetted crosssection, a
function of reach depth}     \\\\\\\\\\\\\\\\ d(V) &=& \\\\\\\\mbox{
the depth of the reach a function of the volume} \\\\\\\\\\\\\\\\
\\\\\\\\Delta_z &=& \\\\\\\\frac{z_{max} - z_{min}}{l}
\\\\\\\\mbox{ Slope of the reach}   .  Flow rate [m3/s]  Parameters:
-----------  A:  The area of the cross section [m2]  slope:  The slope
of the reach [m/m] ";

%feature("docstring")  cmf_core::MeanChannel::set_nManning "def
set_nManning(self, args, kwargs)

set_nManning(IChannel self, double val)  virtual void
set_nManning(double val)=0 ";

%feature("docstring")  cmf_core::MeanChannel::typecode "def
typecode(self, args, kwargs)

typecode(IChannel self) -> char  virtual char typecode() const =0 ";

%feature("docstring")  cmf_core::MeanChannel::V "def V(self, args,
kwargs)

V(IVolumeHeightFunction self, double h) -> double  virtual double
V(double h) const =0 ";


// File: classcmf_1_1atmosphere_1_1_meteorology.xml
%feature("docstring") cmf::atmosphere::Meteorology "

An abstract class, for objects generating Weather records at a
specific time.

C++ includes: meteorology.h ";

%feature("docstring")  cmf::atmosphere::Meteorology::~Meteorology "virtual ~Meteorology() ";

%feature("docstring")  cmf::atmosphere::Meteorology::copy "virtual
Meteorology* copy() const =0

Returns a copy of the meteorology object. Pure virtual function, needs
to be implemented. ";

%feature("docstring")
cmf::atmosphere::Meteorology::get_instrument_height "virtual real
get_instrument_height() const =0

Returns the height of the instruments above canopy. ";

%feature("docstring")  cmf::atmosphere::Meteorology::get_weather "virtual cmf::atmosphere::Weather get_weather(cmf::math::Time t) const
=0

Returns the Weather at time t. Pure virtual function. Must get
implemented by child functions. ";


// File: classcmf__core_1_1_meteorology.xml
%feature("docstring") cmf_core::Meteorology "

An abstract class, for objects generating Weather records at a
specific time.  C++ includes: meteorology.h ";

%feature("docstring")  cmf_core::Meteorology::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::Meteorology::__call__ "def
__call__(self, args, kwargs)

__call__(Meteorology self, Time t) -> Weather ";

%feature("docstring")  cmf_core::Meteorology::copy "def copy(self,
args, kwargs)

copy(Meteorology self) -> Meteorology  virtual Meteorology* copy()
const =0  Returns a copy of the meteorology object. Pure virtual
function, needs to be implemented. ";

%feature("docstring")  cmf_core::Meteorology::get_instrument_height "def get_instrument_height(self, args, kwargs)

get_instrument_height(Meteorology self) -> real  virtual real
get_instrument_height() const =0  Returns the height of the
instruments above canopy. ";

%feature("docstring")  cmf_core::Meteorology::get_weather "def
get_weather(self, args, kwargs)

get_weather(Meteorology self, Time t) -> Weather  virtual
cmf::atmosphere::Weather get_weather(cmf::math::Time t) const =0
Returns the Weather at time t. Pure virtual function. Must get
implemented by child functions. ";


// File: classcmf_1_1atmosphere_1_1_meteo_station.xml
%feature("docstring") cmf::atmosphere::MeteoStation "

A meteorological station holding timeseries to create Weather records.

In order to calculate ETpot with cmf a big amount of meteorological
data is needed, more data than usually available. The MeteoStation
class can estimate missing data from a minimal set. As more data, as
one provides, the better the calculation of ETpot becomes. The minimal
data needed is Tmin and Tmax (daily) and precipitation. To calculate
the global radiation (although measured global radiation could be
inserted), the position of meteorological station in geographic
coordinates has to be set.

A meteorological station is created by
cmf::atmosphere::MeteoStationList::add_station . Usage from python:

There are two modes for the meteorology: daily=true and daily=false.
If daily=true, Radiation is given as a daily mean value. If
daily=false, Radiation is given as an hourly mean value, which shows
the dial ETpot variation but results in erronous results if the
timestep is daily.

C++ includes: meteorology.h ";

/*  Location and behaviour properties  */

%feature("docstring")  cmf::atmosphere::MeteoStation::get_position "cmf::geometry::point get_position() const ";

/*  Data access methods  */

%feature("docstring")  cmf::atmosphere::MeteoStation::get_data "cmf::atmosphere::Weather get_data(cmf::math::Time t, double height)
const

Returns the current Atmosphere state. Uses default values for missing
timeseries. ";

%feature("docstring")  cmf::atmosphere::MeteoStation::use_for_cell "void use_for_cell(cmf::upslope::Cell &c)

Connects this meteostation as a meteo data provider with the cell. ";

%feature("docstring")
cmf::atmosphere::MeteoStation::SetSunshineFraction "void
SetSunshineFraction(cmf::math::timeseries sunshine_duration)

Calculates a timeseries of the sunshine fraction (to put into
Sunshine) from a timeseries of absolute sunshine duration

seehttp://www.fao.org/docrep/X0490E/x0490e07.htm#radiation


.. math::

     \\\\phi &=& \\\\frac{(\\\\mbox{geogr.
    Latitude})^\\\\circ \\\\pi}{180^\\\\circ} \\\\mbox{ Latitude in }rad
    \\\\\\\\ \\\\delta &=& 0.409 \\\\sin\\\\left(\\\\frac{2\\\\pi}{365}DOY
    - 1.39\\\\right) \\\\mbox{ Declination, DOY is day of year}\\\\\\\\
    \\\\omega_s &=& \\\\arccos(-\\\\tan\\\\phi\\\\tan\\\\delta) \\\\mbox{
    Sunset angle in }rad \\\\\\\\ N &=& \\\\frac{24}{\\\\pi}\\\\omega_s
    \\\\mbox{ potential duration of sunshine in }h \\\\\\\\ \\\\frac n N
    &=& n\\\\mbox{ absolute sunshine duration in }h 

 ";

/*  Timeseries of meteorological data  */

%feature("docstring")  cmf::atmosphere::MeteoStation::MeteoStation "MeteoStation(const cmf::atmosphere::MeteoStation &other)

Copy c'tor. ";


// File: classcmf__core_1_1_meteo_station.xml
%feature("docstring") cmf_core::MeteoStation "

A meteorological station holding timeseries to create Weather records.
In order to calculate ETpot with cmf a big amount of meteorological
data is needed, more data than usually available. The MeteoStation
class can estimate missing data from a minimal set. As more data, as
one provides, the better the calculation of ETpot becomes. The minimal
data needed is Tmin and Tmax (daily) and precipitation. To calculate
the global radiation (although measured global radiation could be
inserted), the position of meteorological station in geographic
coordinates has to be set.  A meteorological station is created by
cmf::atmosphere::MeteoStationList::add_station . Usage from python:
There are two modes for the meteorology: daily=true and daily=false.
If daily=true, Radiation is given as a daily mean value. If
daily=false, Radiation is given as an hourly mean value, which shows
the dial ETpot variation but results in erronous results if the
timestep is daily.  C++ includes: meteorology.h ";

%feature("docstring")  cmf_core::MeteoStation::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::atmosphere::MeteoStation self, MeteoStation other) ->
MeteoStation  MeteoStation(const cmf::atmosphere::MeteoStation &other)
Copy c'tor. ";

%feature("docstring")  cmf_core::MeteoStation::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::MeteoStation::get_data "def
get_data(self, args, kwargs)

get_data(MeteoStation self, Time t, double height) -> Weather
cmf::atmosphere::Weather get_data(cmf::math::Time t, double height)
const  Returns the current Atmosphere state. Uses default values for
missing timeseries. ";

%feature("docstring")  cmf_core::MeteoStation::get_position "def
get_position(self, args, kwargs)

get_position(MeteoStation self) -> point  cmf::geometry::point
get_position() const ";

%feature("docstring")  cmf_core::MeteoStation::SetSunshineFraction "def SetSunshineFraction(self, args, kwargs)

SetSunshineFraction(MeteoStation self, timeseries sunshine_duration)
void SetSunshineFraction(cmf::math::timeseries sunshine_duration)
Calculates a timeseries of the sunshine fraction (to put into
Sunshine) from a timeseries of absolute sunshine duration
seehttp://www.fao.org/docrep/X0490E/x0490e07.htm#radiation   .. math::
\\\\\\\\phi &=& \\\\\\\\frac{(\\\\\\\\mbox{geogr.
Latitude})^\\\\\\\\circ \\\\\\\\pi}{180^\\\\\\\\circ} \\\\\\\\mbox{
Latitude in }rad     \\\\\\\\\\\\\\\\ \\\\\\\\delta &=& 0.409
\\\\\\\\sin\\\\\\\\left(\\\\\\\\frac{2\\\\\\\\pi}{365}DOY     -
1.39\\\\\\\\right) \\\\\\\\mbox{ Declination, DOY is day of
year}\\\\\\\\\\\\\\\\     \\\\\\\\omega_s &=&
\\\\\\\\arccos(-\\\\\\\\tan\\\\\\\\phi\\\\\\\\tan\\\\\\\\delta)
\\\\\\\\mbox{     Sunset angle in }rad \\\\\\\\\\\\\\\\ N &=&
\\\\\\\\frac{24}{\\\\\\\\pi}\\\\\\\\omega_s     \\\\\\\\mbox{
potential duration of sunshine in }h \\\\\\\\\\\\\\\\ \\\\\\\\frac n N
&=& n\\\\\\\\mbox{ absolute sunshine duration in }h ";

%feature("docstring")  cmf_core::MeteoStation::TimeseriesDictionary "def TimeseriesDictionary(self) ";

%feature("docstring")  cmf_core::MeteoStation::use_for_cell "def
use_for_cell(self, args, kwargs)

use_for_cell(MeteoStation self, Cell c)  void
use_for_cell(cmf::upslope::Cell &c)  Connects this meteostation as a
meteo data provider with the cell. ";


// File: classcmf_1_1atmosphere_1_1_meteo_station_list.xml
%feature("docstring") cmf::atmosphere::MeteoStationList "

A list of meteorological stations.

Can find the nearest station for a position and calculate the
temperature lapse

C++ includes: meteorology.h ";

%feature("docstring")
cmf::atmosphere::MeteoStationList::MeteoStationList "MeteoStationList()

Create empty list. ";

%feature("docstring")
cmf::atmosphere::MeteoStationList::MeteoStationList "MeteoStationList(const MeteoStationList &copy)

Copy c'tor. ";

%feature("docstring")  cmf::atmosphere::MeteoStationList::add_station
"MeteoStation::ptr add_station(std::string name, cmf::geometry::point
position, double latitude=51.0, double longitude=8.0, double tz=1.0,
cmf::math::Time startTime=cmf::math::Time(1, 1, 2001), cmf::math::Time
timestep=cmf::math::day)

Creates a meteorological station at a certain position and adds it to
the list.

Parameters:
-----------

name:  Name of the station

position:  The location of the station in map coordinates

latitude:  Latitude of the study area (for solar radiation)

longitude:  Longitude of the study area (for solar time)

tz:  Time zone of the study area (e.g Germany +1,U.S. Pacific time -8

startTime:  Date of the beginning of the climatic data (may be changed
for each time series later)

timestep:  Frequency of climatic data (may be changed for each time
series later) ";

%feature("docstring")
cmf::atmosphere::MeteoStationList::calculate_Temp_lapse "double
calculate_Temp_lapse(cmf::math::Time begin, cmf::math::Time step,
cmf::math::Time end)

Calculates the temperature lapse from all stations in the list and
sets the T_lapse attribute of each station.

Returns the average lapse over the whole period. ";

%feature("docstring")
cmf::atmosphere::MeteoStationList::reference_to_nearest "MeteoStationReference reference_to_nearest(const cmf::geometry::point
&position, double z_weight=0) const

Creates a MeteoStationReference from the nearest station to position
at position.

The distance is calculated as :math:`d=\\\\sqrt{(x_{s} - x_{l})^2 + (y_{s} - y_{l})^2} + \\\\lambda_z\\\\|z_{s} - z_{l}\\\\|` Where :math:`s` is the
station and :math:`l` is the locatable A Meteorology using the data of the
nearest station to position

Parameters:
-----------

position:  The position (any locatable, like e.g. Cell possible) to
look for the station. The reference should be owned by the locatable

z_weight:  The weight of the height difference :math:`\\\\lambda_z` ";

%feature("docstring")
cmf::atmosphere::MeteoStationList::remove_station "ptrdiff_t
remove_station(ptrdiff_t index)

Removes a station and returns the number of remaining references to
the removed station. If the station is deleted, 0 is returned. ";

%feature("docstring")  cmf::atmosphere::MeteoStationList::size "size_t size() const

Returns the number of stations. ";


// File: classcmf__core_1_1_meteo_station_list.xml
%feature("docstring") cmf_core::MeteoStationList "

A list of meteorological stations.  Can find the nearest station for a
position and calculate the temperature lapse  C++ includes:
meteorology.h ";

%feature("docstring")  cmf_core::MeteoStationList::__init__ "def
__init__(self, args)

__init__(cmf::atmosphere::MeteoStationList self) -> MeteoStationList
__init__(cmf::atmosphere::MeteoStationList self, MeteoStationList
copy) -> MeteoStationList  MeteoStationList(const MeteoStationList
&copy)  Copy c'tor. ";

%feature("docstring")  cmf_core::MeteoStationList::__getitem__ "def
__getitem__(self, args)

__getitem__(MeteoStationList self, ptrdiff_t index) ->
cmf::atmosphere::MeteoStation::ptr __getitem__(MeteoStationList self,
std::string const & Name) -> cmf::atmosphere::MeteoStation::ptr ";

%feature("docstring")  cmf_core::MeteoStationList::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::MeteoStationList::__len__ "def
__len__(self, args, kwargs)

__len__(MeteoStationList self) -> size_t  size_t size() const  Returns
the number of stations. ";

%feature("docstring")  cmf_core::MeteoStationList::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::MeteoStationList::add_station "def
add_station(self, args, kwargs)

add_station(MeteoStationList self, std::string name, point position,
double latitude=51.0, double longitude=8.0, double tz=1.0, Time
startTime, Time timestep) -> cmf::atmosphere::MeteoStation::ptr
MeteoStation::ptr add_station(std::string name, cmf::geometry::point
position, double latitude=51.0, double longitude=8.0, double tz=1.0,
cmf::math::Time startTime=cmf::math::Time(1, 1, 2001), cmf::math::Time
timestep=cmf::math::day)  Creates a meteorological station at a
certain position and adds it to the list.  Parameters: -----------
name:  Name of the station  position:  The location of the station in
map coordinates  latitude:  Latitude of the study area (for solar
radiation)  longitude:  Longitude of the study area (for solar time)
tz:  Time zone of the study area (e.g Germany +1,U.S. Pacific time -8
startTime:  Date of the beginning of the climatic data (may be changed
for each time series later)  timestep:  Frequency of climatic data
(may be changed for each time series later) ";

%feature("docstring")
cmf_core::MeteoStationList::calculate_Temp_lapse "def
calculate_Temp_lapse(self, args, kwargs)

calculate_Temp_lapse(MeteoStationList self, Time begin, Time step,
Time end) -> double  double calculate_Temp_lapse(cmf::math::Time
begin, cmf::math::Time step, cmf::math::Time end)  Calculates the
temperature lapse from all stations in the list and sets the T_lapse
attribute of each station.  Returns the average lapse over the whole
period. ";

%feature("docstring")
cmf_core::MeteoStationList::reference_to_nearest "def
reference_to_nearest(self, args, kwargs)

reference_to_nearest(MeteoStationList self, point position, double
z_weight=0) -> MeteoStationReference  MeteoStationReference
reference_to_nearest(const cmf::geometry::point &position, double
z_weight=0) const  Creates a MeteoStationReference from the nearest
station to position at position.  The distance is calculated as
:math:`d=\\\\\\\\sqrt{(x_{s} - x_{l})^2 + (y_{s} - y_{l})^2} +
\\\\\\\\lambda_z\\\\\\\\|z_{s} - z_{l}\\\\\\\\|` Where :math:`s` is
the station and :math:`l` is the locatable A Meteorology using the
data of the nearest station to position  Parameters: -----------
position:  The position (any locatable, like e.g. Cell possible) to
look for the station. The reference should be owned by the locatable
z_weight:  The weight of the height difference
:math:`\\\\\\\\lambda_z` ";

%feature("docstring")  cmf_core::MeteoStationList::remove_station "def remove_station(self, args, kwargs)

remove_station(MeteoStationList self, ptrdiff_t index) -> ptrdiff_t
ptrdiff_t remove_station(ptrdiff_t index)  Removes a station and
returns the number of remaining references to the removed station. If
the station is deleted, 0 is returned. ";


// File: classcmf_1_1atmosphere_1_1_meteo_station_reference.xml
%feature("docstring") cmf::atmosphere::MeteoStationReference "

A reference to a meteorological station.

Returns the weather at a given time for its place using
MeteoStation::T_lapse

C++ includes: meteorology.h ";

%feature("docstring")
cmf::atmosphere::MeteoStationReference::MeteoStationReference "MeteoStationReference(MeteoStation::ptr station, cmf::geometry::point
location)

Create a located reference to a meteo station.

Parameters:
-----------

station:   MeteoStation

location:  Location of the reference ";

%feature("docstring")
cmf::atmosphere::MeteoStationReference::MeteoStationReference "MeteoStationReference(const MeteoStationReference &copy) ";

%feature("docstring")  cmf::atmosphere::MeteoStationReference::copy "MeteoStationReference* copy() const

Returns a copy of the meteorology object. Pure virtual function, needs
to be implemented. ";

%feature("docstring")
cmf::atmosphere::MeteoStationReference::get_instrument_height "real
get_instrument_height() const

Creates a reference for a MeteoStation at a location. ";

%feature("docstring")
cmf::atmosphere::MeteoStationReference::get_position "cmf::geometry::point get_position() const

Returns the position of the reference. ";

%feature("docstring")
cmf::atmosphere::MeteoStationReference::get_station "MeteoStation::ptr get_station() const

Returns the station referenced. ";

%feature("docstring")
cmf::atmosphere::MeteoStationReference::get_weather "cmf::atmosphere::Weather get_weather(cmf::math::Time t) const

Returns the weather at the time t. ";


// File: classcmf__core_1_1_meteo_station_reference.xml
%feature("docstring") cmf_core::MeteoStationReference "

A reference to a meteorological station.  Returns the weather at a
given time for its place using MeteoStation::T_lapse  C++ includes:
meteorology.h ";

%feature("docstring")  cmf_core::MeteoStationReference::__init__ "def
__init__(self, args)

__init__(cmf::atmosphere::MeteoStationReference self,
cmf::atmosphere::MeteoStation::ptr station, point location) ->
MeteoStationReference __init__(cmf::atmosphere::MeteoStationReference
self, MeteoStationReference copy) -> MeteoStationReference
MeteoStationReference(const MeteoStationReference &copy) ";

%feature("docstring")  cmf_core::MeteoStationReference::__call__ "def
__call__(self, args, kwargs)

__call__(Meteorology self, Time t) -> Weather ";

%feature("docstring")  cmf_core::MeteoStationReference::copy "def
copy(self, args, kwargs)

copy(MeteoStationReference self) -> MeteoStationReference
MeteoStationReference* copy() const  Returns a copy of the meteorology
object. Pure virtual function, needs to be implemented. ";

%feature("docstring")
cmf_core::MeteoStationReference::get_instrument_height "def
get_instrument_height(self, args, kwargs)

get_instrument_height(Meteorology self) -> real  virtual real
get_instrument_height() const =0  Returns the height of the
instruments above canopy. ";

%feature("docstring")  cmf_core::MeteoStationReference::get_position "def get_position(self, args, kwargs)

get_position(MeteoStationReference self) -> point cmf::geometry::point
get_position() const  Returns the position of the reference. ";

%feature("docstring")  cmf_core::MeteoStationReference::get_station "def get_station(self, args, kwargs)

get_station(MeteoStationReference self) ->
cmf::atmosphere::MeteoStation::ptr  MeteoStation::ptr get_station()
const  Returns the station referenced. ";

%feature("docstring")  cmf_core::MeteoStationReference::get_weather "def get_weather(self, args, kwargs)

get_weather(Meteorology self, Time t) -> Weather  virtual
cmf::atmosphere::Weather get_weather(cmf::math::Time t) const =0
Returns the Weather at time t. Pure virtual function. Must get
implemented by child functions. ";


// File: classcmf__core_1_1_multi_integrator.xml
%feature("docstring") cmf_core::MultiIntegrator "

The MultiIntegrator is a wrapper for a bunch integrators. The states
of the integrators should not have direct connections over integrator
boundaries.  C++ includes: multiintegrator.h ";

%feature("docstring")  cmf_core::MultiIntegrator::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::math::MultiIntegrator self, Integrator
template_integrator, int count) -> MultiIntegrator
MultiIntegrator(const cmf::math::Integrator &template_integrator, int
count)  Creates a new MultiIntegrator.  Parameters: -----------
template_integrator:  Template for the integrators  count:  Number of
integrators ";

%feature("docstring")  cmf_core::MultiIntegrator::__call__ "def
__call__(self, t, dt=None, reset=False)

Advances the integration until `t`  A shortcut to .integrate_until
Parameters ---------- t : cmf.Time     The time step to advance to. If
t < current time, the solver will     advance to self.t + t dt :
cmf.Time, optional     The timestep for the integration. If not given
try to integrate in one step reset : bool, optional     If True, the
solver will perform a reset before starting  Returns ------- cmf.Time
The new time stamp ";

%feature("docstring")  cmf_core::MultiIntegrator::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(Integrator self, long position) ->
cmf::math::StateVariable::ptr ";

%feature("docstring")  cmf_core::MultiIntegrator::__len__ "def
__len__(self, args, kwargs)

__len__(Integrator self) -> size_t ";

%feature("docstring")  cmf_core::MultiIntegrator::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::MultiIntegrator::add_single_state "def add_single_state(self, args, kwargs)

add_single_state(Integrator self, cmf::math::StateVariable::ptr state)
virtual void add_single_state(cmf::math::StateVariable::ptr state)
Adds a single state variable to the integrator. ";

%feature("docstring")  cmf_core::MultiIntegrator::add_states "def
add_states(self, args, kwargs)

add_states(Integrator self, StateVariableOwner stateOwner)  virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)  Add state
variables from a StateVariableOwner. ";

%feature("docstring")
cmf_core::MultiIntegrator::add_states_to_integrator "def
add_states_to_integrator(self, args, kwargs)

add_states_to_integrator(MultiIntegrator self, StateVariableOwner
stateOwner, int integrator_position)  void
add_states_to_integrator(cmf::math::StateVariableOwner &stateOwner,
int integrator_position)  Add state variables from a
StateVariableOwner. ";

%feature("docstring")  cmf_core::MultiIntegrator::copy "def
copy(self, args, kwargs)

copy(MultiIntegrator self) -> MultiIntegrator  virtual
cmf::math::MultiIntegrator* copy() const  Polymorphic copy
constructor. ";

%feature("docstring")  cmf_core::MultiIntegrator::get_dt "def
get_dt(self, args, kwargs)

get_dt(Integrator self) -> Time  cmf::math::Time get_dt() const
Returns the last time step. ";

%feature("docstring")  cmf_core::MultiIntegrator::get_dxdt "def
get_dxdt(self, args, kwargs)

get_dxdt(Integrator self, Time time) -> cmf::math::num_array
cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf_core::MultiIntegrator::get_state "def
get_state(self, args, kwargs)

get_state(Integrator self, ptrdiff_t position) -> real  real
get_state(ptrdiff_t position) const  Returns the statevariable at
position Simplifies the assessment of state variables. ";

%feature("docstring")  cmf_core::MultiIntegrator::get_states "def
get_states(self, args)

get_states(Integrator self) -> cmf::math::num_array
get_states(Integrator self) -> StateVariableList  StateVariableList
get_states()  gets the state variables of the integrator ";

%feature("docstring")  cmf_core::MultiIntegrator::get_t "def
get_t(self, args, kwargs)

get_t(Integrator self) -> Time  cmf::math::Time get_t() const  Returns
the current model time. ";

%feature("docstring")  cmf_core::MultiIntegrator::integrate "def
integrate(self, args, kwargs)

integrate(Integrator self, Time t_max, Time dt) -> int  virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)=0  Integrates the
vector of state variables.  Parameters: -----------  t_max:  To stop
the model (if running in a model framework) at time steps of value
exchange e.g. full hours, the next value exchange time can be given
dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf_core::MultiIntegrator::integrate_until "def integrate_until(self, args, kwargs)

integrate_until(Integrator self, Time t_max, Time dt, bool
reset=False)  void integrate_until(cmf::math::Time t_max,
cmf::math::Time dt=Time(), bool reset=false)  Integrates the vector of
state variables until t_max.  Parameters: -----------  t_max:   Time,
the solver should run to  dt:   Time step (may be omitted)  reset:  If
true, solver is reseted before integration starts ";

%feature("docstring")  cmf_core::MultiIntegrator::reset "def
reset(self, args, kwargs)

reset(Integrator self)  virtual void reset()  Resets any saved history
(for multistep methods) ";

%feature("docstring")  cmf_core::MultiIntegrator::run "def run(self,
start=None, end=None, step=day *1, max_errors=0, reset=False)

Returns an iterator over the timesteps start..end  **Examples:**  >>>
solver=cmf.CVodeIntegrator(...) >>> for t in solver.run(solver.t,
solver.t + cmf.week, cmf.h): >>>    print(t, solver[0].state) or with
list comprehension >>> states = [solver[0].state for t in
solver.run(solver.t, solver.t + cmf.week, cmf.h)]  Parameters
---------- start : cmf.Time, optional Start time for the solver
iteration end : cmf.Time, optional End time of the iteration step :
cmf.Time, optional Step size for the integration max_errors: int
Number of tolerated errors. If >0, up to these number of runtime
errors will be saved with their time and the integration proceeds
after a reset of the solver. Some systems operate with values close to
their physical limits and inifinite values in the integration can
easily occur. For these kind of systems set max_errors to eg. 10. A
larger number of errors should be eliminated usually. reset: bool If
True, the solver performs a `reset` at every time step  Yields ------
cmf.Time      the actual timestep ";

%feature("docstring")  cmf_core::MultiIntegrator::set_state "def
set_state(self, args, kwargs)

set_state(Integrator self, ptrdiff_t position, real newState)  void
set_state(ptrdiff_t position, real newState)  Simplifies the
assessment of state variables. ";

%feature("docstring")  cmf_core::MultiIntegrator::set_t "def
set_t(self, args, kwargs)

set_t(Integrator self, Time val)  void set_t(cmf::math::Time val) Sets
the current model time. ";

%feature("docstring")  cmf_core::MultiIntegrator::size "def
size(self, args, kwargs)

size(Integrator self) -> size_t  size_t size() const  returns the
number of state variables ";


// File: classcmf_1_1math_1_1_multi_integrator.xml
%feature("docstring") cmf::math::MultiIntegrator "

The MultiIntegrator is a wrapper for a bunch integrators. The states
of the integrators should not have direct connections over integrator
boundaries.

C++ includes: multiintegrator.h ";

/*  Accuracy parameters  */

/*  model time  */

%feature("docstring")  cmf::math::MultiIntegrator::get_t "cmf::math::Time get_t() const

Returns the current model time. ";

%feature("docstring")  cmf::math::MultiIntegrator::set_t "void
set_t(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::MultiIntegrator::get_dt "cmf::math::Time get_dt() const

Returns the last time step. ";

/*  Integrate  */

%feature("docstring")  cmf::math::MultiIntegrator::integrate_until "void integrate_until(cmf::math::Time t_max, cmf::math::Time dt=Time(),
bool reset=false)

Integrates the vector of state variables until t_max.

Parameters:
-----------

t_max:   Time, the solver should run to

dt:   Time step (may be omitted)

reset:  If true, solver is reseted before integration starts ";

%feature("docstring")  cmf::math::MultiIntegrator::MultiIntegrator "MultiIntegrator(const cmf::math::Integrator &template_integrator, int
count)

Creates a new MultiIntegrator.

Parameters:
-----------

template_integrator:  Template for the integrators

count:  Number of integrators ";

%feature("docstring")  cmf::math::MultiIntegrator::add_single_state "virtual void add_single_state(cmf::math::StateVariable::ptr state)

Adds a single state variable to the integrator. ";

%feature("docstring")  cmf::math::MultiIntegrator::add_states "void
add_states(cmf::math::StateVariableOwner &stateOwner)

Only there to override Integrator::AddStatesFromOwner. Throws an
exception. Use add_states_to_integrator instead. ";

%feature("docstring")
cmf::math::MultiIntegrator::add_states_to_integrator "void
add_states_to_integrator(cmf::math::StateVariableOwner &stateOwner,
int integrator_position)

Add state variables from a StateVariableOwner. ";

%feature("docstring")
cmf::math::MultiIntegrator::add_values_to_states "void
add_values_to_states(const num_array &operands)

Adds the values in operands to the current states. ";

%feature("docstring")  cmf::math::MultiIntegrator::copy "virtual
cmf::math::MultiIntegrator* copy() const

Polymorphic copy constructor. ";

%feature("docstring")  cmf::math::MultiIntegrator::copy_dxdt "void
copy_dxdt(Time time, num_array &destination, real factor=1) const

Copies the derivatives at time step \"time\" to a numeric vector using
use_OpenMP.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Vector to be overwritten by the results

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::MultiIntegrator::copy_dxdt "void
copy_dxdt(Time time, real *destination, real factor=1) const

Copies the derivatives at time step \"time\" to an preallocated c
array.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Allocated c array

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::MultiIntegrator::copy_states "void
copy_states(num_array &destination) const

Copies the states to a numeric vector using use_OpenMP. ";

%feature("docstring")  cmf::math::MultiIntegrator::copy_states "void
copy_states(real *destination) const ";

%feature("docstring")  cmf::math::MultiIntegrator::get_dxdt "cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf::math::MultiIntegrator::get_state "real
get_state(ptrdiff_t position) const

Returns the statevariable at position Simplifies the assessment of
state variables. ";

%feature("docstring")  cmf::math::MultiIntegrator::get_states "cmf::math::num_array get_states() const ";

%feature("docstring")  cmf::math::MultiIntegrator::get_states "StateVariableList get_states()

gets the state variables of the integrator ";

%feature("docstring")  cmf::math::MultiIntegrator::integrate "int
integrate(cmf::math::Time t_max, cmf::math::Time dt)

Integrates the vector of state variables.

Parameters:
-----------

t_max:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf::math::MultiIntegrator::reset "virtual
void reset()

Resets the integrator. ";

%feature("docstring")  cmf::math::MultiIntegrator::set_state "void
set_state(ptrdiff_t position, real newState)

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::MultiIntegrator::set_states "void
set_states(const num_array &newStates)

Copies the new states to the actual states. ";

%feature("docstring")  cmf::math::MultiIntegrator::set_states "void
set_states(real *newStates) ";

%feature("docstring")  cmf::math::MultiIntegrator::size "size_t
size() const

returns the number of state variables ";


// File: classcmf_1_1maps_1_1_nearest_neighbor_map.xml
%feature("docstring") cmf::maps::NearestNeighborMap "

A map (spatial distribution of data) returning the nearest neighbor to
the queried position Stores position referenced objects.  z_weight is
a weight, how important vertical differences are for neighborhood. 0
means only horizontal distance and a high value only uses the height
as a distance measure. The distance to be minimized is calculated as:
sqrt((x1-x2)**2+(y1-y2)**2)+abs(z1-z2)*z_weight ";

%feature("docstring")  cmf::maps::NearestNeighborMap::__init__ "def
__init__(self, z_weight=0) ";

%feature("docstring")  cmf::maps::NearestNeighborMap::__call__ "def
__call__(self, x, y, z=0)

returns the nearest neighbor object to the given position     The
distance to be minimized is calculated as:
sqrt((x1-x2)**2+(y1-y2)**2)+abs(z1-z2)*z_weight ";

%feature("docstring")  cmf::maps::NearestNeighborMap::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf::maps::NearestNeighborMap::__nonzero__ "def __nonzero__(self) ";

%feature("docstring")  cmf::maps::NearestNeighborMap::append "def
append(self, position, object) ";

%feature("docstring")  cmf::maps::NearestNeighborMap::remove "def
remove(self, position) ";

%feature("docstring")  cmf::maps::NearestNeighborMap::values "def
values(self) ";


// File: classcmf_1_1upslope_1_1neighbor__iterator.xml
%feature("docstring") cmf::upslope::neighbor_iterator "

A class to iterate through the neighbors of a cell (const). Not needed
from the Python side, use the generator cell.neighbors instead.

C++ includes: Topology.h ";

%feature("docstring")
cmf::upslope::neighbor_iterator::neighbor_iterator "neighbor_iterator(cmf::upslope::Topology &topo) ";

%feature("docstring")
cmf::upslope::neighbor_iterator::neighbor_iterator "neighbor_iterator(cmf::upslope::Cell *cell) ";

%feature("docstring")  cmf::upslope::neighbor_iterator::cell "Cell&
cell() ";

%feature("docstring")  cmf::upslope::neighbor_iterator::flowwidth "double flowwidth() ";

%feature("docstring")  cmf::upslope::neighbor_iterator::next_neighbor
"neighbor_iterator& next_neighbor()

Points the iterator to the next neighbor. ";

%feature("docstring")  cmf::upslope::neighbor_iterator::valid "bool
valid() const ";


// File: classcmf__core_1_1neighbor__iterator.xml
%feature("docstring") cmf_core::neighbor_iterator "

A class to iterate through the neighbors of a cell (const). Not needed
from the Python side, use the generator cell.neighbors instead.  C++
includes: Topology.h ";

%feature("docstring")  cmf_core::neighbor_iterator::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::neighbor_iterator self, Cell cell) ->
neighbor_iterator  neighbor_iterator(cmf::upslope::Cell *cell) ";

%feature("docstring")  cmf_core::neighbor_iterator::__eq__ "def
__eq__(self, args, kwargs)

__eq__(neighbor_iterator self, neighbor_iterator cmp) -> bool ";

%feature("docstring")  cmf_core::neighbor_iterator::__neq__ "def
__neq__(self, args, kwargs)

__neq__(neighbor_iterator self, neighbor_iterator cmp) -> bool ";

%feature("docstring")  cmf_core::neighbor_iterator::cell "def
cell(self, args, kwargs)

cell(neighbor_iterator self) -> Cell  Cell& cell() ";

%feature("docstring")  cmf_core::neighbor_iterator::flowwidth "def
flowwidth(self, args, kwargs)

flowwidth(neighbor_iterator self) -> double  double flowwidth() ";

%feature("docstring")  cmf_core::neighbor_iterator::next_neighbor "def next_neighbor(self, args, kwargs)

next_neighbor(neighbor_iterator self) -> neighbor_iterator
neighbor_iterator& next_neighbor()  Points the iterator to the next
neighbor. ";

%feature("docstring")  cmf_core::neighbor_iterator::valid "def
valid(self, args, kwargs)

valid(neighbor_iterator self) -> bool  bool valid() const ";


// File: classcmf__core_1_1_neumann_boundary.xml
%feature("docstring") cmf_core::NeumannBoundary "

A Neumann boundary condition (constant flux boundary condition)  The
flux is a timeseries, but can be used as a scalar. To scale the
timeseries to the specific conditions of this boundary condition the
linear_scale flux_scale can be used.  C++ includes:
boundary_condition.h ";

%feature("docstring")  cmf_core::NeumannBoundary::__init__ "def
__init__(self, args)

__init__(cmf::water::NeumannBoundary self, project _project,
timeseries _flux, SoluteTimeseries _concentration, point loc) ->
NeumannBoundary __init__(cmf::water::NeumannBoundary self, project
_project, point loc) -> NeumannBoundary  NeumannBoundary(cmf::project
&_project, cmf::geometry::point loc=cmf::geometry::point()) ";

%feature("docstring")  cmf_core::NeumannBoundary::__call__ "def
__call__(self, args, kwargs)

__call__(NeumannBoundary self, Time t) -> real ";

%feature("docstring")  cmf_core::NeumannBoundary::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_node self, flux_node other) -> bool ";

%feature("docstring")  cmf_core::NeumannBoundary::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::NeumannBoundary::conc "def
conc(self, args, kwargs)

conc(flux_node self, Time t, solute Solute) -> real  virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const
Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf_core::NeumannBoundary::connect_to "def
connect_to(self, args, kwargs)

connect_to(NeumannBoundary self, cmf::water::flux_node::ptr target)
void connect_to(cmf::water::flux_node::ptr target) ";

%feature("docstring")  cmf_core::NeumannBoundary::connected_nodes "def connected_nodes(self) ";

%feature("docstring")  cmf_core::NeumannBoundary::connection_to "def
connection_to(self, args, kwargs)

connection_to(flux_node self, flux_node target) -> flux_connection
cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)  Returns the connection between this and target. ";

%feature("docstring")  cmf_core::NeumannBoundary::create "def
create(args, kwargs)

create(cmf::water::flux_node::ptr target) ->
cmf::water::NeumannBoundary::ptr ";

%feature("docstring")  cmf_core::NeumannBoundary::flux3d_to "def
flux3d_to(self, args, kwargs)

flux3d_to(flux_node self, flux_node target, Time t) -> point
cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf_core::NeumannBoundary::flux_to "def
flux_to(self, args, kwargs)

flux_to(flux_node self, flux_node target, Time t) -> real  real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)
Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf_core::NeumannBoundary::fluxes "def
fluxes(self, t) ";

%feature("docstring")  cmf_core::NeumannBoundary::get_3d_flux "def
get_3d_flux(self, args, kwargs)

get_3d_flux(flux_node self, Time t) -> point  cmf::geometry::point
get_3d_flux(cmf::math::Time t)  Returns the sum of all flux vectors.
";

%feature("docstring")  cmf_core::NeumannBoundary::get_flux "def
get_flux(self, args, kwargs)

get_flux(NeumannBoundary self) -> timeseries  cmf::math::timeseries
get_flux()  The timeseries of the boundary flux. ";

%feature("docstring")  cmf_core::NeumannBoundary::is_empty "def
is_empty(self, args, kwargs)

is_empty(flux_node self) -> double  virtual double is_empty() const
Returns true if the node has no water. ";

%feature("docstring")  cmf_core::NeumannBoundary::is_storage "def
is_storage(self, args, kwargs)

is_storage(flux_node self) -> bool  virtual bool is_storage() const
true, if this is a waterstorage ";

%feature("docstring")  cmf_core::NeumannBoundary::RecalcFluxes "def
RecalcFluxes(self, args, kwargs)

RecalcFluxes(flux_node self, Time t) -> bool  virtual bool
RecalcFluxes(cmf::math::Time t)  Pure flux_nodes do not influence
fluxes, therefore no recalculation of fluxes is required by flux_node.
WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf_core::NeumannBoundary::remove_connection "def remove_connection(self, args, kwargs)

remove_connection(flux_node self, cmf::water::flux_node::ptr To) ->
bool  bool remove_connection(cmf::water::flux_node::ptr To)  Remove
the connection. ";

%feature("docstring")  cmf_core::NeumannBoundary::set_flux "def
set_flux(self, args)

set_flux(NeumannBoundary self, timeseries new_flux)
set_flux(NeumannBoundary self, double new_flux)  void set_flux(double
new_flux)  Set a constant as the boundary flux. ";

%feature("docstring")  cmf_core::NeumannBoundary::to_string "def
to_string(self, args, kwargs)

to_string(flux_node self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::NeumannBoundary::waterbalance "def
waterbalance(self, args, kwargs)

waterbalance(flux_node self, Time t, flux_connection Without=None) ->
real  real waterbalance(cmf::math::Time t, const flux_connection
*Without=0) const  Returns the sum of all fluxes (positive and
negative) at time t.  Single fluxes can be excluded from the
calculation  Parameters: -----------  t:  Time of the query  Without:
A flux_connection that is excluded from the waterbalance (e.g. to
prevent closed circuits) ";


// File: classcmf_1_1water_1_1_neumann_boundary.xml
%feature("docstring") cmf::water::NeumannBoundary "

A Neumann boundary condition (constant flux boundary condition)

The flux is a timeseries, but can be used as a scalar. To scale the
timeseries to the specific conditions of this boundary condition the
linear_scale flux_scale can be used.

C++ includes: boundary_condition.h ";

%feature("docstring")  cmf::water::NeumannBoundary::NeumannBoundary "NeumannBoundary(cmf::project &_project, cmf::math::timeseries _flux,
cmf::water::SoluteTimeseries
_concentration=cmf::water::SoluteTimeseries(), cmf::geometry::point
loc=cmf::geometry::point())

Ctor of the Neumann boundary.

Parameters:
-----------

_project:  The project this boundary condition belongs to

_flux:  The flux timeseries (a scalar is converted to a timeseries
automatically)

_concentration:  The concentration timeseries

loc:  The location of the boundary condition ";

%feature("docstring")  cmf::water::NeumannBoundary::NeumannBoundary "NeumannBoundary(cmf::project &_project, cmf::geometry::point
loc=cmf::geometry::point()) ";

%feature("docstring")  cmf::water::NeumannBoundary::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute) const

Returns the solute concentrations of the flux at a given time. ";

%feature("docstring")  cmf::water::NeumannBoundary::connect_to "void
connect_to(cmf::water::flux_node::ptr target) ";

%feature("docstring")  cmf::water::NeumannBoundary::connection_to "cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::water::NeumannBoundary::flux3d_to "cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf::water::NeumannBoundary::flux_to "real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf::water::NeumannBoundary::get_3d_flux "cmf::geometry::point get_3d_flux(cmf::math::Time t)

Returns the sum of all flux vectors. ";

%feature("docstring")  cmf::water::NeumannBoundary::get_connections "cmf::water::connection_list get_connections() const ";

%feature("docstring")  cmf::water::NeumannBoundary::get_flux "cmf::math::timeseries get_flux()

The timeseries of the boundary flux. ";

%feature("docstring")  cmf::water::NeumannBoundary::get_potential "virtual real get_potential() const

Returns the water potential of the node in m waterhead.

The base class water storage always returns the height of the location
";

%feature("docstring")  cmf::water::NeumannBoundary::get_project "cmf::project& get_project() const

Returns the project, this node is part of. ";

%feature("docstring")  cmf::water::NeumannBoundary::is_empty "double
is_empty() const

Returns true if the node has no water. ";

%feature("docstring")  cmf::water::NeumannBoundary::is_storage "virtual bool is_storage() const

true, if this is a waterstorage ";

%feature("docstring")  cmf::water::NeumannBoundary::RecalcFluxes "bool RecalcFluxes(cmf::math::Time t)

Pure flux_nodes do not influence fluxes, therefore no recalculation of
fluxes is required by flux_node.

WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf::water::NeumannBoundary::remove_connection
"bool remove_connection(cmf::water::flux_node::ptr To)

Remove the connection. ";

%feature("docstring")  cmf::water::NeumannBoundary::set_flux "void
set_flux(cmf::math::timeseries new_flux)

Set a timeseries as the boundary flux. ";

%feature("docstring")  cmf::water::NeumannBoundary::set_flux "void
set_flux(double new_flux)

Set a constant as the boundary flux. ";

%feature("docstring")  cmf::water::NeumannBoundary::set_potential "virtual void set_potential(real new_potential)

Sets the potential of this flux node. ";

%feature("docstring")  cmf::water::NeumannBoundary::to_string "virtual std::string to_string() const ";

%feature("docstring")  cmf::water::NeumannBoundary::waterbalance "real waterbalance(cmf::math::Time t, const flux_connection *Without=0)
const

Returns the sum of all fluxes (positive and negative) at time t.

Single fluxes can be excluded from the calculation

Parameters:
-----------

t:  Time of the query

Without:  A flux_connection that is excluded from the waterbalance
(e.g. to prevent closed circuits) ";


// File: classcmf__core_1_1_neumann_boundary__list.xml
%feature("docstring") cmf_core::NeumannBoundary_list "

Provides fast access to Neumann boundaries for flux update.  If many
Neumann boundary conditions are present in a project, a fast data
exchange to update the fluxes might be needed.  With this specialized
list a num_array can be passed to the boundary conditions for a fast
flux update If a multiple system layout for the cmf setup is chosen,
we might have a node_list Dirichlet boundary conditions (dbc), a
corresponding NeumannBoundary_list (nbc) of Neumann boundaries and a
node_list containing the storages connected with the
NeumannBoundary_list (storages). The fast data exchange is written in
Python as:  C++ includes: collections.h ";

%feature("docstring")  cmf_core::NeumannBoundary_list::__init__ "def
__init__(self, args)

__init__(cmf::water::NeumannBoundary_list self) ->
NeumannBoundary_list __init__(cmf::water::NeumannBoundary_list self,
node_list copy) -> NeumannBoundary_list
__init__(cmf::water::NeumannBoundary_list self, NeumannBoundary_list
copy) -> NeumannBoundary_list  NeumannBoundary_list(const
NeumannBoundary_list &copy) ";

%feature("docstring")  cmf_core::NeumannBoundary_list::__getitem__ "def __getitem__(self, index) ";

%feature("docstring")  cmf_core::NeumannBoundary_list::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::NeumannBoundary_list::__len__ "def
__len__(self) ";

%feature("docstring")  cmf_core::NeumannBoundary_list::append "def
append(self, args, kwargs)

append(NeumannBoundary_list self, cmf::water::NeumannBoundary::ptr
nbc)  void append(NeumannBoundary::ptr nbc)  Appends a neumann
boundary to this list. ";

%feature("docstring")  cmf_core::NeumannBoundary_list::extend "def
extend(self, sequence)

Extends the list of Neumann boundaries with the sequence (any iterable
will do) ";

%feature("docstring")  cmf_core::NeumannBoundary_list::get "def
get(self, args, kwargs)

get(NeumannBoundary_list self, ptrdiff_t index) ->
cmf::water::NeumannBoundary::ptr  NeumannBoundary::ptr get(ptrdiff_t
index) const  Returns the Neumann boundary condition at position
index.  From Python you can use [] ";

%feature("docstring")  cmf_core::NeumannBoundary_list::get_fluxes "def get_fluxes(self, args, kwargs)

get_fluxes(NeumannBoundary_list self, Time t) -> cmf::math::num_array
cmf::math::num_array get_fluxes(cmf::math::Time t=cmf::math::Time())
const  Returns the fluxes of the items as an array.  get_fluxes and
set_fluxes are wrapped with the Python property fluxes ";

%feature("docstring")
cmf_core::NeumannBoundary_list::global_water_balance "def
global_water_balance(self, args, kwargs)

global_water_balance(NeumannBoundary_list self, Time t) -> real  real
global_water_balance(cmf::math::Time t) const  Returns the sum of the
water balances of the nodes   .. math::      \\\\\\\\sigma_{global} =
\\\\\\\\sum_{i=0}^N{\\\\\\\\sum_{j=0}^{C_i}{q_{ij}(t)}}   .  Replaces
slow Python code like: ";

%feature("docstring")  cmf_core::NeumannBoundary_list::size "def
size(self, args, kwargs)

size(NeumannBoundary_list self) -> size_t  size_t size() const returns
the number of stored boundary conditions ";

%feature("docstring")  cmf_core::NeumannBoundary_list::to_node_list "def to_node_list(self, args, kwargs)

to_node_list(NeumannBoundary_list self) -> node_list
cmf::water::node_list to_node_list() const  Creates a node_list from
this NeumannBoundary_list. ";

%feature("docstring")  cmf_core::NeumannBoundary_list::water_balance "def water_balance(self, args, kwargs)

water_balance(NeumannBoundary_list self, Time t) ->
cmf::math::num_array  cmf::math::num_array
water_balance(cmf::math::Time t) const  Returns the water balance of
each vector as a vector   .. math::       \\\\\\\\sigma_i     =
\\\\\\\\sum_{j=0}^{C_i}{q_{ij}(t)}   .  Replaces slow Python code
like: ";


// File: classcmf_1_1water_1_1_neumann_boundary__list.xml
%feature("docstring") cmf::water::NeumannBoundary_list "

Provides fast access to Neumann boundaries for flux update.

If many Neumann boundary conditions are present in a project, a fast
data exchange to update the fluxes might be needed.

With this specialized list a num_array can be passed to the boundary
conditions for a fast flux update If a multiple system layout for the
cmf setup is chosen, we might have a node_list Dirichlet boundary
conditions (dbc), a corresponding NeumannBoundary_list (nbc) of
Neumann boundaries and a node_list containing the storages connected
with the NeumannBoundary_list (storages). The fast data exchange is
written in Python as:

C++ includes: collections.h ";

%feature("docstring")
cmf::water::NeumannBoundary_list::NeumannBoundary_list "NeumannBoundary_list() ";

%feature("docstring")
cmf::water::NeumannBoundary_list::NeumannBoundary_list "NeumannBoundary_list(const cmf::water::node_list &copy) ";

%feature("docstring")
cmf::water::NeumannBoundary_list::NeumannBoundary_list "NeumannBoundary_list(const NeumannBoundary_list &copy) ";

%feature("docstring")  cmf::water::NeumannBoundary_list::append "void
append(NeumannBoundary::ptr nbc)

Appends a neumann boundary to this list. ";

%feature("docstring")  cmf::water::NeumannBoundary_list::get "NeumannBoundary::ptr get(ptrdiff_t index) const

Returns the Neumann boundary condition at position index.

From Python you can use [] ";

%feature("docstring")  cmf::water::NeumannBoundary_list::get_fluxes "cmf::math::num_array get_fluxes(cmf::math::Time t=cmf::math::Time())
const

Returns the fluxes of the items as an array.

get_fluxes and set_fluxes are wrapped with the Python property fluxes
";

%feature("docstring")
cmf::water::NeumannBoundary_list::global_water_balance "real
global_water_balance(cmf::math::Time t) const

Returns the sum of the water balances of the nodes


.. math::

    \\\\sigma_{global} =
    \\\\sum_{i=0}^N{\\\\sum_{j=0}^{C_i}{q_{ij}(t)}} 

.

Replaces slow Python code like: ";

%feature("docstring")  cmf::water::NeumannBoundary_list::set_fluxes "void set_fluxes(cmf::math::num_array values)

Sets the fluxes of the items from an array.

get_fluxes and set_fluxes are wrapped with the Python property fluxes
";

%feature("docstring")  cmf::water::NeumannBoundary_list::size "size_t
size() const

returns the number of stored boundary conditions ";

%feature("docstring")  cmf::water::NeumannBoundary_list::to_node_list
"cmf::water::node_list to_node_list() const

Creates a node_list from this NeumannBoundary_list. ";

%feature("docstring")  cmf::water::NeumannBoundary_list::water_balance
"cmf::math::num_array water_balance(cmf::math::Time t) const

Returns the water balance of each vector as a vector 

.. math::

     \\\\sigma_i
    = \\\\sum_{j=0}^{C_i}{q_{ij}(t)} 

.

Replaces slow Python code like: ";


// File: classcmf__core_1_1_neumann_flux.xml
%feature("docstring") cmf_core::NeumannFlux "

Connection between Neumann-boundary and a flux node.  This
flux_connection is created, when connecting a Neumann boundary
condition with a state variable using Neumann::connect_to  C++
includes: boundary_condition.h ";

%feature("docstring")  cmf_core::NeumannFlux::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::water::NeumannFlux self, std::shared_ptr<
cmf::water::NeumannBoundary > left, cmf::water::flux_node::ptr right)
-> NeumannFlux  NeumannFlux(std::shared_ptr< NeumannBoundary > left,
cmf::water::flux_node::ptr right) ";

%feature("docstring")  cmf_core::NeumannFlux::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::NeumannFlux::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::NeumannFlux::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::NeumannFlux::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::NeumannFlux::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::NeumannFlux::conc "def conc(self,
args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::NeumannFlux::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::NeumannFlux::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::NeumannFlux::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::NeumannFlux::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::NeumannFlux::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::NeumannFlux::q "def q(self, args,
kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::NeumannFlux::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::NeumannFlux::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::NeumannFlux::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::NeumannFlux::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::NeumannFlux::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1water_1_1_neumann_flux.xml
%feature("docstring") cmf::water::NeumannFlux "

Connection between Neumann-boundary and a flux node.

This flux_connection is created, when connecting a Neumann boundary
condition with a state variable using Neumann::connect_to

C++ includes: boundary_condition.h ";

%feature("docstring")  cmf::water::NeumannFlux::NeumannFlux "NeumannFlux(std::shared_ptr< NeumannBoundary > left,
cmf::water::flux_node::ptr right) ";

%feature("docstring")  cmf::water::NeumannFlux::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")  cmf::water::NeumannFlux::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::water::NeumannFlux::get_ptr "ptr
get_ptr() const ";

%feature("docstring")  cmf::water::NeumannFlux::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::water::NeumannFlux::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")  cmf::water::NeumannFlux::get_tracer_filter "real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")  cmf::water::NeumannFlux::get_tracer_filter "real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::water::NeumannFlux::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::water::NeumannFlux::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::water::NeumannFlux::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::water::NeumannFlux::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::water::NeumannFlux::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")  cmf::water::NeumannFlux::set_tracer_filter "void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")  cmf::water::NeumannFlux::set_tracer_filter "void set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf::water::NeumannFlux::short_string "virtual
std::string short_string() const ";

%feature("docstring")  cmf::water::NeumannFlux::to_string "virtual
std::string to_string() const ";


// File: classcmf_1_1water_1_1node__list.xml
%feature("docstring") cmf::water::node_list "

A collection of nodes for fast access of the waterbalance.

In setups with many storages and rather fast computations, the speed
of data access for output generation can take a high portion of the
total run time. To accelerate data access, one can use the node_list
object

Todo Add a get_volume / set_volume function pair, to complement
get_potential / set_potential

C++ includes: collections.h ";

%feature("docstring")  cmf::water::node_list::node_list "node_list()

Creates an empty node_lust. ";

%feature("docstring")  cmf::water::node_list::node_list "node_list(const cmf::water::node_list &forcopy)

Copy the node_list. ";

%feature("docstring")  cmf::water::node_list::~node_list "virtual
~node_list() ";

%feature("docstring")  cmf::water::node_list::append "void
append(flux_node::ptr node)

Adds a flux node to the list. ";

%feature("docstring")  cmf::water::node_list::begin "node_vector::iterator begin() ";

%feature("docstring")  cmf::water::node_list::begin "node_vector::const_iterator begin() const ";

%feature("docstring")  cmf::water::node_list::conc "cmf::math::num_array conc(cmf::math::Time t, const cmf::water::solute
&_Solute) const

Returns an array holding the concentration of all the flux nodes for
the given solute. ";

%feature("docstring")  cmf::water::node_list::end "node_vector::iterator end() ";

%feature("docstring")  cmf::water::node_list::end "node_vector::const_iterator end() const ";

%feature("docstring")  cmf::water::node_list::get "flux_node::ptr
get(ptrdiff_t index) const

Returns a node in the node_list. ";

%feature("docstring")  cmf::water::node_list::get_fluxes3d "cmf::geometry::point_vector get_fluxes3d(cmf::math::Time t) const

Returns the current flow vector for each node. ";

%feature("docstring")  cmf::water::node_list::get_fluxes3d_to "cmf::geometry::point_vector get_fluxes3d_to(const
cmf::water::node_list &targets, cmf::math::Time t) const

Returns the flux vectors to the nodes of a given target node_list. ";

%feature("docstring")  cmf::water::node_list::get_fluxes_to "cmf::math::num_array get_fluxes_to(const cmf::water::node_list
&targets, cmf::math::Time t) const

A fast method to perform flux queries as a batch.

The node lists left and right should have the same length.

The vector containing the flux from left to right at the same position

Parameters:
-----------

targets:  A node_list containing the source nodes

t:  The time for the fluxes

Replaces slow Python code like: ";

%feature("docstring")  cmf::water::node_list::get_positions "cmf::geometry::point_vector get_positions() const

Returns the positions of the nodes. ";

%feature("docstring")  cmf::water::node_list::get_potentials "cmf::math::num_array get_potentials()

Returns the potential of the nodes. ";

%feature("docstring")  cmf::water::node_list::get_states "cmf::math::StateVariableList get_states()

Implements StateVariableOwner. ";

%feature("docstring")  cmf::water::node_list::getslice "node_list
getslice(ptrdiff_t begin, ptrdiff_t end, ptrdiff_t step=1) const

Returns a slice of the node_list. ";

%feature("docstring")  cmf::water::node_list::global_water_balance "real global_water_balance(cmf::math::Time t) const

Returns the sum of the water balances of the nodes.



.. math::

    \\\\sigma_{global} =
    \\\\sum_{i=0}^N{\\\\sum_{j=0}^{C_i}{q_{ij}(t)}} 

Replaces slow Python code like: ";

%feature("docstring")  cmf::water::node_list::remove "bool
remove(flux_node::ptr node)

Removes a flux node from the list, returns true if successful. ";

%feature("docstring")  cmf::water::node_list::set_potentials "ptrdiff_t set_potentials(const cmf::math::num_array &potentials)

Sets the potentials of the node_list.

If nodes do not have changeable potentials, they are skipped silently
The number of nodes with changed potential ";

%feature("docstring")  cmf::water::node_list::set_solute_source "ptrdiff_t set_solute_source(const cmf::water::solute &_Solute,
cmf::math::num_array source_fluxes)

Sets the source flux of a solute storage associated with a node (node
has to be a water storage) ";

%feature("docstring")  cmf::water::node_list::size "size_t size()
const

The number of nodes. ";

%feature("docstring")  cmf::water::node_list::water_balance "cmf::math::num_array water_balance(cmf::math::Time t) const

Returns the water balance of each vector as a vector.



.. math::

     \\\\sigma_i = \\\\sum_{j=0}^{C_i}{q_{ij}(t)} 

Replaces slow Python code like: ";


// File: classcmf__core_1_1node__list.xml
%feature("docstring") cmf_core::node_list "

A collection of nodes for fast access of the waterbalance.  In setups
with many storages and rather fast computations, the speed of data
access for output generation can take a high portion of the total run
time. To accelerate data access, one can use the node_list object Todo
Add a get_volume / set_volume function pair, to complement
get_potential / set_potential  C++ includes: collections.h ";

%feature("docstring")  cmf_core::node_list::__init__ "def
__init__(self, args)

__init__(cmf::water::node_list self) -> node_list
__init__(cmf::water::node_list self, node_list forcopy) -> node_list
node_list(const cmf::water::node_list &forcopy)  Copy the node_list.
";

%feature("docstring")  cmf_core::node_list::__add__ "def
__add__(self, args, kwargs)

__add__(node_list self, node_list right) -> node_list ";

%feature("docstring")  cmf_core::node_list::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::node_list::__iadd__ "def
__iadd__(self, args, kwargs)

__iadd__(node_list self, node_list right) -> node_list ";

%feature("docstring")  cmf_core::node_list::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::node_list::__len__ "def
__len__(self) ";

%feature("docstring")  cmf_core::node_list::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::node_list::append "def append(self,
args, kwargs)

append(node_list self, cmf::water::flux_node::ptr node)  void
append(flux_node::ptr node)  Adds a flux node to the list. ";

%feature("docstring")  cmf_core::node_list::conc "def conc(self,
args, kwargs)

conc(node_list self, Time t, solute _Solute) -> cmf::math::num_array
cmf::math::num_array conc(cmf::math::Time t, const cmf::water::solute
&_Solute) const  Returns an array holding the concentration of all the
flux nodes for the given solute. ";

%feature("docstring")  cmf_core::node_list::extend "def extend(self,
sequence)

Extends the node list with the sequence (any iterable will do) ";

%feature("docstring")  cmf_core::node_list::get_fluxes3d "def
get_fluxes3d(self, args, kwargs)

get_fluxes3d(node_list self, Time t) -> point_vector
cmf::geometry::point_vector get_fluxes3d(cmf::math::Time t) const
Returns the current flow vector for each node. ";

%feature("docstring")  cmf_core::node_list::get_fluxes3d_to "def
get_fluxes3d_to(self, args, kwargs)

get_fluxes3d_to(node_list self, node_list targets, Time t) ->
point_vector  cmf::geometry::point_vector get_fluxes3d_to(const
cmf::water::node_list &targets, cmf::math::Time t) const  Returns the
flux vectors to the nodes of a given target node_list. ";

%feature("docstring")  cmf_core::node_list::get_fluxes_to "def
get_fluxes_to(self, args, kwargs)

get_fluxes_to(node_list self, node_list targets, Time t) ->
cmf::math::num_array  cmf::math::num_array get_fluxes_to(const
cmf::water::node_list &targets, cmf::math::Time t) const  A fast
method to perform flux queries as a batch.  The node lists left and
right should have the same length.  The vector containing the flux
from left to right at the same position  Parameters: -----------
targets:  A node_list containing the source nodes  t:  The time for
the fluxes  Replaces slow Python code like: ";

%feature("docstring")  cmf_core::node_list::get_positions "def
get_positions(self, args, kwargs)

get_positions(node_list self) -> point_vector
cmf::geometry::point_vector get_positions() const  Returns the
positions of the nodes. ";

%feature("docstring")  cmf_core::node_list::get_states "def
get_states(self, args, kwargs)

get_states(StateVariableOwner self) -> StateVariableList  virtual
StateVariableList get_states()=0  Add the state variables, owned by an
object derived from StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf_core::node_list::global_water_balance "def
global_water_balance(self, args, kwargs)

global_water_balance(node_list self, Time t) -> real  real
global_water_balance(cmf::math::Time t) const  Returns the sum of the
water balances of the nodes.    .. math::      \\\\\\\\sigma_{global}
=     \\\\\\\\sum_{i=0}^N{\\\\\\\\sum_{j=0}^{C_i}{q_{ij}(t)}} Replaces
slow Python code like: ";

%feature("docstring")  cmf_core::node_list::remove "def remove(self,
args, kwargs)

remove(node_list self, cmf::water::flux_node::ptr node) -> bool  bool
remove(flux_node::ptr node)  Removes a flux node from the list,
returns true if successful. ";

%feature("docstring")  cmf_core::node_list::set_solute_source "def
set_solute_source(self, args, kwargs)

set_solute_source(node_list self, solute _Solute, cmf::math::num_array
source_fluxes) -> ptrdiff_t  ptrdiff_t set_solute_source(const
cmf::water::solute &_Solute, cmf::math::num_array source_fluxes)  Sets
the source flux of a solute storage associated with a node (node has
to be a water storage) ";

%feature("docstring")  cmf_core::node_list::size "def size(self,
args, kwargs)

size(node_list self) -> size_t  size_t size() const  The number of
nodes. ";

%feature("docstring")  cmf_core::node_list::water_balance "def
water_balance(self, args, kwargs)

water_balance(node_list self, Time t) -> cmf::math::num_array
cmf::math::num_array water_balance(cmf::math::Time t) const  Returns
the water balance of each vector as a vector.    .. math::
\\\\\\\\sigma_i = \\\\\\\\sum_{j=0}^{C_i}{q_{ij}(t)}   Replaces slow
Python code like: ";


// File: classcmf_1_1math_1_1root__finding_1_1not__finite__error.xml
%feature("docstring") cmf::math::root_finding::not_finite_error "";

%feature("docstring")
cmf::math::root_finding::not_finite_error::not_finite_error "not_finite_error(const std::string &msg) ";


// File: classcmf__core_1_1_null_adsorption.xml
%feature("docstring") cmf_core::NullAdsorption "

A class for tracers without interaction with the storage container.
freesolute returns xt.  C++ includes: adsorption.h ";

%feature("docstring")  cmf_core::NullAdsorption::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::water::NullAdsorption self) -> NullAdsorption ";

%feature("docstring")  cmf_core::NullAdsorption::copy "def copy(self,
args, kwargs)

copy(NullAdsorption self, real m=-1) -> NullAdsorption  virtual
NullAdsorption* copy(real m=-1) const  returns a copy of the
Adsorption object.  If the adsorption is depending on the sorbent
mass, you can give a positive value for the sorbent mass m. If the
value is not given or negative, m is used from the original object. ";

%feature("docstring")  cmf_core::NullAdsorption::freesolute "def
freesolute(self, args, kwargs)

freesolute(Adsorption self, real xt, real V) -> real  virtual real
freesolute(real xt, real V) const =0  Returns the mass of dissolved
tracer as a function of the total tracer mass in the solute storage
and the water volume.  Parameters: -----------  xt:   :math:`x_t` the
total tracer mass in the storage  V:   :math:`V m^3` the water volume
in the storage  :math:`x_f` the dissolved mass of the tracer ";

%feature("docstring")  cmf_core::NullAdsorption::totalsolute "def
totalsolute(self, args, kwargs)

totalsolute(Adsorption self, real xf, real V) -> real  virtual real
totalsolute(real xf, real V) const =0  Returns the total mass of the
tracer from the dissolved concetration in tracer unit/m3.  Parameters:
-----------  xf:   :math:`x_f` the dissolved tracer mass in the
storage  V:   :math:`V m^3` the water volume in the storage
:math:`x_t` the total mass of the tracer ";


// File: classcmf_1_1water_1_1_null_adsorption.xml
%feature("docstring") cmf::water::NullAdsorption "

A class for tracers without interaction with the storage container.
freesolute returns xt.

C++ includes: adsorption.h ";

%feature("docstring")  cmf::water::NullAdsorption::~NullAdsorption "virtual ~NullAdsorption() ";

%feature("docstring")  cmf::water::NullAdsorption::copy "virtual
NullAdsorption* copy(real m=-1) const

returns a copy of the Adsorption object.

If the adsorption is depending on the sorbent mass, you can give a
positive value for the sorbent mass m. If the value is not given or
negative, m is used from the original object. ";

%feature("docstring")  cmf::water::NullAdsorption::freesolute "virtual real freesolute(real xt, real V) const

Returns the mass of dissolved tracer as a function of the total tracer
mass in the solute storage and the water volume.

Parameters:
-----------

xt:   :math:`x_t` the total tracer mass in the storage

V:   :math:`V m^3` the water volume in the storage

:math:`x_f` the dissolved mass of the tracer ";

%feature("docstring")  cmf::water::NullAdsorption::totalsolute "virtual real totalsolute(real xf, real V) const

Returns the total mass of the tracer from the dissolved concetration
in tracer unit/m3.

Parameters:
-----------

xf:   :math:`x_f` the dissolved tracer mass in the storage

V:   :math:`V m^3` the water volume in the storage

:math:`x_t` the total mass of the tracer ";


// File: classcmf_1_1math_1_1num__array.xml
%feature("docstring") cmf::math::num_array "

A valarray kind of vector implementation with OpenMP capabilities.

C++ includes: num_array.h ";

%feature("docstring")  cmf::math::num_array::num_array "num_array()

constructors ";

%feature("docstring")  cmf::math::num_array::num_array "num_array(const num_array &Vector) ";

%feature("docstring")  cmf::math::num_array::num_array "num_array(const_iterator begin, const_iterator end) ";

%feature("docstring")  cmf::math::num_array::num_array "num_array(ptrdiff_t count, real Value=0.0) ";

%feature("docstring")  cmf::math::num_array::num_array "num_array(size_t count, real Value=0.0) ";

%feature("docstring")  cmf::math::num_array::num_array "num_array(size_t count, real *data) ";

%feature("docstring")  cmf::math::num_array::~num_array "~num_array()

destructor ";

%feature("docstring")  cmf::math::num_array::apply "num_array
apply(real funct(real)) const ";

%feature("docstring")  cmf::math::num_array::axpy "void axpy(const
real fac, const num_array &other) ";

%feature("docstring")  cmf::math::num_array::begin "iterator begin()
const ";

%feature("docstring")  cmf::math::num_array::dot "real dot(const
num_array &) const ";

%feature("docstring")  cmf::math::num_array::end "iterator end()
const ";

%feature("docstring")  cmf::math::num_array::is_nan "bool is_nan()
const ";

%feature("docstring")  cmf::math::num_array::max "real max() const ";

%feature("docstring")  cmf::math::num_array::mean "real mean() const
";

%feature("docstring")  cmf::math::num_array::min "real min() const ";

%feature("docstring")  cmf::math::num_array::norm "real norm(int
normtype=0) const ";

%feature("docstring")  cmf::math::num_array::power "num_array
power(const num_array &) const ";

%feature("docstring")  cmf::math::num_array::power "num_array
power(real exponent) const ";

%feature("docstring")  cmf::math::num_array::release "iterator
release() ";

%feature("docstring")  cmf::math::num_array::resize "void
resize(ptrdiff_t count) ";

%feature("docstring")  cmf::math::num_array::scale "void scale(const
real fac) ";

%feature("docstring")  cmf::math::num_array::scale_add "void
scale_add(const real fac, const num_array &other) ";

%feature("docstring")  cmf::math::num_array::set "void set(const
num_array &other)

Prevents deletion of the stored data.

Use with care, and only if you know what you are doing. ";

%feature("docstring")  cmf::math::num_array::set "void set(const real
fac, const num_array &other) ";

%feature("docstring")  cmf::math::num_array::size "ptrdiff_t size()
const ";

%feature("docstring")  cmf::math::num_array::sum "real sum() const ";


// File: classcmf_1_1river_1_1_open_water_storage.xml
%feature("docstring") cmf::river::OpenWaterStorage "

An open water body.

The potential is calculated from the stored water using a water table
function

C++ includes: OpenWaterStorage.h ";

/*  Overrides of flux_node  */

%feature("docstring")  cmf::river::OpenWaterStorage::RecalcFluxes "virtual bool RecalcFluxes(cmf::math::Time t)

Pure flux_nodes do not influence fluxes, therefore no recalculation of
fluxes is required by flux_node.

WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf::river::OpenWaterStorage::is_empty "virtual double is_empty() const

Returns true if the node has no water. ";

%feature("docstring")  cmf::river::OpenWaterStorage::to_string "virtual std::string to_string() const ";

%feature("docstring")
cmf::river::OpenWaterStorage::add_connected_states "virtual void
add_connected_states(cmf::math::StateVariable::list &states) ";

%feature("docstring")  cmf::river::OpenWaterStorage::conc "real
conc(cmf::math::Time t, const cmf::water::solute &solute) const

Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf::river::OpenWaterStorage::conc "real
conc(const cmf::water::solute &_Solute) const

Returns the concentration of the given solute. ";

%feature("docstring")  cmf::river::OpenWaterStorage::conc "void
conc(const cmf::water::solute &_Solute, real NewConcetration)

Sets a new concentration. ";

%feature("docstring")  cmf::river::OpenWaterStorage::connection_to "cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::river::OpenWaterStorage::dxdt "virtual
real dxdt(const cmf::math::Time &time) ";

%feature("docstring")  cmf::river::OpenWaterStorage::flux3d_to "cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf::river::OpenWaterStorage::flux_to "real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf::river::OpenWaterStorage::get_3d_flux "cmf::geometry::point get_3d_flux(cmf::math::Time t)

Returns the sum of all flux vectors. ";

%feature("docstring")  cmf::river::OpenWaterStorage::get_abs_errtol "real get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf::river::OpenWaterStorage::get_connections "cmf::water::connection_list get_connections() const ";

%feature("docstring")  cmf::river::OpenWaterStorage::get_depth "real
get_depth() const

Returns the water table depth. ";

%feature("docstring")
cmf::river::OpenWaterStorage::get_height_function "virtual const
IVolumeHeightFunction& get_height_function() const

The functional relation between volume, depth and exposed area. ";

%feature("docstring")  cmf::river::OpenWaterStorage::get_potential "virtual real get_potential() const

Returns the water potential of the node in m waterhead.

The base class water storage always returns the height of the location
";

%feature("docstring")  cmf::river::OpenWaterStorage::get_project "cmf::project& get_project() const

Returns the project, this node is part of. ";

%feature("docstring")  cmf::river::OpenWaterStorage::get_state "real
get_state() const ";

%feature("docstring")
cmf::river::OpenWaterStorage::get_state_variable_content "char
get_state_variable_content() const

A character indicating the integrated variable (either 'V' for Volume
or 'h' for head) ";

%feature("docstring")  cmf::river::OpenWaterStorage::get_states "cmf::math::StateVariableList get_states()

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf::river::OpenWaterStorage::get_volume "virtual real get_volume() const

Returns the volume of water in this storage in m3 ";

%feature("docstring")  cmf::river::OpenWaterStorage::is_connected "virtual bool is_connected(const cmf::math::StateVariable &other) const

Returns True if this waterstorage is effected by another state. ";

%feature("docstring")  cmf::river::OpenWaterStorage::is_storage "virtual bool is_storage() const

Returns true, since this is a storage. ";

%feature("docstring")  cmf::river::OpenWaterStorage::remove_connection
"bool remove_connection(cmf::water::flux_node::ptr To)

Remove the connection. ";

%feature("docstring")  cmf::river::OpenWaterStorage::set_depth "void
set_depth(real new_depth) ";

%feature("docstring")
cmf::river::OpenWaterStorage::set_height_function "virtual void
set_height_function(const IVolumeHeightFunction &val) ";

%feature("docstring")  cmf::river::OpenWaterStorage::set_potential "virtual void set_potential(real newpotential)

Sets the potential of this flux node. ";

%feature("docstring")  cmf::river::OpenWaterStorage::set_state "void
set_state(real newState) ";

%feature("docstring")
cmf::river::OpenWaterStorage::set_state_variable_content "void
set_state_variable_content(char content)

A character indicating the integrated variable (either 'V' for Volume
or 'h' for head) ";

%feature("docstring")  cmf::river::OpenWaterStorage::set_volume "virtual void set_volume(real newwatercontent)

Sets the volume of water in this storage in m3 ";

%feature("docstring")  cmf::river::OpenWaterStorage::Solute "SoluteStorage& Solute(const cmf::water::solute _Solute)

Returns the water quality of the water storage. ";

%feature("docstring")  cmf::river::OpenWaterStorage::Solute "const
SoluteStorage& Solute(const cmf::water::solute _Solute) const ";

%feature("docstring")  cmf::river::OpenWaterStorage::waterbalance "real waterbalance(cmf::math::Time t, const flux_connection *Without=0)
const

Returns the sum of all fluxes (positive and negative) at time t.

Single fluxes can be excluded from the calculation

Parameters:
-----------

t:  Time of the query

Without:  A flux_connection that is excluded from the waterbalance
(e.g. to prevent closed circuits) ";

%feature("docstring")  cmf::river::OpenWaterStorage::wet_area "real
wet_area() const

Returns the exposed surface area in m2. ";


// File: classcmf__core_1_1_open_water_storage.xml
%feature("docstring") cmf_core::OpenWaterStorage "

An open water body.  The potential is calculated from the stored water
using a water table function  C++ includes: OpenWaterStorage.h ";

%feature("docstring")  cmf_core::OpenWaterStorage::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::OpenWaterStorage::__call__ "def
__call__(self, args, kwargs)

__call__(flux_node self, Time t) -> real ";

%feature("docstring")  cmf_core::OpenWaterStorage::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_node self, flux_node other) -> bool ";

%feature("docstring")  cmf_core::OpenWaterStorage::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(WaterStorage self, solute X) -> SoluteStorage ";

%feature("docstring")  cmf_core::OpenWaterStorage::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::OpenWaterStorage::cast "def
cast(args, kwargs)

cast(cmf::water::flux_node::ptr node) ->
cmf::river::OpenWaterStorage::ptr ";

%feature("docstring")  cmf_core::OpenWaterStorage::conc "def
conc(self, args, kwargs)

conc(flux_node self, Time t, solute Solute) -> real  virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const
Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf_core::OpenWaterStorage::conc "def
conc(self, args)

conc(WaterStorage self, solute _Solute) -> real conc(WaterStorage
self, Time t, solute _Solute) -> real conc(WaterStorage self, solute
_Solute, real NewConcetration)  void conc(const cmf::water::solute
&_Solute, real NewConcetration)  Sets a new concentration. ";

%feature("docstring")  cmf_core::OpenWaterStorage::connected_nodes "def connected_nodes(self) ";

%feature("docstring")  cmf_core::OpenWaterStorage::connection_to "def
connection_to(self, args, kwargs)

connection_to(flux_node self, flux_node target) -> flux_connection
cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)  Returns the connection between this and target. ";

%feature("docstring")  cmf_core::OpenWaterStorage::create "def
create(args, kwargs)

create(project _project, real initial_state=0.0, real scale=1.0) ->
std::shared_ptr< cmf::water::WaterStorage > ";

%feature("docstring")  cmf_core::OpenWaterStorage::create "def
create(args)

create(project _project, real Area) ->
cmf::river::OpenWaterStorage::ptr create(project _project,
IVolumeHeightFunction base_geo) -> cmf::river::OpenWaterStorage::ptr
";

%feature("docstring")  cmf_core::OpenWaterStorage::dxdt "def
dxdt(self, args, kwargs)

dxdt(StateVariable self, Time time) -> real  virtual real dxdt(const
cmf::math::Time &time)=0  Returns the derivate of the state variable
at time time. ";

%feature("docstring")  cmf_core::OpenWaterStorage::flux3d_to "def
flux3d_to(self, args, kwargs)

flux3d_to(flux_node self, flux_node target, Time t) -> point
cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf_core::OpenWaterStorage::flux_to "def
flux_to(self, args, kwargs)

flux_to(flux_node self, flux_node target, Time t) -> real  real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)
Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf_core::OpenWaterStorage::fluxes "def
fluxes(self, t) ";

%feature("docstring")  cmf_core::OpenWaterStorage::from_node "def
from_node(args, kwargs)

from_node(cmf::water::flux_node::ptr node) -> std::shared_ptr<
cmf::water::WaterStorage > ";

%feature("docstring")  cmf_core::OpenWaterStorage::get_3d_flux "def
get_3d_flux(self, args, kwargs)

get_3d_flux(flux_node self, Time t) -> point  cmf::geometry::point
get_3d_flux(cmf::math::Time t)  Returns the sum of all flux vectors.
";

%feature("docstring")  cmf_core::OpenWaterStorage::get_abs_errtol "def get_abs_errtol(self, args, kwargs)

get_abs_errtol(StateVariable self, real rel_errtol) -> real  virtual
real get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf_core::OpenWaterStorage::get_height_function
"def get_height_function(self, args, kwargs)

get_height_function(OpenWaterStorage self) -> IVolumeHeightFunction
virtual const IVolumeHeightFunction& get_height_function() const  The
functional relation between volume, depth and exposed area. ";

%feature("docstring")  cmf_core::OpenWaterStorage::get_states "def
get_states(self, args, kwargs)

get_states(StateVariableOwner self) -> StateVariableList  virtual
StateVariableList get_states()=0  Add the state variables, owned by an
object derived from StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf_core::OpenWaterStorage::is_connected "def
is_connected(self, args, kwargs)

is_connected(StateVariable self, StateVariable other) -> bool  virtual
bool is_connected(const cmf::math::StateVariable &other) const ";

%feature("docstring")  cmf_core::OpenWaterStorage::is_empty "def
is_empty(self, args, kwargs)

is_empty(flux_node self) -> double  virtual double is_empty() const
Returns true if the node has no water. ";

%feature("docstring")  cmf_core::OpenWaterStorage::is_storage "def
is_storage(self, args, kwargs)

is_storage(flux_node self) -> bool  virtual bool is_storage() const
true, if this is a waterstorage ";

%feature("docstring")  cmf_core::OpenWaterStorage::RecalcFluxes "def
RecalcFluxes(self, args, kwargs)

RecalcFluxes(flux_node self, Time t) -> bool  virtual bool
RecalcFluxes(cmf::math::Time t)  Pure flux_nodes do not influence
fluxes, therefore no recalculation of fluxes is required by flux_node.
WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf_core::OpenWaterStorage::remove_connection "def remove_connection(self, args, kwargs)

remove_connection(flux_node self, cmf::water::flux_node::ptr To) ->
bool  bool remove_connection(cmf::water::flux_node::ptr To)  Remove
the connection. ";

%feature("docstring")  cmf_core::OpenWaterStorage::set_height_function
"def set_height_function(self, args, kwargs)

set_height_function(OpenWaterStorage self, IVolumeHeightFunction val)
virtual void set_height_function(const IVolumeHeightFunction &val) ";

%feature("docstring")  cmf_core::OpenWaterStorage::Solute "def
Solute(self, args)

Solute(WaterStorage self, solute _Solute) -> SoluteStorage
Solute(WaterStorage self, solute _Solute) -> SoluteStorage  const
SoluteStorage& Solute(const cmf::water::solute _Solute) const ";

%feature("docstring")  cmf_core::OpenWaterStorage::to_string "def
to_string(self, args, kwargs)

to_string(StateVariable self) -> std::string  virtual std::string
to_string() const =0 ";

%feature("docstring")  cmf_core::OpenWaterStorage::to_string "def
to_string(self, args, kwargs)

to_string(flux_node self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::OpenWaterStorage::waterbalance "def
waterbalance(self, args, kwargs)

waterbalance(flux_node self, Time t, flux_connection Without=None) ->
real  real waterbalance(cmf::math::Time t, const flux_connection
*Without=0) const  Returns the sum of all fluxes (positive and
negative) at time t.  Single fluxes can be excluded from the
calculation  Parameters: -----------  t:  Time of the query  Without:
A flux_connection that is excluded from the waterbalance (e.g. to
prevent closed circuits) ";

%feature("docstring")  cmf_core::OpenWaterStorage::wet_area "def
wet_area(self, args, kwargs)

wet_area(OpenWaterStorage self) -> real  real wet_area() const Returns
the exposed surface area in m2. ";


// File: classcmf__core_1_1_penman_evaporation.xml
%feature("docstring") cmf_core::PenmanEvaporation "

Calculates evaporation from an open water body.  C++ includes: ET.h ";

%feature("docstring")  cmf_core::PenmanEvaporation::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::ET::PenmanEvaporation self,
cmf::river::OpenWaterStorage::ptr source, cmf::water::flux_node::ptr
Evap_target, Meteorology meteo) -> PenmanEvaporation
PenmanEvaporation(cmf::river::OpenWaterStorage::ptr source,
cmf::water::flux_node::ptr Evap_target, const
cmf::atmosphere::Meteorology &meteo) ";

%feature("docstring")  cmf_core::PenmanEvaporation::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::PenmanEvaporation::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::PenmanEvaporation::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::PenmanEvaporation::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::PenmanEvaporation::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::PenmanEvaporation::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::PenmanEvaporation::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::PenmanEvaporation::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::PenmanEvaporation::get_tracer_filter
"def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::PenmanEvaporation::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::PenmanEvaporation::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::PenmanEvaporation::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::PenmanEvaporation::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::PenmanEvaporation::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::PenmanEvaporation::set_tracer_filter
"def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::PenmanEvaporation::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::PenmanEvaporation::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1_e_t_1_1_penman_evaporation.xml
%feature("docstring") cmf::upslope::ET::PenmanEvaporation "

Calculates evaporation from an open water body.

C++ includes: ET.h ";

%feature("docstring")
cmf::upslope::ET::PenmanEvaporation::PenmanEvaporation "PenmanEvaporation(cmf::river::OpenWaterStorage::ptr source,
cmf::water::flux_node::ptr Evap_target, const
cmf::atmosphere::Meteorology &meteo) ";

%feature("docstring")  cmf::upslope::ET::PenmanEvaporation::conc "real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::ET::PenmanEvaporation::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::upslope::ET::PenmanEvaporation::get_ptr "ptr get_ptr() const ";

%feature("docstring")  cmf::upslope::ET::PenmanEvaporation::get_target
"flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::ET::PenmanEvaporation::get_target
"flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::ET::PenmanEvaporation::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::PenmanEvaporation::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::ET::PenmanEvaporation::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::upslope::ET::PenmanEvaporation::left_node
"flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::ET::PenmanEvaporation::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::ET::PenmanEvaporation::refresh "void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::upslope::ET::PenmanEvaporation::right_node
"flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::ET::PenmanEvaporation::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::PenmanEvaporation::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::ET::PenmanEvaporation::short_string "virtual
std::string short_string() const ";

%feature("docstring")  cmf::upslope::ET::PenmanEvaporation::to_string
"virtual std::string to_string() const ";


// File: classcmf__core_1_1_penman_monteith_e_t.xml
%feature("docstring") cmf_core::PenmanMonteithET "

Calculates the potential evapotranspiration according to FAO(1998)
Governing equations:   .. math::       \\\\\\\\lambda ET &=&
\\\\\\\\frac{\\\\\\\\Delta\\\\\\\\left(R_n -
G\\\\\\\\right)+\\\\\\\\rho_a c_p     \\\\\\\\frac{e_s -
e_a}{r_a}}{\\\\\\\\Delta +
\\\\\\\\gamma\\\\\\\\left(1+\\\\\\\\frac{r_s}{r_a}\\\\\\\\right)}
\\\\\\\\mbox{ FAO 1998,     Eq. 3} \\\\\\\\\\\\\\\\
\\\\\\\\mbox{With:} \\\\\\\\\\\\\\\\ \\\\\\\\Delta &=& 4098
\\\\\\\\frac{0.6108 e^{17.27 T}}{(T+237.3)^2}
\\\\\\\\frac{kPa}{^\\\\\\\\circ C}     \\\\\\\\mbox{ (FAO 1998, Eq.
13)} \\\\\\\\\\\\\\\\ T &=& \\\\\\\\mbox{Actual     Temperature in }
^\\\\\\\\circ C \\\\\\\\\\\\\\\\ R_n &=& \\\\\\\\mbox{net Radiation
(see Atmosphere) in } \\\\\\\\frac{MJ}{m^2day} \\\\\\\\\\\\\\\\ G &=&
0 \\\\\\\\     \\\\\\\\frac{MJ}{m^2day} \\\\\\\\mbox{ if daily average
(FAO 1998, Eq. 42)}     \\\\\\\\\\\\\\\\ && 0.1 R_n \\\\\\\\
\\\\\\\\mbox{ if day time (FAO 1998, Eq. 45)}     \\\\\\\\\\\\\\\\ &&
0.5 R_n \\\\\\\\ \\\\\\\\mbox{ if night time (FAO 1998, Eq. 46)}
\\\\\\\\\\\\\\\\ \\\\\\\\gamma &=& \\\\\\\\frac{c_p P}{\\\\\\\\epsilon
\\\\\\\\lambda}     \\\\\\\\mbox{ (FAO 1998,Eq. 8): Psychrometric
constant }     \\\\\\\\frac{kPa}{^\\\\\\\\circ C} \\\\\\\\\\\\\\\\ c_p
&=& 0.001013     \\\\\\\\frac{MJ}{kg\\\\\\\\ ^\\\\\\\\circ
C}\\\\\\\\mbox{ specific heat at constant     pressure }
\\\\\\\\\\\\\\\\ P &=& 101.3
\\\\\\\\left(\\\\\\\\frac{293-0.0065z}{293}\\\\\\\\right)^{5.26}
\\\\\\\\mbox{ (FAO     1998,Eq. 7)} \\\\\\\\\\\\\\\\ \\\\\\\\epsilon
&=& 0.622 \\\\\\\\frac{mol/g \\\\\\\\mbox{     vapor}}{mol/g
\\\\\\\\mbox{ liquid water}} \\\\\\\\\\\\\\\\ \\\\\\\\lambda &=& 2.45
\\\\\\\\frac{MJ}{kg} \\\\\\\\mbox{ (FAO 1998,Eq. 8)} \\\\\\\\\\\\\\\\
R &=& 0.287     \\\\\\\\frac{kJ}{kg\\\\\\\\ k}\\\\\\\\mbox{ Spec. gas
const.} \\\\\\\\\\\\\\\\ \\\\\\\\rho_a     &=&
\\\\\\\\frac{P}{1.01(T+273)R} \\\\\\\\mbox{ (FAO 1998,Box. 6)}
\\\\\\\\\\\\\\\\     e_s &=& \\\\\\\\mbox{ Sat. vapor press. } [kPa]
\\\\\\\\\\\\\\\\ e_a &=& \\\\\\\\mbox{     Act. vapor press. } [kPa]
\\\\\\\\\\\\\\\\ r_a &=&
\\\\\\\\frac{\\\\\\\\ln\\\\\\\\left(\\\\\\\\frac{2-d}{z_{om}}\\\\\\\\right)\\\\\\\\ln\\\\\\\\left(\\\\\\\\frac{2-d}{z_{oh}}\\\\\\\\right)}{k^2
u_2} \\\\\\\\mbox{ (FAO 1998, Eq. 4/Box 4} \\\\\\\\frac s m
\\\\\\\\\\\\\\\\ &&     d=\\\\\\\\frac 2 3 h,z_{om}=0.123 h,z_{oh}=0.1
z_{om}, k=0.41 \\\\\\\\\\\\\\\\ h     &=& \\\\\\\\mbox{ Vegetation
height in }m \\\\\\\\\\\\\\\\ u_2 &=& \\\\\\\\mbox{     Windspeed in
2m above canopy } \\\\\\\\frac m s \\\\\\\\\\\\\\\\ r_s &=&
\\\\\\\\frac{r_l}{LAI_{Active}} \\\\\\\\mbox{ (FAO 1998, Eq. 5/Box 5)}
\\\\\\\\frac s m \\\\\\\\\\\\\\\\ && r_l=100 \\\\\\\\frac s m,
LAI_{Active}=0.5 LAI     C++ includes: ET.h ";

%feature("docstring")  cmf_core::PenmanMonteithET::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::ET::PenmanMonteithET self,
cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr
ET_target) -> PenmanMonteithET
PenmanMonteithET(cmf::upslope::SoilLayer::ptr source,
cmf::water::flux_node::ptr ET_target) ";

%feature("docstring")  cmf_core::PenmanMonteithET::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::PenmanMonteithET::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::PenmanMonteithET::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::PenmanMonteithET::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::PenmanMonteithET::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::PenmanMonteithET::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::PenmanMonteithET::ETpot "def
ETpot(self, args, kwargs)

ETpot(stressedET self, Time t) -> real  virtual real
ETpot(cmf::math::Time t) const ";

%feature("docstring")  cmf_core::PenmanMonteithET::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::PenmanMonteithET::get_layer "def
get_layer(self, args, kwargs)

get_layer(stressedET self) -> cmf::upslope::SoilLayer::ptr
SoilLayer::ptr get_layer() const ";

%feature("docstring")  cmf_core::PenmanMonteithET::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::PenmanMonteithET::get_tracer_filter "def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::PenmanMonteithET::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::PenmanMonteithET::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::PenmanMonteithET::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::PenmanMonteithET::r_a "def r_a(args,
kwargs)

r_a(Weather A, real veg_height) -> real ";

%feature("docstring")  cmf_core::PenmanMonteithET::r_s "def r_s(args,
kwargs)

r_s(Vegetation veg) -> real ";

%feature("docstring")  cmf_core::PenmanMonteithET::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::PenmanMonteithET::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::PenmanMonteithET::set_stressfunction
"def set_stressfunction(self, args, kwargs)

set_stressfunction(stressedET self, RootUptakeStessFunction
stressfunction)  void set_stressfunction(const RootUptakeStessFunction
&stressfunction)  Sets the stress function to limit water uptake. ";

%feature("docstring")  cmf_core::PenmanMonteithET::set_tracer_filter "def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::PenmanMonteithET::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::PenmanMonteithET::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::PenmanMonteithET::use_for_cell "def
use_for_cell(args, kwargs)

use_for_cell(Cell cell) ";


// File: classcmf_1_1upslope_1_1_e_t_1_1_penman_monteith_e_t.xml
%feature("docstring") cmf::upslope::ET::PenmanMonteithET "

Calculates the potential evapotranspiration according to FAO(1998)

Governing equations: 

.. math::

     \\\\lambda ET &=&
    \\\\frac{\\\\Delta\\\\left(R_n - G\\\\right)+\\\\rho_a c_p
    \\\\frac{e_s - e_a}{r_a}}{\\\\Delta +
    \\\\gamma\\\\left(1+\\\\frac{r_s}{r_a}\\\\right)} \\\\mbox{ FAO 1998,
    Eq. 3} \\\\\\\\ \\\\mbox{With:} \\\\\\\\ \\\\Delta &=& 4098
    \\\\frac{0.6108 e^{17.27 T}}{(T+237.3)^2} \\\\frac{kPa}{^\\\\circ C}
    \\\\mbox{ (FAO 1998, Eq. 13)} \\\\\\\\ T &=& \\\\mbox{Actual
    Temperature in } ^\\\\circ C \\\\\\\\ R_n &=& \\\\mbox{net Radiation
    (see Atmosphere) in } \\\\frac{MJ}{m^2day} \\\\\\\\ G &=& 0 \\\\
    \\\\frac{MJ}{m^2day} \\\\mbox{ if daily average (FAO 1998, Eq. 42)}
    \\\\\\\\ && 0.1 R_n \\\\ \\\\mbox{ if day time (FAO 1998, Eq. 45)}
    \\\\\\\\ && 0.5 R_n \\\\ \\\\mbox{ if night time (FAO 1998, Eq. 46)}
    \\\\\\\\ \\\\gamma &=& \\\\frac{c_p P}{\\\\epsilon \\\\lambda}
    \\\\mbox{ (FAO 1998,Eq. 8): Psychrometric constant }
    \\\\frac{kPa}{^\\\\circ C} \\\\\\\\ c_p &=& 0.001013
    \\\\frac{MJ}{kg\\\\ ^\\\\circ C}\\\\mbox{ specific heat at constant
    pressure } \\\\\\\\ P &=& 101.3
    \\\\left(\\\\frac{293-0.0065z}{293}\\\\right)^{5.26} \\\\mbox{ (FAO
    1998,Eq. 7)} \\\\\\\\ \\\\epsilon &=& 0.622 \\\\frac{mol/g \\\\mbox{
    vapor}}{mol/g \\\\mbox{ liquid water}} \\\\\\\\ \\\\lambda &=& 2.45
    \\\\frac{MJ}{kg} \\\\mbox{ (FAO 1998,Eq. 8)} \\\\\\\\ R &=& 0.287
    \\\\frac{kJ}{kg\\\\ k}\\\\mbox{ Spec. gas const.} \\\\\\\\ \\\\rho_a
    &=& \\\\frac{P}{1.01(T+273)R} \\\\mbox{ (FAO 1998,Box. 6)} \\\\\\\\
    e_s &=& \\\\mbox{ Sat. vapor press. } [kPa] \\\\\\\\ e_a &=& \\\\mbox{
    Act. vapor press. } [kPa] \\\\\\\\ r_a &=&
    \\\\frac{\\\\ln\\\\left(\\\\frac{2-d}{z_{om}}\\\\right)\\\\ln\\\\left(\\\\frac{2-d}{z_{oh}}\\\\right)}{k^2
    u_2} \\\\mbox{ (FAO 1998, Eq. 4/Box 4} \\\\frac s m \\\\\\\\ &&
    d=\\\\frac 2 3 h,z_{om}=0.123 h,z_{oh}=0.1 z_{om}, k=0.41 \\\\\\\\ h
    &=& \\\\mbox{ Vegetation height in }m \\\\\\\\ u_2 &=& \\\\mbox{
    Windspeed in 2m above canopy } \\\\frac m s \\\\\\\\ r_s &=&
    \\\\frac{r_l}{LAI_{Active}} \\\\mbox{ (FAO 1998, Eq. 5/Box 5)}
    \\\\frac s m \\\\\\\\ && r_l=100 \\\\frac s m, LAI_{Active}=0.5 LAI
    



C++ includes: ET.h ";

%feature("docstring")
cmf::upslope::ET::PenmanMonteithET::PenmanMonteithET "PenmanMonteithET(cmf::upslope::SoilLayer::ptr source,
cmf::water::flux_node::ptr ET_target) ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::ETpot "virtual real ETpot(cmf::math::Time t) const ";

%feature("docstring")
cmf::upslope::ET::PenmanMonteithET::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::get_layer "SoilLayer::ptr get_layer() const ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::get_ptr "ptr get_ptr() const ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::get_target
"flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::get_target
"flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::ET::PenmanMonteithET::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::PenmanMonteithET::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::refresh "void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::right_node
"flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::ET::PenmanMonteithET::set_stressfunction "void
set_stressfunction(const RootUptakeStessFunction &stressfunction)

Sets the stress function to limit water uptake. ";

%feature("docstring")
cmf::upslope::ET::PenmanMonteithET::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::PenmanMonteithET::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::ET::PenmanMonteithET::short_string "virtual std::string
short_string() const ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteithET::to_string "std::string to_string() const ";


// File: classcmf_1_1river_1_1_pipe_reach.xml
%feature("docstring") cmf::river::PipeReach "

Describes the geometry of a closed pipe.

C++ includes: ReachType.h ";

%feature("docstring")  cmf::river::PipeReach::PipeReach "PipeReach(double l, double diameter)

Creates a tube IChannel with diameter [m]. ";

%feature("docstring")  cmf::river::PipeReach::PipeReach "PipeReach(const PipeReach &copy) ";

%feature("docstring")  cmf::river::PipeReach::~PipeReach "virtual
~PipeReach() ";

%feature("docstring")  cmf::river::PipeReach::A "virtual double
A(double V) const

Returns the area of the surface for a given volume. ";

%feature("docstring")  cmf::river::PipeReach::copy "PipeReach* copy()
const ";

%feature("docstring")  cmf::river::PipeReach::get_channel_width "virtual double get_channel_width(double depth) const



.. math::

    w=2\\\\sqrt{\\\\left|r^2-(r-d)^2\\\\right|} 

";

%feature("docstring")  cmf::river::PipeReach::get_depth "virtual
double get_depth(double area) const



.. math::

    d=r\\\\left(1-\\\\cos{\\\\frac{A}{r^2}}\\\\right) 

";

%feature("docstring")  cmf::river::PipeReach::get_flux_crossection "virtual double get_flux_crossection(double depth) const



.. math::

    A=r^2\\\\arccos{\\\\frac{r-d}{r}{r}} 

";

%feature("docstring")  cmf::river::PipeReach::get_length "double
get_length() const

Length of the reach. ";

%feature("docstring")  cmf::river::PipeReach::get_nManning "virtual
double get_nManning() const ";

%feature("docstring")  cmf::river::PipeReach::get_wetted_perimeter "virtual double get_wetted_perimeter(double depth) const



.. math::

    P=r\\\\arccos{\\\\frac{r-d}{r}} 

";

%feature("docstring")  cmf::river::PipeReach::h "virtual double
h(double V) const

Returns the depth of a given volume. ";

%feature("docstring")  cmf::river::PipeReach::q "virtual double
q(double h, double slope) const ";

%feature("docstring")  cmf::river::PipeReach::qManning "virtual
double qManning(double A, double slope) const

Calculates the flow rate from a given water volume in the reach


.. math::

     q_{Manning}&=& A R^{\\\\frac 2 3}
    \\\\sqrt{\\\\frac {\\\\Delta_z} n} \\\\\\\\ A &=& \\\\frac V l
    \\\\mbox{, (Crosssectional area of the wetted crossection, Volume per
    length)} \\\\\\\\ R &=& \\\\frac A {P(d)} \\\\\\\\ P(d) &=& \\\\mbox{
    the perimeter of the wetted crosssection, a function of reach depth}
    \\\\\\\\ d(V) &=& \\\\mbox{ the depth of the reach a function of the
    volume} \\\\\\\\ \\\\Delta_z &=& \\\\frac{z_{max} - z_{min}}{l}
    \\\\mbox{ Slope of the reach} 

.

Flow rate [m3/s]

Parameters:
-----------

A:  The area of the cross section [m2]

slope:  The slope of the reach [m/m] ";

%feature("docstring")  cmf::river::PipeReach::set_nManning "virtual
void set_nManning(double nManning) ";

%feature("docstring")  cmf::river::PipeReach::typecode "char
typecode() const ";

%feature("docstring")  cmf::river::PipeReach::V "virtual double
V(double h) const ";


// File: classcmf__core_1_1_pipe_reach.xml
%feature("docstring") cmf_core::PipeReach "

Describes the geometry of a closed pipe.  C++ includes: ReachType.h ";

%feature("docstring")  cmf_core::PipeReach::__init__ "def
__init__(self, args)

__init__(cmf::river::PipeReach self, double l, double diameter) ->
PipeReach __init__(cmf::river::PipeReach self, PipeReach copy) ->
PipeReach  PipeReach(const PipeReach &copy) ";

%feature("docstring")  cmf_core::PipeReach::A "def A(self, args,
kwargs)

A(IVolumeHeightFunction self, double V) -> double  virtual double
A(double V) const =0  Returns the area of the surface for a given
volume. ";

%feature("docstring")  cmf_core::PipeReach::copy "def copy(self,
args, kwargs)

copy(PipeReach self) -> PipeReach  PipeReach* copy() const ";

%feature("docstring")  cmf_core::PipeReach::get_channel_width "def
get_channel_width(self, args, kwargs)

get_channel_width(IChannel self, double depth) -> double  virtual
double get_channel_width(double depth) const =0  Calculates the flow
width from a given actual depth [m] using the actual IChannel
geometry. ";

%feature("docstring")  cmf_core::PipeReach::get_depth "def
get_depth(self, args, kwargs)

get_depth(IChannel self, double area) -> double  virtual double
get_depth(double area) const =0  Calculates the actual depth of the
reach using the IChannel geometry.  get_depth of the reach [m]
Parameters: -----------  area:  Wetted area of a river cross section
[m2], can be obtained by V/l, where V is the stored volume and l is
the reach length ";

%feature("docstring")  cmf_core::PipeReach::get_flux_crossection "def
get_flux_crossection(self, args, kwargs)

get_flux_crossection(IChannel self, double depth) -> double  virtual
double get_flux_crossection(double depth) const =0  Calculates the
wetted area from a given depth using the IChannel geometry.  In most
cases use get_flux_crossection=V/l, where V is the stored volume and l
is the reach length Wetted area of a river cross section [m2]
Parameters: -----------  depth:  depth of the reach [m] ";

%feature("docstring")  cmf_core::PipeReach::get_length "def
get_length(self, args, kwargs)

get_length(IChannel self) -> double  virtual double get_length() const
=0  Length of the reach. ";

%feature("docstring")  cmf_core::PipeReach::get_nManning "def
get_nManning(self, args, kwargs)

get_nManning(IChannel self) -> double  virtual double get_nManning()
const =0 ";

%feature("docstring")  cmf_core::PipeReach::get_wetted_perimeter "def
get_wetted_perimeter(self, args, kwargs)

get_wetted_perimeter(IChannel self, double depth) -> double  virtual
double get_wetted_perimeter(double depth) const =0  Calculates the
wetted perimeter from a given actual depth [m] using the actual
IChannel geometry. ";

%feature("docstring")  cmf_core::PipeReach::h "def h(self, args,
kwargs)

h(IVolumeHeightFunction self, double V) -> double  virtual double
h(double V) const =0  Returns the depth of a given volume. ";

%feature("docstring")  cmf_core::PipeReach::q "def q(self, args,
kwargs)

q(IVolumeHeightFunction self, double h, double slope) -> double
virtual double q(double h, double slope) const ";

%feature("docstring")  cmf_core::PipeReach::qManning "def
qManning(self, args, kwargs)

qManning(IChannel self, double A, double slope) -> double  virtual
double qManning(double A, double slope) const  Calculates the flow
rate from a given water volume in the reach   .. math:: q_{Manning}&=&
A R^{\\\\\\\\frac 2 3}     \\\\\\\\sqrt{\\\\\\\\frac {\\\\\\\\Delta_z}
n} \\\\\\\\\\\\\\\\ A &=& \\\\\\\\frac V l \\\\\\\\mbox{,
(Crosssectional area of the wetted crossection, Volume per
length)} \\\\\\\\\\\\\\\\ R &=& \\\\\\\\frac A {P(d)} \\\\\\\\\\\\\\\\
P(d) &=& \\\\\\\\mbox{     the perimeter of the wetted crosssection, a
function of reach depth}     \\\\\\\\\\\\\\\\ d(V) &=& \\\\\\\\mbox{
the depth of the reach a function of the volume} \\\\\\\\\\\\\\\\
\\\\\\\\Delta_z &=& \\\\\\\\frac{z_{max} - z_{min}}{l}
\\\\\\\\mbox{ Slope of the reach}   .  Flow rate [m3/s]  Parameters:
-----------  A:  The area of the cross section [m2]  slope:  The slope
of the reach [m/m] ";

%feature("docstring")  cmf_core::PipeReach::set_nManning "def
set_nManning(self, args, kwargs)

set_nManning(IChannel self, double val)  virtual void
set_nManning(double val)=0 ";

%feature("docstring")  cmf_core::PipeReach::typecode "def
typecode(self, args, kwargs)

typecode(IChannel self) -> char  virtual char typecode() const =0 ";

%feature("docstring")  cmf_core::PipeReach::V "def V(self, args,
kwargs)

V(IVolumeHeightFunction self, double h) -> double  virtual double
V(double h) const =0 ";


// File: classcmf__core_1_1point.xml
%feature("docstring") cmf_core::point "

2D-Point Class.  Used as location property anywhere in the text
Calculation of distances  +,-,-=,*= Operators overloaded  C++
includes: geometry.h ";

%feature("docstring")  cmf_core::point::__init__ "def __init__(self,
args)

__init__(cmf::geometry::point self) -> point
__init__(cmf::geometry::point self, point p) -> point
__init__(cmf::geometry::point self, double x_, double y_, double
z_=0.0) -> point  point(double x_, double y_, double z_=0.0)  Creates
a point from two doubles. ";

%feature("docstring")  cmf_core::point::__add__ "def __add__(self,
args, kwargs)

__add__(point self, point p) -> point ";

%feature("docstring")  cmf_core::point::__eq__ "def __eq__(self,
args, kwargs)

__eq__(point self, point p) -> bool ";

%feature("docstring")  cmf_core::point::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::point::__iadd__ "def __iadd__(self,
args, kwargs)

__iadd__(point self, point left) -> point ";

%feature("docstring")  cmf_core::point::__imul__ "def __imul__(self,
args)

__imul__(point self, double left) -> point __imul__(point self, point
left) -> point ";

%feature("docstring")  cmf_core::point::__isub__ "def __isub__(self,
args, kwargs)

__isub__(point self, point left) -> point ";

%feature("docstring")  cmf_core::point::__iter__ "def __iter__(self)
";

%feature("docstring")  cmf_core::point::__itruediv__ "def
__itruediv__(self, args) ";

%feature("docstring")  cmf_core::point::__len__ "def __len__(self,
args, kwargs)

__len__(point self) -> int ";

%feature("docstring")  cmf_core::point::__mul__ "def __mul__(self,
args)

__mul__(point self, double left) -> point __mul__(point self, point p)
-> point ";

%feature("docstring")  cmf_core::point::__ne__ "def __ne__(self,
args, kwargs)

__ne__(point self, point p) -> bool ";

%feature("docstring")  cmf_core::point::__rdiv__ "def __rdiv__(self,
args, kwargs)

__rdiv__(point self, double val) -> point ";

%feature("docstring")  cmf_core::point::__repr__ "def __repr__(self)
";

%feature("docstring")  cmf_core::point::__rmul__ "def __rmul__(self,
args, kwargs)

__rmul__(point self, double val) -> point ";

%feature("docstring")  cmf_core::point::__setitem__ "def
__setitem__(self, index, value) ";

%feature("docstring")  cmf_core::point::__sub__ "def __sub__(self,
args, kwargs)

__sub__(point self, point p) -> point ";

%feature("docstring")  cmf_core::point::__truediv__ "def
__truediv__(self, args) ";

%feature("docstring")  cmf_core::point::angleToXAxis "def
angleToXAxis(self, args, kwargs)

angleToXAxis(point self, point p) -> double  double angleToXAxis(point
p) const  Returns the angle between the line
:math:`\\\\\\\\overline{this,p}` to the x-Axis in degrees. ";

%feature("docstring")  cmf_core::point::azimuth "def azimuth(self,
args, kwargs)

azimuth(point self, point p) -> double  double azimuth(point p) const
Returns the azimuth angle of the line :math:`\\\\\\\\overline{this,p}`
to the Azimuth in degrees. ";

%feature("docstring")  cmf_core::point::distance "def distance(args,
kwargs)

distance(point p1, point p2) -> double ";

%feature("docstring")  cmf_core::point::distance3DTo "def
distance3DTo(self, args, kwargs)

distance3DTo(point self, point p) -> double  double distance3DTo(point
p) const  Returns the euclidian distance in space to another point p.
";

%feature("docstring")  cmf_core::point::distance_max "def
distance_max(self, args, kwargs)

distance_max(point self, point p) -> double  double distance_max(point
p) const  Returns the distance by the maximum orthogonal offset. ";

%feature("docstring")  cmf_core::point::distanceTo "def
distanceTo(self, args, kwargs)

distanceTo(point self, point p) -> double  double distanceTo(point p)
const  Returns the horizontal euclidian distance to another point p.
:math:`\\\\\\\\sqrt{(this.x-p.x)^2+(this.y-p.y)^2}` ";

%feature("docstring")  cmf_core::point::length "def length(self,
args, kwargs)

length(point self) -> double  double length() const ";

%feature("docstring")  cmf_core::point::sum "def sum(self, args,
kwargs)

sum(point self) -> double  double sum() const  Returns x+y+z. ";

%feature("docstring")  cmf_core::point::z_weight_distance "def
z_weight_distance(self, args, kwargs)

z_weight_distance(point self, point p, double z_weight) -> double
double z_weight_distance(point p, double z_weight) const  Returns the
horizontal euclidian distance plus the absolute of the height
difference times a factor.
:math:`\\\\\\\\sqrt{(this.x-p.x)^2+(this.y-p.y)^2}\\\\\\\\ +\\\\\\\\
w_{z}|this.z-p.z|` ";


// File: classcmf_1_1geometry_1_1point.xml
%feature("docstring") cmf::geometry::point "

2D-Point Class.

Used as location property anywhere in the text Calculation of
distances

+,-,-=,*= Operators overloaded

C++ includes: geometry.h ";

%feature("docstring")  cmf::geometry::point::point "point()

Empty Constructor. Creates an (0 0) location. ";

%feature("docstring")  cmf::geometry::point::point "point(const point
&p)

Copy Constructor. ";

%feature("docstring")  cmf::geometry::point::point "point(double x_,
double y_, double z_=0.0)

Creates a point from two doubles. ";

%feature("docstring")  cmf::geometry::point::angleToXAxis "double
angleToXAxis(point p) const

Returns the angle between the line :math:`\\\\overline{this,p}` to the
x-Axis in degrees. ";

%feature("docstring")  cmf::geometry::point::azimuth "double
azimuth(point p) const

Returns the azimuth angle of the line :math:`\\\\overline{this,p}` to the
Azimuth in degrees. ";

%feature("docstring")  cmf::geometry::point::distance3DTo "double
distance3DTo(point p) const

Returns the euclidian distance in space to another point p. ";

%feature("docstring")  cmf::geometry::point::distance_max "double
distance_max(point p) const

Returns the distance by the maximum orthogonal offset. ";

%feature("docstring")  cmf::geometry::point::distanceTo "double
distanceTo(point p) const

Returns the horizontal euclidian distance to another point p.

:math:`\\\\sqrt{(this.x-p.x)^2+(this.y-p.y)^2}` ";

%feature("docstring")  cmf::geometry::point::length "double length()
const ";

%feature("docstring")  cmf::geometry::point::sum "double sum() const

Returns x+y+z. ";

%feature("docstring")  cmf::geometry::point::z_weight_distance "double z_weight_distance(point p, double z_weight) const

Returns the horizontal euclidian distance plus the absolute of the
height difference times a factor.

:math:`\\\\sqrt{(this.x-p.x)^2+(this.y-p.y)^2}\\\\ +\\\\ w_{z}|this.z-p.z|`
";


// File: classcmf__core_1_1point__vector.xml
%feature("docstring") cmf_core::point_vector "

Holds three arrays x,y and z for fast access of point coordinates. C++
includes: geometry.h ";

%feature("docstring")  cmf_core::point_vector::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::geometry::point_vector self, ptrdiff_t size) ->
point_vector  point_vector(ptrdiff_t size)  Create a point vector of a
specific size. ";

%feature("docstring")  cmf_core::point_vector::get "def get(self,
args, kwargs)

get(point_vector self, ptrdiff_t index) -> point  point get(ptrdiff_t
index) const  Return a point at index. ";

%feature("docstring")  cmf_core::point_vector::set "def set(self,
args, kwargs)

set(point_vector self, ptrdiff_t index, point p)  void set(ptrdiff_t
index, cmf::geometry::point p)  Change the point at index. ";

%feature("docstring")  cmf_core::point_vector::size "def size(self,
args, kwargs)

size(point_vector self) -> size_t  size_t size() const  Return the
number of points in the point_vector. ";


// File: classcmf_1_1geometry_1_1point__vector.xml
%feature("docstring") cmf::geometry::point_vector "

Holds three arrays x,y and z for fast access of point coordinates.

C++ includes: geometry.h ";

%feature("docstring")  cmf::geometry::point_vector::point_vector "point_vector(ptrdiff_t size)

Create a point vector of a specific size. ";

%feature("docstring")  cmf::geometry::point_vector::get "point
get(ptrdiff_t index) const

Return a point at index. ";

%feature("docstring")  cmf::geometry::point_vector::set "void
set(ptrdiff_t index, cmf::geometry::point p)

Change the point at index. ";

%feature("docstring")  cmf::geometry::point_vector::size "size_t
size() const

Return the number of points in the point_vector. ";


// File: classcmf_1_1maps_1_1_polygon_map.xml
%feature("docstring") cmf::maps::PolygonMap "

A map of polygons. Each object is referenced with a shapely polygon.
Returns the object of the first polygon, within the query position
lays. ";

%feature("docstring")  cmf::maps::PolygonMap::__init__ "def
__init__(self, quad_tree_raster_size=20) ";

%feature("docstring")  cmf::maps::PolygonMap::__call__ "def
__call__(self, x, y, z=0) ";

%feature("docstring")  cmf::maps::PolygonMap::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf::maps::PolygonMap::__nonzero__ "def
__nonzero__(self) ";

%feature("docstring")  cmf::maps::PolygonMap::append "def
append(self, polygon, object) ";

%feature("docstring")  cmf::maps::PolygonMap::remove "def
remove(self, polygon) ";

%feature("docstring")  cmf::maps::PolygonMap::values "def
values(self) ";


// File: classcmf__core_1_1_power_law_connection.xml
%feature("docstring") cmf_core::PowerLawConnection "

Calculates flux out of a storage as a linear function of its volume to
a power.  This connection serves the same purpose as the old
kinematic_wave connection, but the parameters are easier to explain.
.. math::       q = Q_0 {\\\\\\\\left(\\\\\\\\frac{V -
V_{residual}}{V_0}     \\\\\\\\right)^\\\\\\\\beta}   where: :math:`V`
The actual volume of water stored in source :math:`V_{residual} [m^3]`
The volume of water not flowing out (default = 0)  :math:`V_0` A
reference volume to scale the outflux. One can see :math:`V_0` as the
inflection point of the outflow curve :math:`\\\\\\\\beta` A parameter
to shape the response curve. :math:`Q_0` is the outflow from the
source in :math:`\\\\\\\\frac{m^3}{day}`, when :math:`V = V_0`.
WARNING: :math:`\\\\\\\\beta < 0.5` may lead to numerical troubles and
have a dubious hydrological meaning. Please avoid.  C++ includes:
simple_connections.h ";

%feature("docstring")  cmf_core::PowerLawConnection::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::water::PowerLawConnection self,
cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr
target, real Q0, real V0, real beta=1.0, real residual=0.0) ->
PowerLawConnection  PowerLawConnection(WaterStorage::ptr source,
flux_node::ptr target, real Q0, real V0, real beta=1.0, real
residual=0.0)  Creates a power law connection.  Parameters:
-----------  source:  Water storage from which the water flows out.
Flux is a function of source.volume  target:  Target node (boundary
condition or storage). Does not influence the strength of the flow Q0:
Reference flow :math:`Q_0 = q(V_0)` Outflow when the source storage
equals the reference volume  V0:  Reference volume :math:`V_0` The
reference volume to scale the exponent  beta: :math:`\\\\\\\\beta [-]`
An empirical exponent to shape the flux function (default = 1 (linear
function))  residual: :math:`V_{residual} [m^3]` The volume of water
not flowing out (default = 0) ";

%feature("docstring")  cmf_core::PowerLawConnection::__contains__ "def __contains__(self, cmp) ";

%feature("docstring")  cmf_core::PowerLawConnection::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::PowerLawConnection::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::PowerLawConnection::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::PowerLawConnection::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::PowerLawConnection::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::PowerLawConnection::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::PowerLawConnection::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::PowerLawConnection::get_tracer_filter
"def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::PowerLawConnection::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::PowerLawConnection::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::PowerLawConnection::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::PowerLawConnection::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::PowerLawConnection::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::PowerLawConnection::set_tracer_filter
"def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::PowerLawConnection::short_string "def short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::PowerLawConnection::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1water_1_1_power_law_connection.xml
%feature("docstring") cmf::water::PowerLawConnection "

Calculates flux out of a storage as a linear function of its volume to
a power.

This connection serves the same purpose as the old kinematic_wave
connection, but the parameters are easier to explain.



.. math::

     q = Q_0 {\\\\left(\\\\frac{V - V_{residual}}{V_0}
    \\\\right)^\\\\beta} 

where:  :math:`V` The actual volume of water
stored in source

:math:`V_{residual} [m^3]` The volume of water not flowing out (default = 0)

:math:`V_0` A reference volume to scale the outflux. One can see :math:`V_0` as
the inflection point of the outflow curve

:math:`\\\\beta` A parameter to shape the response curve. :math:`Q_0` is the
outflow from the source in :math:`\\\\frac{m^3}{day}`, when :math:`V = V_0`.

WARNING:   :math:`\\\\beta < 0.5` may lead to numerical troubles and have a
dubious hydrological meaning. Please avoid.

C++ includes: simple_connections.h ";

%feature("docstring")
cmf::water::PowerLawConnection::PowerLawConnection "PowerLawConnection(WaterStorage::ptr source, flux_node::ptr target,
real Q0, real V0, real beta=1.0, real residual=0.0)

Creates a power law connection.

Parameters:
-----------

source:  Water storage from which the water flows out. Flux is a
function of source.volume

target:  Target node (boundary condition or storage). Does not
influence the strength of the flow

Q0:  Reference flow :math:`Q_0 = q(V_0)` Outflow when the source storage
equals the reference volume

V0:  Reference volume :math:`V_0` The reference volume to scale the exponent

beta:   :math:`\\\\beta [-]` An empirical exponent to shape the flux
function (default = 1 (linear function))

residual:   :math:`V_{residual} [m^3]` The volume of water not flowing out
(default = 0) ";

%feature("docstring")  cmf::water::PowerLawConnection::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")  cmf::water::PowerLawConnection::exchange_target
"void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")  cmf::water::PowerLawConnection::get_ptr "ptr
get_ptr() const ";

%feature("docstring")  cmf::water::PowerLawConnection::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::water::PowerLawConnection::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::water::PowerLawConnection::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::PowerLawConnection::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::water::PowerLawConnection::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::water::PowerLawConnection::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::water::PowerLawConnection::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::water::PowerLawConnection::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::water::PowerLawConnection::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::water::PowerLawConnection::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::PowerLawConnection::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf::water::PowerLawConnection::short_string "virtual std::string short_string() const ";

%feature("docstring")  cmf::water::PowerLawConnection::to_string "virtual std::string to_string() const ";


// File: classcmf_1_1math_1_1precalculatable.xml
%feature("docstring") cmf::math::precalculatable "";

%feature("docstring")  cmf::math::precalculatable::do_action "virtual
void do_action(Time t, bool use_OpenMP=true)=0 ";


// File: classcmf__core_1_1_priestley_taylor_e_t.xml
%feature("docstring") cmf_core::PriestleyTaylorET "

Calculates the Evapotranspiration using Priestley-Taylor equation. ..
math::      lambda ET &=& \\\\\\\\alpha
\\\\\\\\frac{\\\\\\\\Delta}{\\\\\\\\Delta +     \\\\\\\\gamma}
\\\\\\\\left(R_n - G\\\\\\\\right)  where:  :math:`\\\\\\\\Delta =
4098 \\\\\\\\frac{0.6108 e^{17.27 T}}{(T+237.3)^2}
\\\\\\\\frac{kPa}{^\\\\\\\\circ C}`, the slope of the vapor pressure/
temperature curve  :math:`\\\\\\\\gamma = \\\\\\\\frac{c_p
P}{\\\\\\\\epsilon \\\\\\\\lambda} \\\\\\\\frac{kPa}{^\\\\\\\\circ C}`
Psychrometric constant  :math:`\\\\\\\\lambda = 2.45
\\\\\\\\frac{MJ}{kg}` the latent heat of vaporization  :math:`R_n
\\\\\\\\frac{MJ}{m^2day}` net Radiation (see Atmosphere)  :math:`G`
Ground heat flux  :math:`\\\\\\\\alpha` the Priestley-Taylor constant
(default 1.26 for humid climates)  C++ includes: ET.h ";

%feature("docstring")  cmf_core::PriestleyTaylorET::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::ET::PriestleyTaylorET self,
cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr
ET_target, real alpha=1.26) -> PriestleyTaylorET
PriestleyTaylorET(cmf::upslope::SoilLayer::ptr source,
cmf::water::flux_node::ptr ET_target, real alpha=1.26) ";

%feature("docstring")  cmf_core::PriestleyTaylorET::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::PriestleyTaylorET::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::PriestleyTaylorET::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::PriestleyTaylorET::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::PriestleyTaylorET::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::PriestleyTaylorET::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::PriestleyTaylorET::ETpot "def
ETpot(self, args, kwargs)

ETpot(stressedET self, Time t) -> real  virtual real
ETpot(cmf::math::Time t) const ";

%feature("docstring")  cmf_core::PriestleyTaylorET::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::PriestleyTaylorET::get_layer "def
get_layer(self, args, kwargs)

get_layer(stressedET self) -> cmf::upslope::SoilLayer::ptr
SoilLayer::ptr get_layer() const ";

%feature("docstring")  cmf_core::PriestleyTaylorET::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::PriestleyTaylorET::get_tracer_filter
"def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::PriestleyTaylorET::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::PriestleyTaylorET::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::PriestleyTaylorET::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::PriestleyTaylorET::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::PriestleyTaylorET::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::PriestleyTaylorET::set_stressfunction
"def set_stressfunction(self, args, kwargs)

set_stressfunction(stressedET self, RootUptakeStessFunction
stressfunction)  void set_stressfunction(const RootUptakeStessFunction
&stressfunction)  Sets the stress function to limit water uptake. ";

%feature("docstring")  cmf_core::PriestleyTaylorET::set_tracer_filter
"def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::PriestleyTaylorET::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::PriestleyTaylorET::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::PriestleyTaylorET::use_for_cell "def
use_for_cell(args, kwargs)

use_for_cell(Cell cell) ";


// File: classcmf_1_1upslope_1_1_e_t_1_1_priestley_taylor_e_t.xml
%feature("docstring") cmf::upslope::ET::PriestleyTaylorET "

Calculates the Evapotranspiration using Priestley-Taylor equation.



.. math::

    lambda ET = \\\\alpha \\\\frac{\\\\Delta}{\\\\Delta + \\\\gamma}
    \\\\left(R_n - G\\\\right)

where:  :math:`\\\\Delta = 4098 \\\\frac{0.6108 e^{17.27 T}}{(T+237.3)^2} \\\\frac{kPa}{^\\\\circ C}`,
the slope of the vapor pressure/ temperature curve

:math:`\\\\gamma = \\\\frac{c_p P}{\\\\epsilon \\\\lambda} \\\\frac{kPa}{^\\\\circ C}` Psychrometric constant

:math:`\\\\lambda = 2.45 \\\\frac{MJ}{kg}` the latent heat of vaporization

:math:`R_n \\\\frac{MJ}{m^2day}` net Radiation (see Atmosphere)

:math:`G` Ground heat flux

:math:`\\\\alpha` the Priestley-Taylor constant (default 1.26 for humid
climates)

C++ includes: ET.h ";

%feature("docstring")
cmf::upslope::ET::PriestleyTaylorET::PriestleyTaylorET "PriestleyTaylorET(cmf::upslope::SoilLayer::ptr source,
cmf::water::flux_node::ptr ET_target, real alpha=1.26) ";

%feature("docstring")  cmf::upslope::ET::PriestleyTaylorET::conc "real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")  cmf::upslope::ET::PriestleyTaylorET::ETpot "real ETpot(cmf::math::Time t) const ";

%feature("docstring")
cmf::upslope::ET::PriestleyTaylorET::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::upslope::ET::PriestleyTaylorET::get_layer
"SoilLayer::ptr get_layer() const ";

%feature("docstring")  cmf::upslope::ET::PriestleyTaylorET::get_ptr "ptr get_ptr() const ";

%feature("docstring")  cmf::upslope::ET::PriestleyTaylorET::get_target
"flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::ET::PriestleyTaylorET::get_target
"flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::ET::PriestleyTaylorET::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::PriestleyTaylorET::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::ET::PriestleyTaylorET::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::upslope::ET::PriestleyTaylorET::left_node
"flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::ET::PriestleyTaylorET::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::ET::PriestleyTaylorET::refresh "void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::upslope::ET::PriestleyTaylorET::right_node
"flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::ET::PriestleyTaylorET::set_stressfunction "void
set_stressfunction(const RootUptakeStessFunction &stressfunction)

Sets the stress function to limit water uptake. ";

%feature("docstring")
cmf::upslope::ET::PriestleyTaylorET::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::PriestleyTaylorET::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::ET::PriestleyTaylorET::short_string "virtual
std::string short_string() const ";

%feature("docstring")  cmf::upslope::ET::PriestleyTaylorET::to_string
"std::string to_string() const ";


// File: classcmf_1_1river_1_1_prism.xml
%feature("docstring") cmf::river::Prism "

the height of a volume in a Prism with a defined base area

C++ includes: ReachType.h ";

%feature("docstring")  cmf::river::Prism::Prism "Prism(double
base_area, double thickness_of_rough_ground=0.01) ";

%feature("docstring")  cmf::river::Prism::~Prism "~Prism() ";

%feature("docstring")  cmf::river::Prism::A "double A(double V) const

:math:`A(V) = A_{base}` ";

%feature("docstring")  cmf::river::Prism::copy "Prism* copy() const
";

%feature("docstring")  cmf::river::Prism::h "double h(double V) const

:math:`h(V) = \\\\frac V A_{base}` ";

%feature("docstring")  cmf::river::Prism::q "virtual double q(double
h, double slope) const ";

%feature("docstring")  cmf::river::Prism::V "double V(double h) const
";


// File: classcmf__core_1_1_prism.xml
%feature("docstring") cmf_core::Prism "

the height of a volume in a Prism with a defined base area  C++
includes: ReachType.h ";

%feature("docstring")  cmf_core::Prism::__init__ "def __init__(self,
args, kwargs)

__init__(cmf::river::Prism self, double base_area, double
thickness_of_rough_ground=0.01) -> Prism  Prism(double base_area,
double thickness_of_rough_ground=0.01) ";

%feature("docstring")  cmf_core::Prism::A "def A(self, args, kwargs)

A(IVolumeHeightFunction self, double V) -> double  virtual double
A(double V) const =0  Returns the area of the surface for a given
volume. ";

%feature("docstring")  cmf_core::Prism::copy "def copy(self, args,
kwargs)

copy(Prism self) -> Prism  Prism* copy() const ";

%feature("docstring")  cmf_core::Prism::h "def h(self, args, kwargs)

h(IVolumeHeightFunction self, double V) -> double  virtual double
h(double V) const =0  Returns the depth of a given volume. ";

%feature("docstring")  cmf_core::Prism::q "def q(self, args, kwargs)

q(IVolumeHeightFunction self, double h, double slope) -> double
virtual double q(double h, double slope) const ";

%feature("docstring")  cmf_core::Prism::V "def V(self, args, kwargs)

V(IVolumeHeightFunction self, double h) -> double  virtual double
V(double h) const =0 ";


// File: classcmf__core_1_1project.xml
%feature("docstring") cmf_core::project "

The study area, holding all cells, outlets and streams.  Todo Describe
tracers  C++ includes: project.h ";

%feature("docstring")  cmf_core::project::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::project self, std::string solute_names) -> project
project(std::string solute_names=\"\")  Creates a new project.
Parameters: -----------  solute_names:  A string representing the
names of the solutes to be used in the project. Sepereate solute names
with space. ";

%feature("docstring")  cmf_core::project::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::project::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::project::__len__ "def __len__(self)
";

%feature("docstring")  cmf_core::project::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::project::get_cell "def
get_cell(self, args, kwargs)

get_cell(project self, ptrdiff_t index) -> Cell  upslope::Cell&
get_cell(ptrdiff_t index)  Returns the reference to the cell at index
in the project. ";

%feature("docstring")  cmf_core::project::get_node "def
get_node(self, args, kwargs)

get_node(project self, ptrdiff_t index) -> cmf::water::flux_node::ptr
cmf::water::flux_node::ptr get_node(ptrdiff_t index)  Returns the node
from the project nodes at index. ";

%feature("docstring")  cmf_core::project::get_reach "def
get_reach(self, args, kwargs)

get_reach(project self, ptrdiff_t index) -> cmf::river::Reach::ptr
cmf::river::Reach::ptr get_reach(ptrdiff_t index)  Returns the reach
at index. ";

%feature("docstring")  cmf_core::project::get_states "def
get_states(self, args, kwargs)

get_states(StateVariableOwner self) -> StateVariableList  virtual
StateVariableList get_states()=0  Add the state variables, owned by an
object derived from StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf_core::project::get_storages "def
get_storages(self, args, kwargs)

get_storages(project self) -> node_list  cmf::water::node_list
get_storages()  Returns a list of all storages of this project. ";

%feature("docstring")  cmf_core::project::NewCell "def NewCell(self,
args, kwargs)

NewCell(project self, double x, double y, double z, double area, bool
with_surfacewater=False) -> Cell  cmf::upslope::Cell* NewCell(double
x, double y, double z, double area, bool with_surfacewater=false)
Creates a new cell.  A new cell, owned by the project  Parameters:
-----------  x:  y:  z:  Position of the cell center in project
coordinates (m)  area:  Area of the cell in m^2  with_surfacewater: If
true, the cell will own a surfacewater storage upon creation ";

%feature("docstring")  cmf_core::project::NewNeumannBoundary "def
NewNeumannBoundary(self, args, kwargs)

NewNeumannBoundary(project self, std::string name,
cmf::water::WaterStorage::ptr target) ->
cmf::water::NeumannBoundary::ptr  cmf::water::NeumannBoundary::ptr
NewNeumannBoundary(std::string name, cmf::water::WaterStorage::ptr
target)  Creates a new Neumann boundary for a target water storage.
The boundary is stored with the project A new Neumann boundary
Parameters: -----------  name:  The name of the boundary condition
target:  The water storage to which the Neumann boundary is bound ";

%feature("docstring")  cmf_core::project::NewOpenStorage "def
NewOpenStorage(self, args, kwargs)

NewOpenStorage(project self, std::string name, double x, double y,
double z, double area) -> cmf::river::OpenWaterStorage::ptr
cmf::river::OpenWaterStorage::ptr NewOpenStorage(std::string name,
double x, double y, double z, double area)  Creates a new open water
storage with a prism geometry.  The open water storage is added to the
project nodes A new open water storage, owned by the project
Parameters: -----------  name:  Name of the open water storage for
output  x:  y:  z:  Position of the open water storage in project
coordinates  area:  Surface area of the open water storage ";

%feature("docstring")  cmf_core::project::NewOutlet "def
NewOutlet(self, args, kwargs)

NewOutlet(project self, std::string name, double x=0, double y=0,
double z=0) -> cmf::water::DirichletBoundary::ptr
cmf::water::DirichletBoundary::ptr NewOutlet(std::string name, double
x=0, double y=0, double z=0)  Creates a new Dirichlet boundary
condition and adds it to the list of outlets The potential of the
Dirichlet boundary equals z, but can be changed.  Parameters:
-----------  name:  Name of the boundary condition for output  x:  y:
z:  Position of the boundary condition in project coordinates ";

%feature("docstring")  cmf_core::project::NewReach "def
NewReach(self, args, kwargs)

NewReach(project self, double x, double y, double z, IChannel shape,
bool diffusive=False) -> cmf::river::Reach::ptr cmf::river::Reach::ptr
NewReach(double x, double y, double z, cmf::river::IChannel &shape,
bool diffusive=false)  Creates a new reach.  A new reach, owned by the
project  Parameters: -----------  x: y:  z:  Position of the reach in
project coordinates  shape: Crossectional geometry of the river. Any
class inheriting from cmf::water::IChannel  diffusive:  If true, this
reach uses by default a diffusive wave connection ";

%feature("docstring")  cmf_core::project::NewStorage "def
NewStorage(self, args, kwargs)

NewStorage(project self, std::string name, double x=0, double y=0,
double z=0) -> cmf::water::WaterStorage::ptr
cmf::water::WaterStorage::ptr NewStorage(std::string name, double x=0,
double y=0, double z=0)  Creates a new generic water storage at
position x,y,z.  The storage is added to the project nodes A new water
storage, owned by the project  Parameters: -----------  name:  Name of
the generic water storage for output  x:  y:  z:  Position of the
generic water storage condition in project coordinates ";

%feature("docstring")  cmf_core::project::node_count "def
node_count(self, args, kwargs)

node_count(project self) -> size_t  size_t node_count() const  Returns
the number of nodes saved with this project. ";

%feature("docstring")  cmf_core::project::nodes "def nodes(self) ";

%feature("docstring")  cmf_core::project::reach_count "def
reach_count(self, args, kwargs)

reach_count(project self) -> size_t  size_t reach_count() const
Returns the number of reaches in this project. ";

%feature("docstring")  cmf_core::project::reaches "def reaches(self)
";

%feature("docstring")  cmf_core::project::remove_node "def
remove_node(self, args, kwargs)

remove_node(project self, cmf::water::flux_node::ptr node) -> size_t
size_t remove_node(cmf::water::flux_node::ptr node)  Removes a node
from the repository.  Removes a node (boundary condition or water
storage) from the node repository of the project. NOTE: If you have
other references to this node, the node is not deleted. If you are
creating a new solver, the node will not be part of the solver. ";

%feature("docstring")  cmf_core::project::size "def size(self, args,
kwargs)

size(project self) -> size_t  size_t size() const  The number of cells
in the project. ";

%feature("docstring")  cmf_core::project::use_IDW_meteo "def
use_IDW_meteo(self, args, kwargs)

use_IDW_meteo(project self, double z_weight=0, double power=2)  void
use_IDW_meteo(double z_weight=0, double power=2)  Uses IDW
interpolation to generate meterological data for each cell of project.
Creates a meteo-data source for each cell, using spatial interpolated
data from all meteorological stations of the project using Inverse
Distance Weighted (IDW) interpolation. The meteorolgical value f is
calculated with IDW for position x,y,z and time t as follows:   ..
math::       f(x,y,z,t) &=& \\\\\\\\sum^N_{i=1}{f_i(t) w_i(x,y,z)}
\\\\\\\\\\\\\\\\ w_i(x,y,z) &=&
\\\\\\\\frac{d_i(x,y,z)^{-p}}{\\\\\\\\sum^N_{j=0}{d_j(x,y,z)^{-p}}}
\\\\\\\\\\\\\\\\     d_i(x,y,z) &=& w_z
\\\\\\\\left|z-z_i\\\\\\\\right| +
\\\\\\\\sqrt{\\\\\\\\left(x-x_i\\\\\\\\right)^2 +
\\\\\\\\left(y-y_i\\\\\\\\right)^2}     :math:`N` is the number of
stations  :math:`f_i(t)` the meteorological value at time t, eg.
Temperature, Humidity  :math:`w_i` is the weight of station i
:math:`d_i` is the distance from x,y,z to station i  :math:`p` the
power of the weighting function, usually 2.  :math:`x_i,y_i,z_i` is
the position of station i in space  :math:`w_z` is a factor to weight
the vertical distance between stations and the cell. 0 results in a
pure horizontal interpolation (normal IDW). If :math:`w_z=1`, height
difference is as important as horizontal distance, and with
:math:`w_z>1` the height difference is weighted more important than
horizontal distance See:  IDW_Meteorology  Parameters: -----------
z_weight:   :math:`w_z` the weight of height difference between cell
and station  power:  the power of the distance weight ";

%feature("docstring")  cmf_core::project::use_IDW_rainfall "def
use_IDW_rainfall(self, args, kwargs)

use_IDW_rainfall(project self, double z_weight=0, double power=2) void
use_IDW_rainfall(double z_weight=0, double power=2)  Uses IDW
interpolation to generate rainfall data for each cell of project.
Creates a rainfall-data source for each cell, using spatial
interpolated data from all meteorological stations of the project
using Inverse Distance Weighted (IDW) interpolation. The rainfall
intensity P is calculated with IDW for position x,y,z and time t as
follows:   .. math::       P(x,y,z,t) &=& \\\\\\\\sum^N_{i=1}{P_i(t)
w_i(x,y,z)} \\\\\\\\\\\\\\\\ w_i(x,y,z) &=&
\\\\\\\\frac{d_i(x,y,z)^{-p}}{\\\\\\\\sum^N_{j=0}{d_j(x,y,z)^{-p}}}
\\\\\\\\\\\\\\\\     d_i(x,y,z) &=& w_z
\\\\\\\\left|z-z_i\\\\\\\\right| +
\\\\\\\\sqrt{\\\\\\\\left(x-x_i\\\\\\\\right)^2 +
\\\\\\\\left(y-y_i\\\\\\\\right)^2}     :math:`N` is the number of
stations  :math:`P_i(t)` the meteorological value at time t, eg.
Temperature, Humidity  :math:`w_i` is the weight of station i
:math:`d_i` is the distance from x,y,z to station i  :math:`p` the
power of the weighting function, usually 2.  :math:`x_i,y_i,z_i` is
the position of station i in space  :math:`w_z` is a factor to weight
the vertical distance between stations and the cell. 0 results in a
pure horizontal interpolation (normal IDW). If :math:`w_z=1`, height
difference is as important as horizontal distance, and with
:math:`w_z>1` the height difference is weighted more important than
horizontal distance See:  IDW_Meteorology  Parameters: -----------
z_weight:   :math:`w_z` the weight of height difference between cell
and station  power:  the power of the distance weight ";

%feature("docstring")  cmf_core::project::use_nearest_meteo "def
use_nearest_meteo(self, args, kwargs)

use_nearest_meteo(project self, double z_weight=0)  void
use_nearest_meteo(double z_weight=0)  Connects all cells of the
project with its nearest meteorological station.  Distance is
calculated as follows:   .. math::      d_i(x,y,z) = w_z
\\\\\\\\left|z-z_i\\\\\\\\right| +
\\\\\\\\sqrt{\\\\\\\\left(x-x_i\\\\\\\\right)^2 +
\\\\\\\\left(y-y_i\\\\\\\\right)^2}   :math:`d_i` is the distance from
x,y,z to station i  :math:`p` the power of the weighting function,
usually 2.  :math:`x_i,y_i,z_i` is the position of station i in space
:math:`w_z` is a factor to weight the vertical distance between
stations and the cell. 0 results in a pure horizontal interpolation
(normal IDW). If :math:`w_z=1`, height difference is as important as
horizontal distance, and with :math:`w_z>1` the height difference is
weighted more important than horizontal distance  Parameters:
-----------  z_weight:   :math:`w_z` the weight of height difference
between cell and station ";

%feature("docstring")  cmf_core::project::use_nearest_rainfall "def
use_nearest_rainfall(self, args, kwargs)

use_nearest_rainfall(project self, double z_weight=0)  void
use_nearest_rainfall(double z_weight=0)  Connects all cells of the
project with its nearest rainfall station.  Distance is calculated as
follows:   .. math::      d_i(x,y,z) = w_z
\\\\\\\\left|z-z_i\\\\\\\\right| +
\\\\\\\\sqrt{\\\\\\\\left(x-x_i\\\\\\\\right)^2 +
\\\\\\\\left(y-y_i\\\\\\\\right)^2}   :math:`d_i` is the distance from
x,y,z to station i  :math:`p` the power of the weighting function,
usually 2.  :math:`x_i,y_i,z_i` is the position of station i in space
:math:`w_z` is a factor to weight the vertical distance between
stations and the cell. 0 results in a pure horizontal interpolation
(normal IDW). If :math:`w_z=1`, height difference is as important as
horizontal distance, and with :math:`w_z>1` the height difference is
weighted more important than horizontal distance  Parameters:
-----------  z_weight:   :math:`w_z` the weight of height difference
between cell and station ";


// File: classcmf_1_1project.xml
%feature("docstring") cmf::project "

The study area, holding all cells, outlets and streams.

Todo Describe tracers

C++ includes: project.h ";

%feature("docstring")  cmf::project::project "project(std::string
solute_names=\"\")

Creates a new project.

Parameters:
-----------

solute_names:  A string representing the names of the solutes to be
used in the project. Sepereate solute names with space. ";

%feature("docstring")  cmf::project::~project "~project() ";

%feature("docstring")  cmf::project::get_cell "upslope::Cell&
get_cell(ptrdiff_t index)

Returns the reference to the cell at index in the project. ";

%feature("docstring")  cmf::project::get_cells "const
upslope::cell_vector& get_cells() const

Returns the cells in the project. ";

%feature("docstring")  cmf::project::get_node "cmf::water::flux_node::ptr get_node(ptrdiff_t index)

Returns the node from the project nodes at index. ";

%feature("docstring")  cmf::project::get_reach "cmf::river::Reach::ptr get_reach(ptrdiff_t index)

Returns the reach at index. ";

%feature("docstring")  cmf::project::get_states "cmf::math::StateVariableList get_states()

Returns all state variables of the project. Mostly for internal use.
";

%feature("docstring")  cmf::project::get_storages "cmf::water::node_list get_storages()

Returns a list of all storages of this project. ";

%feature("docstring")  cmf::project::NewCell "cmf::upslope::Cell*
NewCell(double x, double y, double z, double area, bool
with_surfacewater=false)

Creates a new cell.

A new cell, owned by the project

Parameters:
-----------

x:  y:  z:  Position of the cell center in project coordinates (m)

area:  Area of the cell in m^2

with_surfacewater:  If true, the cell will own a surfacewater storage
upon creation ";

%feature("docstring")  cmf::project::NewNeumannBoundary "cmf::water::NeumannBoundary::ptr NewNeumannBoundary(std::string name,
cmf::water::WaterStorage::ptr target)

Creates a new Neumann boundary for a target water storage.

The boundary is stored with the project A new Neumann boundary

Parameters:
-----------

name:  The name of the boundary condition

target:  The water storage to which the Neumann boundary is bound ";

%feature("docstring")  cmf::project::NewOpenStorage "cmf::river::OpenWaterStorage::ptr NewOpenStorage(std::string name,
double x, double y, double z, double area)

Creates a new open water storage with a prism geometry.

The open water storage is added to the project nodes A new open water
storage, owned by the project

Parameters:
-----------

name:  Name of the open water storage for output

x:  y:  z:  Position of the open water storage in project coordinates

area:  Surface area of the open water storage ";

%feature("docstring")  cmf::project::NewOutlet "cmf::water::DirichletBoundary::ptr NewOutlet(std::string name, double
x=0, double y=0, double z=0)

Creates a new Dirichlet boundary condition and adds it to the list of
outlets The potential of the Dirichlet boundary equals z, but can be
changed.

Parameters:
-----------

name:  Name of the boundary condition for output

x:  y:  z:  Position of the boundary condition in project coordinates
";

%feature("docstring")  cmf::project::NewReach "cmf::river::Reach::ptr
NewReach(double x, double y, double z, cmf::river::IChannel &shape,
bool diffusive=false)

Creates a new reach.

A new reach, owned by the project

Parameters:
-----------

x:  y:  z:  Position of the reach in project coordinates

shape:  Crossectional geometry of the river. Any class inheriting from
cmf::water::IChannel

diffusive:  If true, this reach uses by default a diffusive wave
connection ";

%feature("docstring")  cmf::project::NewStorage "cmf::water::WaterStorage::ptr NewStorage(std::string name, double x=0,
double y=0, double z=0)

Creates a new generic water storage at position x,y,z.

The storage is added to the project nodes A new water storage, owned
by the project

Parameters:
-----------

name:  Name of the generic water storage for output

x:  y:  z:  Position of the generic water storage condition in project
coordinates ";

%feature("docstring")  cmf::project::node_count "size_t node_count()
const

Returns the number of nodes saved with this project. ";

%feature("docstring")  cmf::project::reach_count "size_t
reach_count() const

Returns the number of reaches in this project. ";

%feature("docstring")  cmf::project::remove_node "size_t
remove_node(cmf::water::flux_node::ptr node)

Removes a node from the repository.

Removes a node (boundary condition or water storage) from the node
repository of the project. NOTE: If you have other references to this
node, the node is not deleted. If you are creating a new solver, the
node will not be part of the solver. ";

%feature("docstring")  cmf::project::size "size_t size() const

The number of cells in the project. ";

%feature("docstring")  cmf::project::use_IDW_meteo "void
use_IDW_meteo(double z_weight=0, double power=2)

Uses IDW interpolation to generate meterological data for each cell of
project.

Creates a meteo-data source for each cell, using spatial interpolated
data from all meteorological stations of the project using Inverse
Distance Weighted (IDW) interpolation. The meteorolgical value f is
calculated with IDW for position x,y,z and time t as follows:


.. math::

     f(x,y,z,t) &=& \\\\sum^N_{i=1}{f_i(t) w_i(x,y,z)}
    \\\\\\\\ w_i(x,y,z) &=&
    \\\\frac{d_i(x,y,z)^{-p}}{\\\\sum^N_{j=0}{d_j(x,y,z)^{-p}}} \\\\\\\\
    d_i(x,y,z) &=& w_z \\\\left|z-z_i\\\\right| +
    \\\\sqrt{\\\\left(x-x_i\\\\right)^2 + \\\\left(y-y_i\\\\right)^2}
    

  :math:`N` is the number of stations

:math:`f_i(t)` the meteorological value at time t, eg. Temperature, Humidity

:math:`w_i` is the weight of station i

:math:`d_i` is the distance from x,y,z to station i

:math:`p` the power of the weighting function, usually 2.

:math:`x_i,y_i,z_i` is the position of station i in space

:math:`w_z` is a factor to weight the vertical distance between stations and
the cell. 0 results in a pure horizontal interpolation (normal IDW).
If :math:`w_z=1`, height difference is as important as horizontal distance,
and with :math:`w_z>1` the height difference is weighted more important than
horizontal distance See:  IDW_Meteorology

Parameters:
-----------

z_weight:   :math:`w_z` the weight of height difference between cell and
station

power:  the power of the distance weight ";

%feature("docstring")  cmf::project::use_IDW_rainfall "void
use_IDW_rainfall(double z_weight=0, double power=2)

Uses IDW interpolation to generate rainfall data for each cell of
project.

Creates a rainfall-data source for each cell, using spatial
interpolated data from all meteorological stations of the project
using Inverse Distance Weighted (IDW) interpolation. The rainfall
intensity P is calculated with IDW for position x,y,z and time t as
follows: 

.. math::

     P(x,y,z,t) &=& \\\\sum^N_{i=1}{P_i(t)
    w_i(x,y,z)} \\\\\\\\ w_i(x,y,z) &=&
    \\\\frac{d_i(x,y,z)^{-p}}{\\\\sum^N_{j=0}{d_j(x,y,z)^{-p}}} \\\\\\\\
    d_i(x,y,z) &=& w_z \\\\left|z-z_i\\\\right| +
    \\\\sqrt{\\\\left(x-x_i\\\\right)^2 + \\\\left(y-y_i\\\\right)^2}
    

  :math:`N` is the number of stations

:math:`P_i(t)` the meteorological value at time t, eg. Temperature, Humidity

:math:`w_i` is the weight of station i

:math:`d_i` is the distance from x,y,z to station i

:math:`p` the power of the weighting function, usually 2.

:math:`x_i,y_i,z_i` is the position of station i in space

:math:`w_z` is a factor to weight the vertical distance between stations and
the cell. 0 results in a pure horizontal interpolation (normal IDW).
If :math:`w_z=1`, height difference is as important as horizontal distance,
and with :math:`w_z>1` the height difference is weighted more important than
horizontal distance See:  IDW_Meteorology

Parameters:
-----------

z_weight:   :math:`w_z` the weight of height difference between cell and
station

power:  the power of the distance weight ";

%feature("docstring")  cmf::project::use_nearest_meteo "void
use_nearest_meteo(double z_weight=0)

Connects all cells of the project with its nearest meteorological
station.

Distance is calculated as follows: 

.. math::

    d_i(x,y,z) = w_z
    \\\\left|z-z_i\\\\right| + \\\\sqrt{\\\\left(x-x_i\\\\right)^2 +
    \\\\left(y-y_i\\\\right)^2} 

:math:`d_i` is the distance from x,y,z to
station i

:math:`p` the power of the weighting function, usually 2.

:math:`x_i,y_i,z_i` is the position of station i in space

:math:`w_z` is a factor to weight the vertical distance between stations and
the cell. 0 results in a pure horizontal interpolation (normal IDW).
If :math:`w_z=1`, height difference is as important as horizontal distance,
and with :math:`w_z>1` the height difference is weighted more important than
horizontal distance

Parameters:
-----------

z_weight:   :math:`w_z` the weight of height difference between cell and
station ";

%feature("docstring")  cmf::project::use_nearest_rainfall "void
use_nearest_rainfall(double z_weight=0)

Connects all cells of the project with its nearest rainfall station.

Distance is calculated as follows: 

.. math::

    d_i(x,y,z) = w_z
    \\\\left|z-z_i\\\\right| + \\\\sqrt{\\\\left(x-x_i\\\\right)^2 +
    \\\\left(y-y_i\\\\right)^2} 

:math:`d_i` is the distance from x,y,z to
station i

:math:`p` the power of the weighting function, usually 2.

:math:`x_i,y_i,z_i` is the position of station i in space

:math:`w_z` is a factor to weight the vertical distance between stations and
the cell. 0 results in a pure horizontal interpolation (normal IDW).
If :math:`w_z=1`, height difference is as important as horizontal distance,
and with :math:`w_z>1` the height difference is weighted more important than
horizontal distance

Parameters:
-----------

z_weight:   :math:`w_z` the weight of height difference between cell and
station ";


// File: classcmf__core_1_1project__list__wrapper.xml
%feature("docstring") cmf_core::project_list_wrapper "";

%feature("docstring")  cmf_core::project_list_wrapper::__init__ "def
__init__(self, getitem, getlen, name) ";

%feature("docstring")  cmf_core::project_list_wrapper::__getitem__ "def __getitem__(self, index) ";

%feature("docstring")  cmf_core::project_list_wrapper::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::project_list_wrapper::__len__ "def
__len__(self) ";

%feature("docstring")  cmf_core::project_list_wrapper::__repr__ "def
__repr__(self) ";


// File: classcmf_1_1geometry_1_1qtree_1_1_quadtree.xml
%feature("docstring") cmf::geometry::qtree::Quadtree "

A simple quad tree to check if the boundaries of geometries overlap or
not ";

%feature("docstring")  cmf::geometry::qtree::Quadtree::__init__ "def
__init__(self, area, divisions=50)

:param area: The total area of the study area in m2 :param divisions:
The number of divisions of the area, default is 20 ";

%feature("docstring")  cmf::geometry::qtree::Quadtree::__call__ "def
__call__(self, bounds)

Get all objects in the given boundaries :param bounds: The boundary
rectangle of the tree. A 4 item sequence (xmin, ymin, xmax, ymax)
:return: ";

%feature("docstring")  cmf::geometry::qtree::Quadtree::append "def
append(self, obj, bounds)

Appends an object to the qtree using the given bounds. :param obj: An
object to append to the tree, must be hashable :param bounds: The
boundary rectangle of the object. A 4 item sequence (xmin, ymin, xmax,
ymax) ";

%feature("docstring")  cmf::geometry::qtree::Quadtree::extend "def
extend(self, objects_with_boundaries)

Extends the Quadtree with objects :param objects_with_boundaries: an
iterable of (object, bounds) tuples :return: ";

%feature("docstring")  cmf::geometry::qtree::Quadtree::iterbounds "def iterbounds(self, bounds)

Iterates through all positions in the boundaries :param bounds: The
boundary rectangle. A 4 item sequence (xmin, ymin, xmax, ymax)
:return: (i,j) position tuple ";


// File: classcmf__core_1_1_rainfall.xml
%feature("docstring") cmf_core::Rainfall "

A connection routing rainfall to surface water and to an eventually
existing canopy storage.  C++ includes: AtmosphericFluxes.h ";

%feature("docstring")  cmf_core::Rainfall::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::Rainfall self,
cmf::water::flux_node::ptr target, Cell cell, bool
getthroughfall=True, bool getintercepted=True) -> Rainfall
Rainfall(cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell,
bool getthroughfall=true, bool getintercepted=true)  Creates a new
Rainfall connection. ";

%feature("docstring")  cmf_core::Rainfall::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::Rainfall::__eq__ "def __eq__(self,
args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::Rainfall::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::Rainfall::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::Rainfall::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::Rainfall::conc "def conc(self, args,
kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::Rainfall::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::Rainfall::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::Rainfall::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::Rainfall::kill_me "def kill_me(self,
args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::Rainfall::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::Rainfall::q "def q(self, args,
kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::Rainfall::refresh "def refresh(self,
args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::Rainfall::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::Rainfall::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::Rainfall::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::Rainfall::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1connections_1_1_rainfall.xml
%feature("docstring") cmf::upslope::connections::Rainfall "

A connection routing rainfall to surface water and to an eventually
existing canopy storage.

C++ includes: AtmosphericFluxes.h ";

%feature("docstring")  cmf::upslope::connections::Rainfall::Rainfall "Rainfall(cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell,
bool getthroughfall=true, bool getintercepted=true)

Creates a new Rainfall connection. ";

%feature("docstring")  cmf::upslope::connections::Rainfall::conc "real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::Rainfall::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::upslope::connections::Rainfall::get_ptr "ptr get_ptr() const ";

%feature("docstring")  cmf::upslope::connections::Rainfall::get_target
"flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::connections::Rainfall::get_target
"flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::Rainfall::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::Rainfall::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::connections::Rainfall::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::upslope::connections::Rainfall::left_node
"flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::connections::Rainfall::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::connections::Rainfall::refresh "void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::upslope::connections::Rainfall::right_node
"flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::Rainfall::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::Rainfall::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::Rainfall::short_string "virtual
std::string short_string() const ";

%feature("docstring")  cmf::upslope::connections::Rainfall::to_string
"virtual std::string to_string() const ";


// File: classcmf_1_1atmosphere_1_1_rainfall_station.xml
%feature("docstring") cmf::atmosphere::RainfallStation "

RainfallStation describes a rainfall timeseries in mm/day at a certain
place.

Use RainfallStationReference or IDWRainfall to distribute the data
into space

C++ includes: precipitation.h ";

%feature("docstring")
cmf::atmosphere::RainfallStation::RainfallStation "RainfallStation(const RainfallStation &copy)

copy c'tor ";

%feature("docstring")  cmf::atmosphere::RainfallStation::tostring "std::string tostring() const

Returns the name and the mean yearly rainfall. ";

%feature("docstring")  cmf::atmosphere::RainfallStation::use_for_cell
"void use_for_cell(cmf::upslope::Cell &c)

Connects a cell with this rainfall station. ";


// File: classcmf__core_1_1_rainfall_station.xml
%feature("docstring") cmf_core::RainfallStation "

RainfallStation describes a rainfall timeseries in mm/day at a certain
place.  Use RainfallStationReference or IDWRainfall to distribute the
data into space  C++ includes: precipitation.h ";

%feature("docstring")  cmf_core::RainfallStation::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::atmosphere::RainfallStation self, RainfallStation copy)
-> RainfallStation  RainfallStation(const RainfallStation &copy)  copy
c'tor ";

%feature("docstring")  cmf_core::RainfallStation::__call__ "def
__call__(self, args, kwargs)

__call__(RainfallStation self, Time t) -> double ";

%feature("docstring")  cmf_core::RainfallStation::__repr__ "def
__repr__(self, args, kwargs)

__repr__(RainfallStation self) -> std::string  std::string tostring()
const  Returns the name and the mean yearly rainfall. ";

%feature("docstring")  cmf_core::RainfallStation::create "def
create(args, kwargs)

create(size_t Id, std::string Name, timeseries Data, point position)
-> cmf::atmosphere::RainfallStation::ptr ";

%feature("docstring")  cmf_core::RainfallStation::use_for_cell "def
use_for_cell(self, args, kwargs)

use_for_cell(RainfallStation self, Cell c)  void
use_for_cell(cmf::upslope::Cell &c)  Connects a cell with this
rainfall station. ";


// File: classcmf_1_1atmosphere_1_1_rainfall_station_list.xml
%feature("docstring") cmf::atmosphere::RainfallStationList "

A list of rainfall stations.

C++ includes: precipitation.h ";

%feature("docstring")  cmf::atmosphere::RainfallStationList::add "RainfallStation::ptr add(std::string Name, cmf::math::timeseries Data,
cmf::geometry::point Position)

Creates a new RainfallStation and adds it to the list.

Usage: The position of the rainfall station will be used as identifier
A new rainfall station

Parameters:
-----------

Name:  Name of the station

Data:  Rainfall timeseries

Position:  Spatial position of the new station ";

%feature("docstring")  cmf::atmosphere::RainfallStationList::remove "void remove(ptrdiff_t index)

Removes the station at index from this list. ";

%feature("docstring")  cmf::atmosphere::RainfallStationList::size "size_t size() const

Returns the number of rainfall stations. ";


// File: classcmf__core_1_1_rainfall_station_list.xml
%feature("docstring") cmf_core::RainfallStationList "

A list of rainfall stations.  C++ includes: precipitation.h ";

%feature("docstring")  cmf_core::RainfallStationList::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::atmosphere::RainfallStationList self) ->
RainfallStationList ";

%feature("docstring")  cmf_core::RainfallStationList::__getitem__ "def __getitem__(self, args)

__getitem__(RainfallStationList self, ptrdiff_t index) ->
cmf::atmosphere::RainfallStation::ptr __getitem__(RainfallStationList
self, ptrdiff_t index) -> cmf::atmosphere::RainfallStation::ptr const
";

%feature("docstring")  cmf_core::RainfallStationList::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::RainfallStationList::__len__ "def
__len__(self, args, kwargs)

__len__(RainfallStationList self) -> size_t  size_t size() const
Returns the number of rainfall stations. ";

%feature("docstring")  cmf_core::RainfallStationList::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::RainfallStationList::add "def
add(self, args, kwargs)

add(RainfallStationList self, std::string Name, timeseries Data, point
Position) -> cmf::atmosphere::RainfallStation::ptr
RainfallStation::ptr add(std::string Name, cmf::math::timeseries Data,
cmf::geometry::point Position)  Creates a new RainfallStation and adds
it to the list.  Usage: The position of the rainfall station will be
used as identifier A new rainfall station  Parameters: -----------
Name:  Name of the station  Data:  Rainfall timeseries  Position:
Spatial position of the new station ";

%feature("docstring")  cmf_core::RainfallStationList::remove "def
remove(self, args, kwargs)

remove(RainfallStationList self, ptrdiff_t index)  void
remove(ptrdiff_t index)  Removes the station at index from this list.
";


// File: classcmf_1_1atmosphere_1_1_rainfall_station_reference.xml
%feature("docstring") cmf::atmosphere::RainfallStationReference "

References a single RainfallStation to provide rainfall intensity
data.

C++ includes: precipitation.h ";

%feature("docstring")  cmf::atmosphere::RainfallStationReference::conc
"real conc(cmf::math::Time t, const cmf::water::solute &Solute) const

Returns the concentration of a solute in [solute unit]/m3 at time t in
rainfall. ";

%feature("docstring")
cmf::atmosphere::RainfallStationReference::connection_to "cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)

Returns the connection between this and target. ";

%feature("docstring")
cmf::atmosphere::RainfallStationReference::flux3d_to "cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")
cmf::atmosphere::RainfallStationReference::flux_to "real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")
cmf::atmosphere::RainfallStationReference::get_3d_flux "cmf::geometry::point get_3d_flux(cmf::math::Time t)

Returns the sum of all flux vectors. ";

%feature("docstring")
cmf::atmosphere::RainfallStationReference::get_connections "cmf::water::connection_list get_connections() const ";

%feature("docstring")
cmf::atmosphere::RainfallStationReference::get_intensity "real
get_intensity(cmf::math::Time t) const

Returns the rainfall intensity in mm/day at time t. ";

%feature("docstring")
cmf::atmosphere::RainfallStationReference::get_potential "virtual
real get_potential() const

Returns the water potential of the node in m waterhead.

The base class water storage always returns the height of the location
";

%feature("docstring")
cmf::atmosphere::RainfallStationReference::get_project "cmf::project&
get_project() const

Returns the project, this node is part of. ";

%feature("docstring")
cmf::atmosphere::RainfallStationReference::is_empty "virtual double
is_empty() const

Returns false. ";

%feature("docstring")
cmf::atmosphere::RainfallStationReference::is_storage "virtual bool
is_storage() const

true, if this is a waterstorage ";

%feature("docstring")
cmf::atmosphere::RainfallStationReference::RecalcFluxes "virtual bool
RecalcFluxes(cmf::math::Time t)

Pure flux_nodes do not influence fluxes, therefore no recalculation of
fluxes is required by flux_node.

WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")
cmf::atmosphere::RainfallStationReference::remove_connection "bool
remove_connection(cmf::water::flux_node::ptr To)

Remove the connection. ";

%feature("docstring")
cmf::atmosphere::RainfallStationReference::set_potential "virtual
void set_potential(real new_potential)

Sets the potential of this flux node. ";

%feature("docstring")
cmf::atmosphere::RainfallStationReference::to_string "virtual
std::string to_string() const ";

%feature("docstring")
cmf::atmosphere::RainfallStationReference::waterbalance "real
waterbalance(cmf::math::Time t, const flux_connection *Without=0)
const

Returns the sum of all fluxes (positive and negative) at time t.

Single fluxes can be excluded from the calculation

Parameters:
-----------

t:  Time of the query

Without:  A flux_connection that is excluded from the waterbalance
(e.g. to prevent closed circuits) ";


// File: classcmf__core_1_1_rainfall_station_reference.xml
%feature("docstring") cmf_core::RainfallStationReference "

References a single RainfallStation to provide rainfall intensity
data.  C++ includes: precipitation.h ";

%feature("docstring")  cmf_core::RainfallStationReference::__init__ "def __init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::RainfallStationReference::__call__ "def __call__(self, args, kwargs)

__call__(RainSource self, Time t) -> real ";

%feature("docstring")  cmf_core::RainfallStationReference::__eq__ "def __eq__(self, args, kwargs)

__eq__(flux_node self, flux_node other) -> bool ";

%feature("docstring")  cmf_core::RainfallStationReference::__repr__ "def __repr__(self) ";

%feature("docstring")  cmf_core::RainfallStationReference::conc "def
conc(self, args, kwargs)

conc(flux_node self, Time t, solute Solute) -> real  virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const
Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")
cmf_core::RainfallStationReference::connected_nodes "def
connected_nodes(self) ";

%feature("docstring")
cmf_core::RainfallStationReference::connection_to "def
connection_to(self, args, kwargs)

connection_to(flux_node self, flux_node target) -> flux_connection
cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)  Returns the connection between this and target. ";

%feature("docstring")  cmf_core::RainfallStationReference::flux3d_to "def flux3d_to(self, args, kwargs)

flux3d_to(flux_node self, flux_node target, Time t) -> point
cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf_core::RainfallStationReference::flux_to "def flux_to(self, args, kwargs)

flux_to(flux_node self, flux_node target, Time t) -> real  real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)
Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf_core::RainfallStationReference::fluxes "def fluxes(self, t) ";

%feature("docstring")
cmf_core::RainfallStationReference::from_nearest_station "def
from_nearest_station(args, kwargs)

from_nearest_station(project project, point position, double z_weight)
-> cmf::atmosphere::RainfallStationReference::ptr ";

%feature("docstring")
cmf_core::RainfallStationReference::from_station_id "def
from_station_id(args, kwargs)

from_station_id(project project, point position, size_t id) ->
cmf::atmosphere::RainfallStationReference::ptr ";

%feature("docstring")  cmf_core::RainfallStationReference::get_3d_flux
"def get_3d_flux(self, args, kwargs)

get_3d_flux(flux_node self, Time t) -> point  cmf::geometry::point
get_3d_flux(cmf::math::Time t)  Returns the sum of all flux vectors.
";

%feature("docstring")
cmf_core::RainfallStationReference::get_intensity "def
get_intensity(self, args, kwargs)

get_intensity(RainSource self, Time t) -> real  virtual real
get_intensity(cmf::math::Time t) const =0  Returns the actual rainfall
intensity in mm/day. ";

%feature("docstring")  cmf_core::RainfallStationReference::is_empty "def is_empty(self, args, kwargs)

is_empty(flux_node self) -> double  virtual double is_empty() const
Returns true if the node has no water. ";

%feature("docstring")  cmf_core::RainfallStationReference::is_storage
"def is_storage(self, args, kwargs)

is_storage(flux_node self) -> bool  virtual bool is_storage() const
true, if this is a waterstorage ";

%feature("docstring")
cmf_core::RainfallStationReference::RecalcFluxes "def
RecalcFluxes(self, args, kwargs)

RecalcFluxes(flux_node self, Time t) -> bool  virtual bool
RecalcFluxes(cmf::math::Time t)  Pure flux_nodes do not influence
fluxes, therefore no recalculation of fluxes is required by flux_node.
WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")
cmf_core::RainfallStationReference::remove_connection "def
remove_connection(self, args, kwargs)

remove_connection(flux_node self, cmf::water::flux_node::ptr To) ->
bool  bool remove_connection(cmf::water::flux_node::ptr To)  Remove
the connection. ";

%feature("docstring")  cmf_core::RainfallStationReference::to_string "def to_string(self, args, kwargs)

to_string(flux_node self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")
cmf_core::RainfallStationReference::waterbalance "def
waterbalance(self, args, kwargs)

waterbalance(flux_node self, Time t, flux_connection Without=None) ->
real  real waterbalance(cmf::math::Time t, const flux_connection
*Without=0) const  Returns the sum of all fluxes (positive and
negative) at time t.  Single fluxes can be excluded from the
calculation  Parameters: -----------  t:  Time of the query  Without:
A flux_connection that is excluded from the waterbalance (e.g. to
prevent closed circuits) ";


// File: classcmf__core_1_1_rain_source.xml
%feature("docstring") cmf_core::RainSource "

An abstract class for different types of rainfall sources.  C++
includes: precipitation.h ";

%feature("docstring")  cmf_core::RainSource::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::RainSource::__call__ "def
__call__(self, args, kwargs)

__call__(RainSource self, Time t) -> real ";

%feature("docstring")  cmf_core::RainSource::__eq__ "def __eq__(self,
args, kwargs)

__eq__(flux_node self, flux_node other) -> bool ";

%feature("docstring")  cmf_core::RainSource::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::RainSource::conc "def conc(self,
args, kwargs)

conc(flux_node self, Time t, solute Solute) -> real  virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const
Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf_core::RainSource::connected_nodes "def
connected_nodes(self) ";

%feature("docstring")  cmf_core::RainSource::connection_to "def
connection_to(self, args, kwargs)

connection_to(flux_node self, flux_node target) -> flux_connection
cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)  Returns the connection between this and target. ";

%feature("docstring")  cmf_core::RainSource::flux3d_to "def
flux3d_to(self, args, kwargs)

flux3d_to(flux_node self, flux_node target, Time t) -> point
cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf_core::RainSource::flux_to "def
flux_to(self, args, kwargs)

flux_to(flux_node self, flux_node target, Time t) -> real  real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)
Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf_core::RainSource::fluxes "def fluxes(self,
t) ";

%feature("docstring")  cmf_core::RainSource::get_3d_flux "def
get_3d_flux(self, args, kwargs)

get_3d_flux(flux_node self, Time t) -> point  cmf::geometry::point
get_3d_flux(cmf::math::Time t)  Returns the sum of all flux vectors.
";

%feature("docstring")  cmf_core::RainSource::get_intensity "def
get_intensity(self, args, kwargs)

get_intensity(RainSource self, Time t) -> real  virtual real
get_intensity(cmf::math::Time t) const =0  Returns the actual rainfall
intensity in mm/day. ";

%feature("docstring")  cmf_core::RainSource::is_empty "def
is_empty(self, args, kwargs)

is_empty(flux_node self) -> double  virtual double is_empty() const
Returns true if the node has no water. ";

%feature("docstring")  cmf_core::RainSource::is_storage "def
is_storage(self, args, kwargs)

is_storage(flux_node self) -> bool  virtual bool is_storage() const
true, if this is a waterstorage ";

%feature("docstring")  cmf_core::RainSource::RecalcFluxes "def
RecalcFluxes(self, args, kwargs)

RecalcFluxes(flux_node self, Time t) -> bool  virtual bool
RecalcFluxes(cmf::math::Time t)  Pure flux_nodes do not influence
fluxes, therefore no recalculation of fluxes is required by flux_node.
WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf_core::RainSource::remove_connection "def
remove_connection(self, args, kwargs)

remove_connection(flux_node self, cmf::water::flux_node::ptr To) ->
bool  bool remove_connection(cmf::water::flux_node::ptr To)  Remove
the connection. ";

%feature("docstring")  cmf_core::RainSource::to_string "def
to_string(self, args, kwargs)

to_string(flux_node self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::RainSource::waterbalance "def
waterbalance(self, args, kwargs)

waterbalance(flux_node self, Time t, flux_connection Without=None) ->
real  real waterbalance(cmf::math::Time t, const flux_connection
*Without=0) const  Returns the sum of all fluxes (positive and
negative) at time t.  Single fluxes can be excluded from the
calculation  Parameters: -----------  t:  Time of the query  Without:
A flux_connection that is excluded from the waterbalance (e.g. to
prevent closed circuits) ";


// File: classcmf_1_1atmosphere_1_1_rain_source.xml
%feature("docstring") cmf::atmosphere::RainSource "

An abstract class for different types of rainfall sources.

C++ includes: precipitation.h ";

%feature("docstring")  cmf::atmosphere::RainSource::conc "virtual
real conc(cmf::math::Time t, const cmf::water::solute &Solute) const
=0

Returns the concentration of a solute in the rainfall at time t. ";

%feature("docstring")  cmf::atmosphere::RainSource::connection_to "cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::atmosphere::RainSource::flux3d_to "cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf::atmosphere::RainSource::flux_to "real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf::atmosphere::RainSource::get_3d_flux "cmf::geometry::point get_3d_flux(cmf::math::Time t)

Returns the sum of all flux vectors. ";

%feature("docstring")  cmf::atmosphere::RainSource::get_connections "cmf::water::connection_list get_connections() const ";

%feature("docstring")  cmf::atmosphere::RainSource::get_intensity "virtual real get_intensity(cmf::math::Time t) const =0

Returns the actual rainfall intensity in mm/day. ";

%feature("docstring")  cmf::atmosphere::RainSource::get_potential "virtual real get_potential() const

Returns the water potential of the node in m waterhead.

The base class water storage always returns the height of the location
";

%feature("docstring")  cmf::atmosphere::RainSource::get_project "cmf::project& get_project() const

Returns the project, this node is part of. ";

%feature("docstring")  cmf::atmosphere::RainSource::is_empty "virtual
double is_empty() const

Returns false. ";

%feature("docstring")  cmf::atmosphere::RainSource::is_storage "virtual bool is_storage() const

true, if this is a waterstorage ";

%feature("docstring")  cmf::atmosphere::RainSource::RecalcFluxes "virtual bool RecalcFluxes(cmf::math::Time t)

Pure flux_nodes do not influence fluxes, therefore no recalculation of
fluxes is required by flux_node.

WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf::atmosphere::RainSource::remove_connection
"bool remove_connection(cmf::water::flux_node::ptr To)

Remove the connection. ";

%feature("docstring")  cmf::atmosphere::RainSource::set_potential "virtual void set_potential(real new_potential)

Sets the potential of this flux node. ";

%feature("docstring")  cmf::atmosphere::RainSource::to_string "virtual std::string to_string() const ";

%feature("docstring")  cmf::atmosphere::RainSource::waterbalance "real waterbalance(cmf::math::Time t, const flux_connection *Without=0)
const

Returns the sum of all fluxes (positive and negative) at time t.

Single fluxes can be excluded from the calculation

Parameters:
-----------

t:  Time of the query

Without:  A flux_connection that is excluded from the waterbalance
(e.g. to prevent closed circuits) ";


// File: classcmf_1_1river_1_1_reach.xml
%feature("docstring") cmf::river::Reach "

A reach represents the section of a riover and is a specialization of
an open water storage.

The OpenWaterStorage attributes and methods are extended by
topological features, for the creation of a network of reaches.

C++ includes: Reach.h ";

/*  Overrides of flux_node  */

%feature("docstring")  cmf::river::Reach::RecalcFluxes "virtual bool
RecalcFluxes(cmf::math::Time t)

Pure flux_nodes do not influence fluxes, therefore no recalculation of
fluxes is required by flux_node.

WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf::river::Reach::is_empty "virtual double
is_empty() const

Returns true if the node has no water. ";

%feature("docstring")  cmf::river::Reach::to_string "virtual
std::string to_string() const ";

%feature("docstring")  cmf::river::Reach::~Reach "virtual ~Reach() ";

%feature("docstring")  cmf::river::Reach::add_connected_states "virtual void add_connected_states(cmf::math::StateVariable::list
&states) ";

%feature("docstring")  cmf::river::Reach::conc "real
conc(cmf::math::Time t, const cmf::water::solute &solute) const

Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf::river::Reach::conc "real conc(const
cmf::water::solute &_Solute) const

Returns the concentration of the given solute. ";

%feature("docstring")  cmf::river::Reach::conc "void conc(const
cmf::water::solute &_Solute, real NewConcetration)

Sets a new concentration. ";

%feature("docstring")  cmf::river::Reach::connect_to_surfacewater "void connect_to_surfacewater(cmf::upslope::Cell *cell, real width,
bool diffusive)

Connects the surfacewater of a cell with this reach.

Parameters:
-----------

cell:  The cell with the surface water to be connected with this reach

width:  The flow width from cell to this reach

diffusive:  If diffusive is false, a ManningKinematic connection is
used, else a ManningDiffusive connection ";

%feature("docstring")  cmf::river::Reach::connection_to "cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::river::Reach::distance_to_cell "double
distance_to_cell(cmf::upslope::Cell *cell) const

Returns the distance (d) for connections between this reach and a
cell.

If the effective inner cell distance (defined as :math:`R_{Cell} = 0.5\\\\frac{\\\\sqrt{A}}{\\\\pi}`) is smaller than the distance
between the center points, the cell radius is returned ";

%feature("docstring")  cmf::river::Reach::dxdt "virtual real
dxdt(const cmf::math::Time &time) ";

%feature("docstring")  cmf::river::Reach::flux3d_to "cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf::river::Reach::flux_to "real flux_to(const
cmf::water::flux_node &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf::river::Reach::get_3d_flux "cmf::geometry::point get_3d_flux(cmf::math::Time t)

Returns the sum of all flux vectors. ";

%feature("docstring")  cmf::river::Reach::get_abs_errtol "real
get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf::river::Reach::get_connections "cmf::water::connection_list get_connections() const ";

%feature("docstring")  cmf::river::Reach::get_depth "real get_depth()
const

Returns the water table depth. ";

%feature("docstring")  cmf::river::Reach::get_diffusive "bool
get_diffusive() const

Returns if flow is calculated using a diffusive wave model. ";

%feature("docstring")  cmf::river::Reach::get_downstream "cmf::water::flux_node::ptr get_downstream() const

Returns the reach downstream of this (or null if there is no reach
downstream) ";

%feature("docstring")  cmf::river::Reach::get_height_function "virtual const IVolumeHeightFunction& get_height_function() const

The functional relation between volume, depth and exposed area. ";

%feature("docstring")  cmf::river::Reach::get_length "real
get_length() const

Returns the length of the reach. ";

%feature("docstring")  cmf::river::Reach::get_potential "virtual real
get_potential() const

Returns the water potential of the node in m waterhead.

The base class water storage always returns the height of the location
";

%feature("docstring")  cmf::river::Reach::get_project "cmf::project&
get_project() const

Returns the project, this node is part of. ";

%feature("docstring")  cmf::river::Reach::get_reachtype "Channel
get_reachtype() const

Returns the channel shape. ";

%feature("docstring")  cmf::river::Reach::get_root "ptr get_root()

Returns the reach most downstream from this reach. ";

%feature("docstring")  cmf::river::Reach::get_state "real get_state()
const ";

%feature("docstring")  cmf::river::Reach::get_state_variable_content "char get_state_variable_content() const

A character indicating the integrated variable (either 'V' for Volume
or 'h' for head) ";

%feature("docstring")  cmf::river::Reach::get_states "cmf::math::StateVariableList get_states()

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf::river::Reach::get_upstream "ptr
get_upstream(int index) const

Returns a reach upstream of this. ";

%feature("docstring")  cmf::river::Reach::get_volume "virtual real
get_volume() const

Returns the volume of water in this storage in m3 ";

%feature("docstring")  cmf::river::Reach::get_width "real get_width()
const

Returns the average width of the reach. ";

%feature("docstring")  cmf::river::Reach::is_connected "virtual bool
is_connected(const cmf::math::StateVariable &other) const

Returns True if this waterstorage is effected by another state. ";

%feature("docstring")  cmf::river::Reach::is_storage "virtual bool
is_storage() const

Returns true, since this is a storage. ";

%feature("docstring")  cmf::river::Reach::remove_connection "bool
remove_connection(cmf::water::flux_node::ptr To)

Remove the connection. ";

%feature("docstring")  cmf::river::Reach::set_dead_end "void
set_dead_end()

Deletes any downstream connection. ";

%feature("docstring")  cmf::river::Reach::set_depth "void
set_depth(real new_depth) ";

%feature("docstring")  cmf::river::Reach::set_diffusive "void
set_diffusive(bool use_diffusive_wave)

Sets all Manning kind connections to either diffusive or kinematic. ";

%feature("docstring")  cmf::river::Reach::set_downstream "void
set_downstream(ptr new_downstream, bool use_meanchannel=false)

Connects the reach to another one downstream. ";

%feature("docstring")  cmf::river::Reach::set_height_function "virtual void set_height_function(const IVolumeHeightFunction &val) ";

%feature("docstring")  cmf::river::Reach::set_height_function "void
set_height_function(const IChannel &val)

Sets the channel shape. ";

%feature("docstring")  cmf::river::Reach::set_outlet "void
set_outlet(cmf::water::flux_node::ptr outlet)

Connects the reach to an outlet, e.g. a boundary condition. ";

%feature("docstring")  cmf::river::Reach::set_potential "virtual void
set_potential(real newpotential)

Sets the potential of this flux node. ";

%feature("docstring")  cmf::river::Reach::set_state "void
set_state(real newState) ";

%feature("docstring")  cmf::river::Reach::set_state_variable_content "void set_state_variable_content(char content)

A character indicating the integrated variable (either 'V' for Volume
or 'h' for head) ";

%feature("docstring")  cmf::river::Reach::set_volume "virtual void
set_volume(real newwatercontent)

Sets the volume of water in this storage in m3 ";

%feature("docstring")  cmf::river::Reach::Solute "SoluteStorage&
Solute(const cmf::water::solute _Solute)

Returns the water quality of the water storage. ";

%feature("docstring")  cmf::river::Reach::Solute "const
SoluteStorage& Solute(const cmf::water::solute _Solute) const ";

%feature("docstring")  cmf::river::Reach::upstream_count "int
upstream_count() const

Returns the number of reaches upstream of this. ";

%feature("docstring")  cmf::river::Reach::waterbalance "real
waterbalance(cmf::math::Time t, const flux_connection *Without=0)
const

Returns the sum of all fluxes (positive and negative) at time t.

Single fluxes can be excluded from the calculation

Parameters:
-----------

t:  Time of the query

Without:  A flux_connection that is excluded from the waterbalance
(e.g. to prevent closed circuits) ";

%feature("docstring")  cmf::river::Reach::wet_area "real wet_area()
const

Returns the exposed surface area in m2. ";


// File: classcmf__core_1_1_reach.xml
%feature("docstring") cmf_core::Reach "

A reach represents the section of a riover and is a specialization of
an open water storage.  The OpenWaterStorage attributes and methods
are extended by topological features, for the creation of a network of
reaches.  C++ includes: Reach.h ";

%feature("docstring")  cmf_core::Reach::__init__ "def __init__(self,
args, kwargs) ";

%feature("docstring")  cmf_core::Reach::__call__ "def __call__(self,
args, kwargs)

__call__(flux_node self, Time t) -> real ";

%feature("docstring")  cmf_core::Reach::__eq__ "def __eq__(self,
args, kwargs)

__eq__(flux_node self, flux_node other) -> bool ";

%feature("docstring")  cmf_core::Reach::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(WaterStorage self, solute X) -> SoluteStorage ";

%feature("docstring")  cmf_core::Reach::__hash__ "def __hash__(self)
";

%feature("docstring")  cmf_core::Reach::__repr__ "def __repr__(self)
";

%feature("docstring")  cmf_core::Reach::cast "def cast(args, kwargs)

cast(cmf::water::flux_node::ptr node) ->
cmf::river::OpenWaterStorage::ptr ";

%feature("docstring")  cmf_core::Reach::conc "def conc(self, args,
kwargs)

conc(flux_node self, Time t, solute Solute) -> real  virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const
Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf_core::Reach::conc "def conc(self, args)

conc(WaterStorage self, solute _Solute) -> real conc(WaterStorage
self, Time t, solute _Solute) -> real conc(WaterStorage self, solute
_Solute, real NewConcetration)  void conc(const cmf::water::solute
&_Solute, real NewConcetration)  Sets a new concentration. ";

%feature("docstring")  cmf_core::Reach::connect_to_cell "def
connect_to_cell(self, cell, width, subsurface_connection_type=None,
subsurface_connection_depth=None, diffusive=None)

Connects a cell with this reach using Manning's equation for surface
runoff and a given connection for subsurface interflow   - width :
Boundary width in m  - subsurface_connection_type  : Any lateral flow
connection type  - subsurface_connection_depth : The depth below
ground of the deepest layer to be connected by
subsurface_connection_type,                          default (None) =
cell.z - reach.position.z  - diffusive: Determines if a kinematic or
diffusive wave is to be used for surface runoff ";

%feature("docstring")  cmf_core::Reach::connect_to_surfacewater "def
connect_to_surfacewater(self, args, kwargs)

connect_to_surfacewater(Reach self, Cell cell, real width, bool
diffusive)  void connect_to_surfacewater(cmf::upslope::Cell *cell,
real width, bool diffusive)  Connects the surfacewater of a cell with
this reach.  Parameters: -----------  cell:  The cell with the surface
water to be connected with this reach  width:  The flow width from
cell to this reach  diffusive:  If diffusive is false, a
ManningKinematic connection is used, else a ManningDiffusive
connection ";

%feature("docstring")  cmf_core::Reach::connected_nodes "def
connected_nodes(self) ";

%feature("docstring")  cmf_core::Reach::connection_to "def
connection_to(self, args, kwargs)

connection_to(flux_node self, flux_node target) -> flux_connection
cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)  Returns the connection between this and target. ";

%feature("docstring")  cmf_core::Reach::create "def create(args)

create(project _project, real Area) ->
cmf::river::OpenWaterStorage::ptr create(project _project,
IVolumeHeightFunction base_geo) -> cmf::river::OpenWaterStorage::ptr
";

%feature("docstring")  cmf_core::Reach::create "def create(args,
kwargs)

create(project project, IChannel shape, bool diffusive=False) ->
cmf::river::Reach::ptr ";

%feature("docstring")  cmf_core::Reach::distance_to_cell "def
distance_to_cell(self, args, kwargs)

distance_to_cell(Reach self, Cell cell) -> double  double
distance_to_cell(cmf::upslope::Cell *cell) const  Returns the distance
(d) for connections between this reach and a cell.  If the effective
inner cell distance (defined as :math:`R_{Cell} =
0.5\\\\\\\\frac{\\\\\\\\sqrt{A}}{\\\\\\\\pi}`) is smaller than the
distance between the center points, the cell radius is returned ";

%feature("docstring")  cmf_core::Reach::dxdt "def dxdt(self, args,
kwargs)

dxdt(StateVariable self, Time time) -> real  virtual real dxdt(const
cmf::math::Time &time)=0  Returns the derivate of the state variable
at time time. ";

%feature("docstring")  cmf_core::Reach::flux3d_to "def
flux3d_to(self, args, kwargs)

flux3d_to(flux_node self, flux_node target, Time t) -> point
cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf_core::Reach::flux_to "def flux_to(self,
args, kwargs)

flux_to(flux_node self, flux_node target, Time t) -> real  real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)
Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf_core::Reach::fluxes "def fluxes(self, t)
";

%feature("docstring")  cmf_core::Reach::from_node "def
from_node(args, kwargs)

from_node(cmf::water::flux_node::ptr node) -> std::shared_ptr<
cmf::water::WaterStorage > ";

%feature("docstring")  cmf_core::Reach::get_3d_flux "def
get_3d_flux(self, args, kwargs)

get_3d_flux(flux_node self, Time t) -> point  cmf::geometry::point
get_3d_flux(cmf::math::Time t)  Returns the sum of all flux vectors.
";

%feature("docstring")  cmf_core::Reach::get_abs_errtol "def
get_abs_errtol(self, args, kwargs)

get_abs_errtol(StateVariable self, real rel_errtol) -> real  virtual
real get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf_core::Reach::get_height_function "def
get_height_function(self, args, kwargs)

get_height_function(OpenWaterStorage self) -> IVolumeHeightFunction
virtual const IVolumeHeightFunction& get_height_function() const  The
functional relation between volume, depth and exposed area. ";

%feature("docstring")  cmf_core::Reach::get_reachtype "def
get_reachtype(self, args, kwargs)

get_reachtype(Reach self) -> Channel  Channel get_reachtype() const
Returns the channel shape. ";

%feature("docstring")  cmf_core::Reach::get_states "def
get_states(self, args, kwargs)

get_states(StateVariableOwner self) -> StateVariableList  virtual
StateVariableList get_states()=0  Add the state variables, owned by an
object derived from StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf_core::Reach::get_upstream "def
get_upstream(self, args, kwargs)

get_upstream(Reach self, int index) -> cmf::river::Reach::ptr  ptr
get_upstream(int index) const  Returns a reach upstream of this. ";

%feature("docstring")  cmf_core::Reach::is_connected "def
is_connected(self, args, kwargs)

is_connected(StateVariable self, StateVariable other) -> bool  virtual
bool is_connected(const cmf::math::StateVariable &other) const ";

%feature("docstring")  cmf_core::Reach::is_empty "def is_empty(self,
args, kwargs)

is_empty(flux_node self) -> double  virtual double is_empty() const
Returns true if the node has no water. ";

%feature("docstring")  cmf_core::Reach::is_storage "def
is_storage(self, args, kwargs)

is_storage(flux_node self) -> bool  virtual bool is_storage() const
true, if this is a waterstorage ";

%feature("docstring")  cmf_core::Reach::RecalcFluxes "def
RecalcFluxes(self, args, kwargs)

RecalcFluxes(flux_node self, Time t) -> bool  virtual bool
RecalcFluxes(cmf::math::Time t)  Pure flux_nodes do not influence
fluxes, therefore no recalculation of fluxes is required by flux_node.
WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf_core::Reach::remove_connection "def
remove_connection(self, args, kwargs)

remove_connection(flux_node self, cmf::water::flux_node::ptr To) ->
bool  bool remove_connection(cmf::water::flux_node::ptr To)  Remove
the connection. ";

%feature("docstring")  cmf_core::Reach::set_dead_end "def
set_dead_end(self, args, kwargs)

set_dead_end(Reach self)  void set_dead_end()  Deletes any downstream
connection. ";

%feature("docstring")  cmf_core::Reach::set_downstream "def
set_downstream(self, args, kwargs)

set_downstream(Reach self, cmf::river::Reach::ptr new_downstream, bool
use_meanchannel=False)  void set_downstream(ptr new_downstream, bool
use_meanchannel=false)  Connects the reach to another one downstream.
";

%feature("docstring")  cmf_core::Reach::set_height_function "def
set_height_function(self, args, kwargs)

set_height_function(Reach self, IChannel val)  void
set_height_function(const IChannel &val)  Sets the channel shape. ";

%feature("docstring")  cmf_core::Reach::set_outlet "def
set_outlet(self, args, kwargs)

set_outlet(Reach self, cmf::water::flux_node::ptr outlet)  void
set_outlet(cmf::water::flux_node::ptr outlet)  Connects the reach to
an outlet, e.g. a boundary condition. ";

%feature("docstring")  cmf_core::Reach::Solute "def Solute(self,
args)

Solute(WaterStorage self, solute _Solute) -> SoluteStorage
Solute(WaterStorage self, solute _Solute) -> SoluteStorage  const
SoluteStorage& Solute(const cmf::water::solute _Solute) const ";

%feature("docstring")  cmf_core::Reach::to_string "def
to_string(self, args, kwargs)

to_string(StateVariable self) -> std::string  virtual std::string
to_string() const =0 ";

%feature("docstring")  cmf_core::Reach::to_string "def
to_string(self, args, kwargs)

to_string(flux_node self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::Reach::upstream "def upstream(self)

Returns a list containing all reaches flowing into self ";

%feature("docstring")  cmf_core::Reach::waterbalance "def
waterbalance(self, args, kwargs)

waterbalance(flux_node self, Time t, flux_connection Without=None) ->
real  real waterbalance(cmf::math::Time t, const flux_connection
*Without=0) const  Returns the sum of all fluxes (positive and
negative) at time t.  Single fluxes can be excluded from the
calculation  Parameters: -----------  t:  Time of the query  Without:
A flux_connection that is excluded from the waterbalance (e.g. to
prevent closed circuits) ";

%feature("docstring")  cmf_core::Reach::wet_area "def wet_area(self,
args, kwargs)

wet_area(OpenWaterStorage self) -> real  real wet_area() const Returns
the exposed surface area in m2. ";


// File: classcmf_1_1river_1_1_reach_iterator.xml
%feature("docstring") cmf::river::ReachIterator "

An iterator over every upstream reach from a start reach.

Implements both the Python and the C++ iterator interface Usage C++:
Usage Python:

C++ includes: Reach.h ";

%feature("docstring")  cmf::river::ReachIterator::ReachIterator "ReachIterator(Reach::ptr first)

Creates a ReachIterator from a first reach. ";

%feature("docstring")  cmf::river::ReachIterator::next "Reach::ptr
next()

Returns the next reach in the upstream queue. ";

%feature("docstring")  cmf::river::ReachIterator::position "double
position() const

Returns the distance to the root reach. ";

%feature("docstring")  cmf::river::ReachIterator::reach "Reach::ptr
reach() const

Returns the current reach. ";

%feature("docstring")  cmf::river::ReachIterator::valid "bool valid()
const

Returns true, if reaches are left to iterate over. ";


// File: classcmf__core_1_1_reach_iterator.xml
%feature("docstring") cmf_core::ReachIterator "

An iterator over every upstream reach from a start reach.  Implements
both the Python and the C++ iterator interface Usage C++: Usage
Python:  C++ includes: Reach.h ";

%feature("docstring")  cmf_core::ReachIterator::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::river::ReachIterator self, cmf::river::Reach::ptr first)
-> ReachIterator  ReachIterator(Reach::ptr first)  Creates a
ReachIterator from a first reach. ";

%feature("docstring")  cmf_core::ReachIterator::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::ReachIterator::next "def next(self,
args, kwargs)

next(ReachIterator self) -> cmf::river::Reach::ptr  Reach::ptr next()
Returns the next reach in the upstream queue. ";

%feature("docstring")  cmf_core::ReachIterator::valid "def
valid(self, args, kwargs)

valid(ReachIterator self) -> bool  bool valid() const  Returns true,
if reaches are left to iterate over. ";


// File: classcmf_1_1river_1_1_rectangular_reach.xml
%feature("docstring") cmf::river::RectangularReach "

Describes a IChannel with a rectangular crosssection.

C++ includes: ReachType.h ";

%feature("docstring")  cmf::river::RectangularReach::RectangularReach
"RectangularReach(double l, double width)

Creates a new rectangular reach type with width [m]. ";

%feature("docstring")  cmf::river::RectangularReach::RectangularReach
"RectangularReach(const RectangularReach &copy) ";

%feature("docstring")  cmf::river::RectangularReach::~RectangularReach
"virtual ~RectangularReach() ";

%feature("docstring")  cmf::river::RectangularReach::A "virtual
double A(double V) const

Returns the area of the surface for a given volume. ";

%feature("docstring")  cmf::river::RectangularReach::copy "RectangularReach* copy() const ";

%feature("docstring")  cmf::river::RectangularReach::get_channel_width
"virtual double get_channel_width(double depth) const

Returns the width of the stream at a given depth 

.. math::

    
    w &=& const 

. ";

%feature("docstring")  cmf::river::RectangularReach::get_depth "virtual double get_depth(double area) const

Returns the depth at a given crossection area 

.. math::

     d
    &=& \\\\frac A w 

. ";

%feature("docstring")
cmf::river::RectangularReach::get_flux_crossection "virtual double
get_flux_crossection(double depth) const

Returns the crossection area at a given depth 

.. math::

     A
    &=& d w 

. ";

%feature("docstring")  cmf::river::RectangularReach::get_length "double get_length() const

Length of the reach. ";

%feature("docstring")  cmf::river::RectangularReach::get_nManning "virtual double get_nManning() const ";

%feature("docstring")
cmf::river::RectangularReach::get_wetted_perimeter "virtual double
get_wetted_perimeter(double depth) const

Returns the wetted perimeter at a given depth 

.. math::

     P
    &=& 2 d + w 

. ";

%feature("docstring")  cmf::river::RectangularReach::h "virtual
double h(double V) const

Returns the depth of a given volume. ";

%feature("docstring")  cmf::river::RectangularReach::q "virtual
double q(double h, double slope) const ";

%feature("docstring")  cmf::river::RectangularReach::qManning "virtual double qManning(double A, double slope) const

Calculates the flow rate from a given water volume in the reach


.. math::

     q_{Manning}&=& A R^{\\\\frac 2 3}
    \\\\sqrt{\\\\frac {\\\\Delta_z} n} \\\\\\\\ A &=& \\\\frac V l
    \\\\mbox{, (Crosssectional area of the wetted crossection, Volume per
    length)} \\\\\\\\ R &=& \\\\frac A {P(d)} \\\\\\\\ P(d) &=& \\\\mbox{
    the perimeter of the wetted crosssection, a function of reach depth}
    \\\\\\\\ d(V) &=& \\\\mbox{ the depth of the reach a function of the
    volume} \\\\\\\\ \\\\Delta_z &=& \\\\frac{z_{max} - z_{min}}{l}
    \\\\mbox{ Slope of the reach} 

.

Flow rate [m3/s]

Parameters:
-----------

A:  The area of the cross section [m2]

slope:  The slope of the reach [m/m] ";

%feature("docstring")  cmf::river::RectangularReach::set_nManning "virtual void set_nManning(double nManning) ";

%feature("docstring")  cmf::river::RectangularReach::typecode "char
typecode() const ";

%feature("docstring")  cmf::river::RectangularReach::V "virtual
double V(double h) const ";


// File: classcmf__core_1_1_rectangular_reach.xml
%feature("docstring") cmf_core::RectangularReach "

Describes a IChannel with a rectangular crosssection.  C++ includes:
ReachType.h ";

%feature("docstring")  cmf_core::RectangularReach::__init__ "def
__init__(self, args)

__init__(cmf::river::RectangularReach self, double l, double width) ->
RectangularReach __init__(cmf::river::RectangularReach self,
RectangularReach copy) -> RectangularReach  RectangularReach(const
RectangularReach &copy) ";

%feature("docstring")  cmf_core::RectangularReach::A "def A(self,
args, kwargs)

A(IVolumeHeightFunction self, double V) -> double  virtual double
A(double V) const =0  Returns the area of the surface for a given
volume. ";

%feature("docstring")  cmf_core::RectangularReach::copy "def
copy(self, args, kwargs)

copy(RectangularReach self) -> RectangularReach  RectangularReach*
copy() const ";

%feature("docstring")  cmf_core::RectangularReach::get_channel_width "def get_channel_width(self, args, kwargs)

get_channel_width(IChannel self, double depth) -> double  virtual
double get_channel_width(double depth) const =0  Calculates the flow
width from a given actual depth [m] using the actual IChannel
geometry. ";

%feature("docstring")  cmf_core::RectangularReach::get_depth "def
get_depth(self, args, kwargs)

get_depth(IChannel self, double area) -> double  virtual double
get_depth(double area) const =0  Calculates the actual depth of the
reach using the IChannel geometry.  get_depth of the reach [m]
Parameters: -----------  area:  Wetted area of a river cross section
[m2], can be obtained by V/l, where V is the stored volume and l is
the reach length ";

%feature("docstring")
cmf_core::RectangularReach::get_flux_crossection "def
get_flux_crossection(self, args, kwargs)

get_flux_crossection(IChannel self, double depth) -> double  virtual
double get_flux_crossection(double depth) const =0  Calculates the
wetted area from a given depth using the IChannel geometry.  In most
cases use get_flux_crossection=V/l, where V is the stored volume and l
is the reach length Wetted area of a river cross section [m2]
Parameters: -----------  depth:  depth of the reach [m] ";

%feature("docstring")  cmf_core::RectangularReach::get_length "def
get_length(self, args, kwargs)

get_length(IChannel self) -> double  virtual double get_length() const
=0  Length of the reach. ";

%feature("docstring")  cmf_core::RectangularReach::get_nManning "def
get_nManning(self, args, kwargs)

get_nManning(IChannel self) -> double  virtual double get_nManning()
const =0 ";

%feature("docstring")
cmf_core::RectangularReach::get_wetted_perimeter "def
get_wetted_perimeter(self, args, kwargs)

get_wetted_perimeter(IChannel self, double depth) -> double  virtual
double get_wetted_perimeter(double depth) const =0  Calculates the
wetted perimeter from a given actual depth [m] using the actual
IChannel geometry. ";

%feature("docstring")  cmf_core::RectangularReach::h "def h(self,
args, kwargs)

h(IVolumeHeightFunction self, double V) -> double  virtual double
h(double V) const =0  Returns the depth of a given volume. ";

%feature("docstring")  cmf_core::RectangularReach::q "def q(self,
args, kwargs)

q(IVolumeHeightFunction self, double h, double slope) -> double
virtual double q(double h, double slope) const ";

%feature("docstring")  cmf_core::RectangularReach::qManning "def
qManning(self, args, kwargs)

qManning(IChannel self, double A, double slope) -> double  virtual
double qManning(double A, double slope) const  Calculates the flow
rate from a given water volume in the reach   .. math:: q_{Manning}&=&
A R^{\\\\\\\\frac 2 3}     \\\\\\\\sqrt{\\\\\\\\frac {\\\\\\\\Delta_z}
n} \\\\\\\\\\\\\\\\ A &=& \\\\\\\\frac V l \\\\\\\\mbox{,
(Crosssectional area of the wetted crossection, Volume per
length)} \\\\\\\\\\\\\\\\ R &=& \\\\\\\\frac A {P(d)} \\\\\\\\\\\\\\\\
P(d) &=& \\\\\\\\mbox{     the perimeter of the wetted crosssection, a
function of reach depth}     \\\\\\\\\\\\\\\\ d(V) &=& \\\\\\\\mbox{
the depth of the reach a function of the volume} \\\\\\\\\\\\\\\\
\\\\\\\\Delta_z &=& \\\\\\\\frac{z_{max} - z_{min}}{l}
\\\\\\\\mbox{ Slope of the reach}   .  Flow rate [m3/s]  Parameters:
-----------  A:  The area of the cross section [m2]  slope:  The slope
of the reach [m/m] ";

%feature("docstring")  cmf_core::RectangularReach::set_nManning "def
set_nManning(self, args, kwargs)

set_nManning(IChannel self, double val)  virtual void
set_nManning(double val)=0 ";

%feature("docstring")  cmf_core::RectangularReach::typecode "def
typecode(self, args, kwargs)

typecode(IChannel self) -> char  virtual char typecode() const =0 ";

%feature("docstring")  cmf_core::RectangularReach::V "def V(self,
args, kwargs)

V(IVolumeHeightFunction self, double h) -> double  virtual double
V(double h) const =0 ";


// File: classcmf_1_1upslope_1_1_retention_curve.xml
%feature("docstring") cmf::upslope::RetentionCurve "

Abstract base class for different types of retention curves.

This class, and its children uses wetness instead of volumetric water
content. The wetness of a soil is defined as water content per void
volume

C++ includes: RetentionCurve.h ";

%feature("docstring")  cmf::upslope::RetentionCurve::~RetentionCurve "virtual ~RetentionCurve() ";

%feature("docstring")  cmf::upslope::RetentionCurve::copy "virtual
RetentionCurve* copy() const =0 ";

%feature("docstring")  cmf::upslope::RetentionCurve::Diffusivity "virtual real Diffusivity(real wetness) const

Returns the Diffusivity of the soil.

Not implemented for all retention curves. Diffusivity is used by
MACROlikeMacroMicroExchange ";

%feature("docstring")  cmf::upslope::RetentionCurve::Diffusivity "cmf::math::num_array Diffusivity(cmf::math::num_array &wetness) ";

%feature("docstring")  cmf::upslope::RetentionCurve::dPsiM_dW "virtual real dPsiM_dW(real wetness) const ";

%feature("docstring")  cmf::upslope::RetentionCurve::dPsiM_dW "cmf::math::num_array dPsiM_dW(const cmf::math::num_array &wetness)
const ";

%feature("docstring")  cmf::upslope::RetentionCurve::FillHeight "virtual real FillHeight(real lowerDepth, real Area, real Volume) const

Returns the thickness of a soil column with a certain pore volume. ";

%feature("docstring")  cmf::upslope::RetentionCurve::K "virtual real
K(real wetness) const

Returns the conductivity in m/day at a certain depth and water
content. ";

%feature("docstring")  cmf::upslope::RetentionCurve::K "cmf::math::num_array K(const cmf::math::num_array &wetness) const ";

%feature("docstring")  cmf::upslope::RetentionCurve::MatricPotential "virtual real MatricPotential(real wetness) const

returns the wetness of the soil at given water content ";

%feature("docstring")  cmf::upslope::RetentionCurve::MatricPotential "cmf::math::num_array MatricPotential(const cmf::math::num_array
&wetness) const ";

%feature("docstring")  cmf::upslope::RetentionCurve::Porosity "virtual real Porosity(real depth=0.0) const =0

Returns the porosity at a certain depth. ";

%feature("docstring")  cmf::upslope::RetentionCurve::theta "virtual
real theta(real wetness) const

returns the water content :math:`theta` for a given wetness ";

%feature("docstring")  cmf::upslope::RetentionCurve::theta "cmf::math::num_array theta(const cmf::math::num_array &wetness) const
";

%feature("docstring")  cmf::upslope::RetentionCurve::VoidVolume "virtual real VoidVolume(real upperDepth, real lowerDepth, real Area)
const

Returns the void volume of a soil column. ";

%feature("docstring")  cmf::upslope::RetentionCurve::Wetness "virtual
real Wetness(real suction) const

returns the wetness (volumetric water content per pore space) at a
given suction pressure ";

%feature("docstring")  cmf::upslope::RetentionCurve::Wetness "cmf::math::num_array Wetness(const cmf::math::num_array &suction)
const ";

%feature("docstring")  cmf::upslope::RetentionCurve::Wetness_eff "virtual real Wetness_eff(real wetness, real pF_r=4.2) const

Returns the effective wetness, using a residual pF value 

.. math::

    w_{eff}
    =
    \\\\frac{w_{act}-w\\\\left(pF_r\\\\right)}{1-w\\\\left(pF_r\\\\right)}

.
";

%feature("docstring")  cmf::upslope::RetentionCurve::Wetness_pF "real
Wetness_pF(real pF) const

returns the volumetric water content at a given pF value ";

%feature("docstring")  cmf::upslope::RetentionCurve::Wetness_pF "cmf::math::num_array Wetness_pF(const cmf::math::num_array &pF) const
";


// File: classcmf__core_1_1_retention_curve.xml
%feature("docstring") cmf_core::RetentionCurve "

Abstract base class for different types of retention curves.  This
class, and its children uses wetness instead of volumetric water
content. The wetness of a soil is defined as water content per void
volume  C++ includes: RetentionCurve.h ";

%feature("docstring")  cmf_core::RetentionCurve::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::RetentionCurve::copy "def copy(self,
args, kwargs)

copy(RetentionCurve self) -> RetentionCurve  virtual RetentionCurve*
copy() const =0 ";

%feature("docstring")  cmf_core::RetentionCurve::Diffusivity "def
Diffusivity(self, args)

Diffusivity(RetentionCurve self, real wetness) -> real
Diffusivity(RetentionCurve self, cmf::math::num_array & wetness) ->
cmf::math::num_array  cmf::math::num_array
Diffusivity(cmf::math::num_array &wetness) ";

%feature("docstring")  cmf_core::RetentionCurve::dPsiM_dW "def
dPsiM_dW(self, args)

dPsiM_dW(RetentionCurve self, real wetness) -> real
dPsiM_dW(RetentionCurve self, cmf::math::num_array const & wetness) ->
cmf::math::num_array  cmf::math::num_array dPsiM_dW(const
cmf::math::num_array &wetness) const ";

%feature("docstring")  cmf_core::RetentionCurve::FillHeight "def
FillHeight(self, args, kwargs)

FillHeight(RetentionCurve self, real lowerDepth, real Area, real
Volume) -> real  virtual real FillHeight(real lowerDepth, real Area,
real Volume) const  Returns the thickness of a soil column with a
certain pore volume. ";

%feature("docstring")  cmf_core::RetentionCurve::K "def K(self, args)

K(RetentionCurve self, real wetness) -> real K(RetentionCurve self,
cmf::math::num_array const & wetness) -> cmf::math::num_array
cmf::math::num_array K(const cmf::math::num_array &wetness) const ";

%feature("docstring")  cmf_core::RetentionCurve::MatricPotential "def
MatricPotential(self, args)

MatricPotential(RetentionCurve self, real wetness) -> real
MatricPotential(RetentionCurve self, cmf::math::num_array const &
wetness) -> cmf::math::num_array  cmf::math::num_array
MatricPotential(const cmf::math::num_array &wetness) const ";

%feature("docstring")  cmf_core::RetentionCurve::Porosity "def
Porosity(self, args, kwargs)

Porosity(RetentionCurve self, real depth=0.0) -> real  virtual real
Porosity(real depth=0.0) const =0  Returns the porosity at a certain
depth. ";

%feature("docstring")  cmf_core::RetentionCurve::theta "def
theta(self, args)

theta(RetentionCurve self, real wetness) -> real theta(RetentionCurve
self, cmf::math::num_array const & wetness) -> cmf::math::num_array
cmf::math::num_array theta(const cmf::math::num_array &wetness) const
";

%feature("docstring")  cmf_core::RetentionCurve::VoidVolume "def
VoidVolume(self, args, kwargs)

VoidVolume(RetentionCurve self, real upperDepth, real lowerDepth, real
Area) -> real  virtual real VoidVolume(real upperDepth, real
lowerDepth, real Area) const  Returns the void volume of a soil
column. ";

%feature("docstring")  cmf_core::RetentionCurve::Wetness "def
Wetness(self, args)

Wetness(RetentionCurve self, real suction) -> real
Wetness(RetentionCurve self, cmf::math::num_array const & suction) ->
cmf::math::num_array  cmf::math::num_array Wetness(const
cmf::math::num_array &suction) const ";

%feature("docstring")  cmf_core::RetentionCurve::Wetness_eff "def
Wetness_eff(self, args, kwargs)

Wetness_eff(RetentionCurve self, real wetness, real pF_r=4.2) -> real
virtual real Wetness_eff(real wetness, real pF_r=4.2) const  Returns
the effective wetness, using a residual pF value   .. math:: w_{eff}
=
\\\\\\\\frac{w_{act}-w\\\\\\\\left(pF_r\\\\\\\\right)}{1-w\\\\\\\\left(pF_r\\\\\\\\right)}
. ";

%feature("docstring")  cmf_core::RetentionCurve::Wetness_pF "def
Wetness_pF(self, args)

Wetness_pF(RetentionCurve self, real pF) -> real
Wetness_pF(RetentionCurve self, cmf::math::num_array const & pF) ->
cmf::math::num_array  cmf::math::num_array Wetness_pF(const
cmf::math::num_array &pF) const ";


// File: classcmf__core_1_1_richards.xml
%feature("docstring") cmf_core::Richards "

Calculates flow according to the Richards equation.    .. math::
q_{Richards} &=&     \\\\\\\\frac{\\\\\\\\Delta\\\\\\\\Psi_{tot}}{d}
K(\\\\\\\\theta) A \\\\\\\\\\\\\\\\     \\\\\\\\Psi_{tot} &=
&\\\\\\\\Psi_{M}(\\\\\\\\theta) + h    where
:math:`\\\\\\\\Delta\\\\\\\\Psi_{tot} [m]` is the difference of the
total water potentials of the two soil layers  :math:`d [m]` is the
distance between the two soil layers
:math:`K(\\\\\\\\theta)\\\\\\\\left[\\\\\\\\frac m{day}\\\\\\\\right]`
is the geometric mean conductivity (see SoilType::Kunsat)  :math:`A
[m^2]` is the crosssectional area of the flux
:math:`\\\\\\\\Psi_M(\\\\\\\\theta) [m]` is the matrix potential (see
SoilType::MatrixPotential)  :math:`h [m]` is the height of a soil
layer above sea level  C++ includes: Percolation.h ";

%feature("docstring")  cmf_core::Richards::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::Richards self,
cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right)
-> Richards  Richards(cmf::upslope::SoilLayer::ptr left,
cmf::water::flux_node::ptr right)  Creates a Richards equation
connection between two soil layers (left and right, rather top and
bottom) of the same cell. ";

%feature("docstring")  cmf_core::Richards::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::Richards::__eq__ "def __eq__(self,
args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::Richards::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::Richards::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::Richards::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::Richards::conc "def conc(self, args,
kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::Richards::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::Richards::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::Richards::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::Richards::kill_me "def kill_me(self,
args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::Richards::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::Richards::q "def q(self, args,
kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::Richards::refresh "def refresh(self,
args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::Richards::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::Richards::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::Richards::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::Richards::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::Richards::use_for_cell "def
use_for_cell(args, kwargs)

use_for_cell(Cell cell, bool no_override=True) ";


// File: classcmf_1_1upslope_1_1connections_1_1_richards.xml
%feature("docstring") cmf::upslope::connections::Richards "

Calculates flow according to the Richards equation.



.. math::

     q_{Richards} &=&
    \\\\frac{\\\\Delta\\\\Psi_{tot}}{d} K(\\\\theta) A \\\\\\\\
    \\\\Psi_{tot} &= &\\\\Psi_{M}(\\\\theta) + h 

 where
:math:`\\\\Delta\\\\Psi_{tot} [m]` is the difference of the total water
potentials of the two soil layers

:math:`d [m]` is the distance between the two soil layers

:math:`K(\\\\theta)\\\\left[\\\\frac m{day}\\\\right]` is the geometric
mean conductivity (see SoilType::Kunsat)

:math:`A [m^2]` is the crosssectional area of the flux

:math:`\\\\Psi_M(\\\\theta) [m]` is the matrix potential (see
SoilType::MatrixPotential)

:math:`h [m]` is the height of a soil layer above sea level

C++ includes: Percolation.h ";

%feature("docstring")  cmf::upslope::connections::Richards::Richards "Richards(cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr
right)

Creates a Richards equation connection between two soil layers (left
and right, rather top and bottom) of the same cell. ";

%feature("docstring")  cmf::upslope::connections::Richards::conc "real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::Richards::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::upslope::connections::Richards::get_ptr "ptr get_ptr() const ";

%feature("docstring")  cmf::upslope::connections::Richards::get_target
"flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::connections::Richards::get_target
"flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::Richards::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::Richards::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::connections::Richards::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::upslope::connections::Richards::left_node
"flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::connections::Richards::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::connections::Richards::refresh "void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::upslope::connections::Richards::right_node
"flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::Richards::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::Richards::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::Richards::short_string "virtual
std::string short_string() const ";

%feature("docstring")  cmf::upslope::connections::Richards::to_string
"virtual std::string to_string() const ";


// File: classcmf__core_1_1_richards__lateral.xml
%feature("docstring") cmf_core::Richards_lateral "

Calculates the flux using Richard's equation for adjacent layers   ..
math::       q_{lat} = \\\\\\\\frac{\\\\\\\\Psi_1 -
\\\\\\\\Psi_2}{\\\\\\\\|C_1-C_2\\\\\\\\|}     K(\\\\\\\\theta) A
where:  :math:`q_{lat}` the lateral flow in :math:`m^3/day`
:math:`\\\\\\\\Psi_i` the head of node i
:math:`\\\\\\\\|C_1-C_2\\\\\\\\|` is the distance from Cell 1 to Cell
2  :math:`K(\\\\\\\\theta_{1,2}) = \\\\\\\\sqrt{K(\\\\\\\\theta_1)
K(\\\\\\\\theta_2)}`  :math:`A` the crosssectional area of the
interface between storages 1 and 2  C++ includes: subsurfacefluxes.h
";

%feature("docstring")  cmf_core::Richards_lateral::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::Richards_lateral self,
cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right,
real FlowWidth=0, real Distance=0) -> Richards_lateral
Richards_lateral(cmf::upslope::SoilLayer::ptr left,
cmf::water::flux_node::ptr right, real FlowWidth=0, real Distance=0)
Creates the connection.  Parameters: -----------  left:  Left node of
the connection (needs to be soil water storage)  right:  Right node of
the connection (can be any node)  FlowWidth:  the width of the
connection - is multiplied by layer thickness to get the interface
area  Distance:  the length of the connection. If 0, the distance is
calculated from the position of the nodes ";

%feature("docstring")  cmf_core::Richards_lateral::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::Richards_lateral::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::Richards_lateral::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::Richards_lateral::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::Richards_lateral::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::Richards_lateral::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::Richards_lateral::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::Richards_lateral::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::Richards_lateral::get_tracer_filter "def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::Richards_lateral::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::Richards_lateral::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::Richards_lateral::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::Richards_lateral::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::Richards_lateral::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::Richards_lateral::set_tracer_filter "def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::Richards_lateral::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::Richards_lateral::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::Richards_lateral::usebaseflow "def
usebaseflow(args, kwargs)

usebaseflow(bool use) ";


// File: classcmf_1_1upslope_1_1connections_1_1_richards__lateral.xml
%feature("docstring") cmf::upslope::connections::Richards_lateral "

Calculates the flux using Richard's equation for adjacent layers 

.. math::

    
    q_{lat} = \\\\frac{\\\\Psi_1 - \\\\Psi_2}{\\\\|C_1-C_2\\\\|}
    K(\\\\theta) A 

where:

:math:`q_{lat}` the lateral flow in :math:`m^3/day`

:math:`\\\\Psi_i` the head of node i

:math:`\\\\|C_1-C_2\\\\|` is the distance from Cell 1 to Cell 2

:math:`K(\\\\theta_{1,2}) = \\\\sqrt{K(\\\\theta_1) K(\\\\theta_2)}`

:math:`A` the crosssectional area of the interface between storages 1 and 2

C++ includes: subsurfacefluxes.h ";

%feature("docstring")
cmf::upslope::connections::Richards_lateral::Richards_lateral "Richards_lateral(cmf::upslope::SoilLayer::ptr left,
cmf::water::flux_node::ptr right, real FlowWidth=0, real Distance=0)

Creates the connection.

Parameters:
-----------

left:  Left node of the connection (needs to be soil water storage)

right:  Right node of the connection (can be any node)

FlowWidth:  the width of the connection - is multiplied by layer
thickness to get the interface area

Distance:  the length of the connection. If 0, the distance is
calculated from the position of the nodes ";

%feature("docstring")
cmf::upslope::connections::Richards_lateral::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::Richards_lateral::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::upslope::connections::Richards_lateral::get_ptr "ptr get_ptr()
const ";

%feature("docstring")
cmf::upslope::connections::Richards_lateral::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::Richards_lateral::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::Richards_lateral::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::Richards_lateral::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::Richards_lateral::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::Richards_lateral::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::connections::Richards_lateral::q
"real q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::Richards_lateral::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::Richards_lateral::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::Richards_lateral::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::Richards_lateral::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::Richards_lateral::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::Richards_lateral::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_r_k_f_integrator.xml
%feature("docstring") cmf_core::RKFIntegrator "

Integrates a vector of cmf::math::StateVariable with the Runge-Kutta-
Fehlberg (RKF54) method.  C++ includes: RKFintegrator.h ";

%feature("docstring")  cmf_core::RKFIntegrator::__init__ "def
__init__(self, args)

__init__(cmf::math::RKFIntegrator self, StateVariableOwner states,
real epsilon=1e-9, Time dt_min) -> RKFIntegrator
__init__(cmf::math::RKFIntegrator self, real epsilon=1e-9, Time
dt_min) -> RKFIntegrator  RKFIntegrator(real epsilon=1e-9,
cmf::math::Time dt_min=cmf::math::timespan(1000))  Constructs a new
RKFIntegrator.  Parameters: -----------  epsilon:  relative error
tolerance per time step (default=1e-9)  dt_min:  minimum time step
(default=1s) ";

%feature("docstring")  cmf_core::RKFIntegrator::__call__ "def
__call__(self, t, dt=None, reset=False)

Advances the integration until `t`  A shortcut to .integrate_until
Parameters ---------- t : cmf.Time     The time step to advance to. If
t < current time, the solver will     advance to self.t + t dt :
cmf.Time, optional     The timestep for the integration. If not given
try to integrate in one step reset : bool, optional     If True, the
solver will perform a reset before starting  Returns ------- cmf.Time
The new time stamp ";

%feature("docstring")  cmf_core::RKFIntegrator::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(Integrator self, long position) ->
cmf::math::StateVariable::ptr ";

%feature("docstring")  cmf_core::RKFIntegrator::__len__ "def
__len__(self, args, kwargs)

__len__(Integrator self) -> size_t ";

%feature("docstring")  cmf_core::RKFIntegrator::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::RKFIntegrator::add_single_state "def
add_single_state(self, args, kwargs)

add_single_state(Integrator self, cmf::math::StateVariable::ptr state)
virtual void add_single_state(cmf::math::StateVariable::ptr state)
Adds a single state variable to the integrator. ";

%feature("docstring")  cmf_core::RKFIntegrator::add_states "def
add_states(self, args, kwargs)

add_states(Integrator self, StateVariableOwner stateOwner)  virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)  Add state
variables from a StateVariableOwner. ";

%feature("docstring")  cmf_core::RKFIntegrator::copy "def copy(self,
args, kwargs)

copy(Integrator self) -> Integrator  virtual Integrator* copy() const
=0  Polymorphic copy constructor. ";

%feature("docstring")  cmf_core::RKFIntegrator::get_dt "def
get_dt(self, args, kwargs)

get_dt(Integrator self) -> Time  cmf::math::Time get_dt() const
Returns the last time step. ";

%feature("docstring")  cmf_core::RKFIntegrator::get_dxdt "def
get_dxdt(self, args, kwargs)

get_dxdt(Integrator self, Time time) -> cmf::math::num_array
cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf_core::RKFIntegrator::get_state "def
get_state(self, args, kwargs)

get_state(Integrator self, ptrdiff_t position) -> real  real
get_state(ptrdiff_t position) const  Returns the statevariable at
position Simplifies the assessment of state variables. ";

%feature("docstring")  cmf_core::RKFIntegrator::get_states "def
get_states(self, args)

get_states(Integrator self) -> cmf::math::num_array
get_states(Integrator self) -> StateVariableList  StateVariableList
get_states()  gets the state variables of the integrator ";

%feature("docstring")  cmf_core::RKFIntegrator::get_t "def
get_t(self, args, kwargs)

get_t(Integrator self) -> Time  cmf::math::Time get_t() const  Returns
the current model time. ";

%feature("docstring")  cmf_core::RKFIntegrator::integrate "def
integrate(self, args, kwargs)

integrate(Integrator self, Time t_max, Time dt) -> int  virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)=0  Integrates the
vector of state variables.  Parameters: -----------  t_max:  To stop
the model (if running in a model framework) at time steps of value
exchange e.g. full hours, the next value exchange time can be given
dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf_core::RKFIntegrator::integrate_until "def
integrate_until(self, args, kwargs)

integrate_until(Integrator self, Time t_max, Time dt, bool
reset=False)  void integrate_until(cmf::math::Time t_max,
cmf::math::Time dt=Time(), bool reset=false)  Integrates the vector of
state variables until t_max.  Parameters: -----------  t_max:   Time,
the solver should run to  dt:   Time step (may be omitted)  reset:  If
true, solver is reseted before integration starts ";

%feature("docstring")  cmf_core::RKFIntegrator::reset "def
reset(self, args, kwargs)

reset(Integrator self)  virtual void reset()  Resets any saved history
(for multistep methods) ";

%feature("docstring")  cmf_core::RKFIntegrator::run "def run(self,
start=None, end=None, step=day *1, max_errors=0, reset=False)

Returns an iterator over the timesteps start..end  **Examples:**  >>>
solver=cmf.CVodeIntegrator(...) >>> for t in solver.run(solver.t,
solver.t + cmf.week, cmf.h): >>>    print(t, solver[0].state) or with
list comprehension >>> states = [solver[0].state for t in
solver.run(solver.t, solver.t + cmf.week, cmf.h)]  Parameters
---------- start : cmf.Time, optional Start time for the solver
iteration end : cmf.Time, optional End time of the iteration step :
cmf.Time, optional Step size for the integration max_errors: int
Number of tolerated errors. If >0, up to these number of runtime
errors will be saved with their time and the integration proceeds
after a reset of the solver. Some systems operate with values close to
their physical limits and inifinite values in the integration can
easily occur. For these kind of systems set max_errors to eg. 10. A
larger number of errors should be eliminated usually. reset: bool If
True, the solver performs a `reset` at every time step  Yields ------
cmf.Time      the actual timestep ";

%feature("docstring")  cmf_core::RKFIntegrator::set_state "def
set_state(self, args, kwargs)

set_state(Integrator self, ptrdiff_t position, real newState)  void
set_state(ptrdiff_t position, real newState)  Simplifies the
assessment of state variables. ";

%feature("docstring")  cmf_core::RKFIntegrator::set_t "def
set_t(self, args, kwargs)

set_t(Integrator self, Time val)  void set_t(cmf::math::Time val) Sets
the current model time. ";

%feature("docstring")  cmf_core::RKFIntegrator::size "def size(self,
args, kwargs)

size(Integrator self) -> size_t  size_t size() const  returns the
number of state variables ";


// File: classcmf_1_1math_1_1_r_k_f_integrator.xml
%feature("docstring") cmf::math::RKFIntegrator "

Integrates a vector of cmf::math::StateVariable with the Runge-Kutta-
Fehlberg (RKF54) method.

C++ includes: RKFintegrator.h ";

/*  Accuracy parameters  */

/*  model time  */

%feature("docstring")  cmf::math::RKFIntegrator::get_t "cmf::math::Time get_t() const

Returns the current model time. ";

%feature("docstring")  cmf::math::RKFIntegrator::set_t "void
set_t(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::RKFIntegrator::get_dt "cmf::math::Time get_dt() const

Returns the last time step. ";

%feature("docstring")  cmf::math::RKFIntegrator::reset "virtual void
reset()

Resets any saved history (for multistep methods) ";

/*  Integrate  */

%feature("docstring")  cmf::math::RKFIntegrator::integrate_until "void integrate_until(cmf::math::Time t_max, cmf::math::Time dt=Time(),
bool reset=false)

Integrates the vector of state variables until t_max.

Parameters:
-----------

t_max:   Time, the solver should run to

dt:   Time step (may be omitted)

reset:  If true, solver is reseted before integration starts ";

%feature("docstring")  cmf::math::RKFIntegrator::RKFIntegrator "RKFIntegrator(StateVariableOwner &states, real epsilon=1e-9,
cmf::math::Time dt_min=cmf::math::timespan(1000))

Constructs a new RKFIntegrator from a pointer to a vector of state
variables.

The RKF Integrator becomes the owner of states

Parameters:
-----------

states:  Statevariables of the system

epsilon:  relative error tolerance per time step (default=1e-9)

dt_min:  minimum time step (default=1s) ";

%feature("docstring")  cmf::math::RKFIntegrator::RKFIntegrator "RKFIntegrator(real epsilon=1e-9, cmf::math::Time
dt_min=cmf::math::timespan(1000))

Constructs a new RKFIntegrator.

Parameters:
-----------

epsilon:  relative error tolerance per time step (default=1e-9)

dt_min:  minimum time step (default=1s) ";

%feature("docstring")  cmf::math::RKFIntegrator::add_single_state "virtual void add_single_state(cmf::math::StateVariable::ptr state)

Adds a single state variable to the integrator. ";

%feature("docstring")  cmf::math::RKFIntegrator::add_states "void
add_states(cmf::math::StateVariableOwner &stateOwner)

Adds states from an StateVariableOwner. ";

%feature("docstring")  cmf::math::RKFIntegrator::add_values_to_states
"void add_values_to_states(const num_array &operands)

Adds the values in operands to the current states. ";

%feature("docstring")  cmf::math::RKFIntegrator::copy "virtual
Integrator* copy() const

Polymorphic copy constructor. ";

%feature("docstring")  cmf::math::RKFIntegrator::copy_dxdt "void
copy_dxdt(Time time, num_array &destination, real factor=1) const

Copies the derivatives at time step \"time\" to a numeric vector using
use_OpenMP.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Vector to be overwritten by the results

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::RKFIntegrator::copy_dxdt "void
copy_dxdt(Time time, real *destination, real factor=1) const

Copies the derivatives at time step \"time\" to an preallocated c
array.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Allocated c array

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::RKFIntegrator::copy_states "void
copy_states(num_array &destination) const

Copies the states to a numeric vector using use_OpenMP. ";

%feature("docstring")  cmf::math::RKFIntegrator::copy_states "void
copy_states(real *destination) const ";

%feature("docstring")  cmf::math::RKFIntegrator::get_dxdt "cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf::math::RKFIntegrator::get_state "real
get_state(ptrdiff_t position) const

Returns the statevariable at position Simplifies the assessment of
state variables. ";

%feature("docstring")  cmf::math::RKFIntegrator::get_states "cmf::math::num_array get_states() const ";

%feature("docstring")  cmf::math::RKFIntegrator::get_states "StateVariableList get_states()

gets the state variables of the integrator ";

%feature("docstring")  cmf::math::RKFIntegrator::integrate "int
integrate(cmf::math::Time MaxTime, cmf::math::Time TimeStep)

Integrates the vector of state variables.

Parameters:
-----------

MaxTime:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

TimeStep:  Takes the proposed timestep, and changes it into the
effictivly used timestep according to the local stiffness of the
problem and MaxTime ";

%feature("docstring")  cmf::math::RKFIntegrator::set_state "void
set_state(ptrdiff_t position, real newState)

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::RKFIntegrator::set_states "void
set_states(const num_array &newStates)

Copies the new states to the actual states. ";

%feature("docstring")  cmf::math::RKFIntegrator::set_states "void
set_states(real *newStates) ";

%feature("docstring")  cmf::math::RKFIntegrator::size "size_t size()
const

returns the number of state variables ";


// File: classcmf_1_1upslope_1_1_e_t_1_1_root_uptake_stess_function.xml
%feature("docstring") cmf::upslope::ET::RootUptakeStessFunction "

An abstract class to calculate the actual transpiration from potential
transpiration.

Implementations of WaterStressFunction are used by ET connections
derived from cmf::upslope::ET::stressedET

C++ includes: waterstress.h ";

%feature("docstring")
cmf::upslope::ET::RootUptakeStessFunction::~RootUptakeStessFunction "virtual ~RootUptakeStessFunction() ";

%feature("docstring")  cmf::upslope::ET::RootUptakeStessFunction::copy
"virtual cmf::upslope::ET::RootUptakeStessFunction* copy() const =0

Creates a new copy of this wetness. ";

%feature("docstring")  cmf::upslope::ET::RootUptakeStessFunction::Tact
"virtual real Tact(const stressedET *connection, real Tpot) const =0

Calculates the water stress for a layer.

Parameters:
-----------

connection:  The stressedET connection this stress function belongs to

Tpot:  Potential Transpiration in mm/day (for the full profile)

Actual flux from layer in m3/day ";

%feature("docstring")
cmf::upslope::ET::RootUptakeStessFunction::to_string "virtual
std::string to_string() const =0 ";


// File: classcmf__core_1_1_root_uptake_stess_function.xml
%feature("docstring") cmf_core::RootUptakeStessFunction "

An abstract class to calculate the actual transpiration from potential
transpiration.  Implementations of WaterStressFunction are used by ET
connections derived from cmf::upslope::ET::stressedET  C++ includes:
waterstress.h ";

%feature("docstring")  cmf_core::RootUptakeStessFunction::__init__ "def __init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::RootUptakeStessFunction::copy "def
copy(self, args, kwargs)

copy(RootUptakeStessFunction self) -> RootUptakeStessFunction  virtual
cmf::upslope::ET::RootUptakeStessFunction* copy() const =0  Creates a
new copy of this wetness. ";

%feature("docstring")  cmf_core::RootUptakeStessFunction::Tact "def
Tact(self, args, kwargs)

Tact(RootUptakeStessFunction self, stressedET connection, real Tpot)
-> real  virtual real Tact(const stressedET *connection, real Tpot)
const =0  Calculates the water stress for a layer.  Parameters:
-----------  connection:  The stressedET connection this stress
function belongs to  Tpot:  Potential Transpiration in mm/day (for the
full profile)  Actual flux from layer in m3/day ";

%feature("docstring")  cmf_core::RootUptakeStessFunction::to_string "def to_string(self, args, kwargs)

to_string(RootUptakeStessFunction self) -> std::string  virtual
std::string to_string() const =0 ";


// File: classcmf__core_1_1_rutter_interception.xml
%feature("docstring") cmf_core::RutterInterception "

Interception storage overflow according to the Rutter and Morton
(1977) model.  Calculates the interception overflow as a storage
depending fraction of incoming rainfall The Rutter model of
interception reads as follows after Meuser, A., 1990. Effects of
afforestation on run-off characteristics. Agric. For. Meteorol. 50:
125-138.:   .. math::      \\\\\\\\frac{dI_C(t)}{dt}=P(t)(1-p_F-
p_S)-P(t)(1-p_F-     p_S)\\\\\\\\frac{I_C(t)}{I_CMAX}-f_I(E-e)(t) With
:math:`I_C` the current canopy storage and :math:`P(t)` the current
rainfall.  The second term of the equation denotes the flux from the
canopy to the ground. The implemented formula for canopy storage
overflow reads then as:   .. math::      q_{CO}(t) =
P_{net}(t)\\\\\\\\frac{V_{act}[mm]}{V_{max}[mm]}  With:
:math:`q_{CO}(t)[\\\\\\\\frac{m^3}{day}]`: The flux from canopy to the
ground  :math:`P_{net}(t)[\\\\\\\\frac{m^3}{day}]`: The flux from the
rain to the canopy  :math:`V_{act}[mm]=1000 [mm/m]
\\\\\\\\frac{V_{canopy}[m^3]}{A_{cell} [m^2]}` The stored water of the
canopy in mm  :math:`V_{max}[mm]=c_{LAI}[mm]\\\\\\\\cdot LAI` The
capacity of the canopy in mm, defined by the factor
CanopyCapacityPerLAI [mm/LAI], and the leaf area index LAI. (see:
cmf::upslope::vegetation::Vegetation)  C++ includes: surfacefluxes.h
";

%feature("docstring")  cmf_core::RutterInterception::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::RutterInterception self,
cmf::water::WaterStorage::ptr Canopy, cmf::water::flux_node::ptr
target, Cell cell) -> RutterInterception
RutterInterception(cmf::water::WaterStorage::ptr Canopy,
cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell) ";

%feature("docstring")  cmf_core::RutterInterception::__contains__ "def __contains__(self, cmp) ";

%feature("docstring")  cmf_core::RutterInterception::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::RutterInterception::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::RutterInterception::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::RutterInterception::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::RutterInterception::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::RutterInterception::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::RutterInterception::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::RutterInterception::get_tracer_filter
"def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::RutterInterception::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::RutterInterception::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::RutterInterception::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::RutterInterception::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::RutterInterception::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::RutterInterception::set_tracer_filter
"def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::RutterInterception::short_string "def short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::RutterInterception::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::RutterInterception::use_for_cell "def use_for_cell(args, kwargs)

use_for_cell(Cell cell) -> RutterInterception ";


// File: classcmf_1_1upslope_1_1connections_1_1_rutter_interception.xml
%feature("docstring") cmf::upslope::connections::RutterInterception "

Interception storage overflow according to the Rutter and Morton
(1977) model.

Calculates the interception overflow as a storage depending fraction
of incoming rainfall The Rutter model of interception reads as follows
after Meuser, A., 1990. Effects of afforestation on run-off
characteristics. Agric. For. Meteorol. 50: 125-138.:


.. math::

    \\\\frac{dI_C(t)}{dt}=P(t)(1-p_F-p_S)-P(t)(1-p_F-
    p_S)\\\\frac{I_C(t)}{I_CMAX}-f_I(E-e)(t)

With :math:`I_C` the current
canopy storage and :math:`P(t)` the current rainfall.

The second term of the equation denotes the flux from the canopy to
the ground. The implemented formula for canopy storage overflow reads
then as: 

.. math::

    q_{CO}(t) =
    P_{net}(t)\\\\frac{V_{act}[mm]}{V_{max}[mm]}

With:
:math:`q_{CO}(t)[\\\\frac{m^3}{day}]`: The flux from canopy to the ground

:math:`P_{net}(t)[\\\\frac{m^3}{day}]`: The flux from the rain to the canopy

:math:`V_{act}[mm]=1000 [mm/m] \\\\frac{V_{canopy}[m^3]}{A_{cell} [m^2]}`
The stored water of the canopy in mm

:math:`V_{max}[mm]=c_{LAI}[mm]\\\\cdot LAI` The capacity of the canopy in
mm, defined by the factor CanopyCapacityPerLAI [mm/LAI], and the leaf
area index LAI. (see: cmf::upslope::vegetation::Vegetation)

C++ includes: surfacefluxes.h ";

%feature("docstring")
cmf::upslope::connections::RutterInterception::RutterInterception "RutterInterception(cmf::water::WaterStorage::ptr Canopy,
cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell) ";

%feature("docstring")
cmf::upslope::connections::RutterInterception::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::RutterInterception::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::upslope::connections::RutterInterception::get_ptr "ptr get_ptr()
const ";

%feature("docstring")
cmf::upslope::connections::RutterInterception::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::RutterInterception::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::RutterInterception::get_tracer_filter "real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::RutterInterception::get_tracer_filter "real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::RutterInterception::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::RutterInterception::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")
cmf::upslope::connections::RutterInterception::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::RutterInterception::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::RutterInterception::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::RutterInterception::set_tracer_filter "void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::RutterInterception::set_tracer_filter "void set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::RutterInterception::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::RutterInterception::to_string "virtual
std::string to_string() const ";


// File: classcmf_1_1draw_1_1shapemap_1_1_shape_map.xml
%feature("docstring") cmf::draw::shapemap::ShapeMap "

self.fc_function: A callable taking a feature and returning a color
(fillcolor) self.lw_function: A callable taking a feature and
returning a scalar (line width) ";

%feature("docstring")  cmf::draw::shapemap::ShapeMap::__init__ "def
__init__(self, features, kwargs) ";

%feature("docstring")  cmf::draw::shapemap::ShapeMap::refresh "def
refresh(self) ";


// File: classcmf__core_1_1_shuttleworth_wallace.xml
%feature("docstring") cmf_core::ShuttleworthWallace "

Calculates the sum of soil evaporation and transpiration according to
Shuttleworth & Wallace 1985, as implemented in BROOK 90 (Federer 1990)
The difference to BROOK90 is, that the actual transpiration is not
calculated by plant resitance and potential gradient between plant and
soil, but by an piecewise linear function of the pF value :math:`pF =
\\\\\\\\log_{10}\\\\\\\\left(-\\\\\\\\Psi [hPa]\\\\\\\\right)`:   ..
math::       \\\\\\\\frac{T_{act}}{T_{pot}} = \\\\\\\\begin{cases}1 &
pF \\\\\\\\le 3.35     \\\\\\\\\\\\\\\\ \\\\\\\\frac{pF - 4.2}{3.35 -
4.2} & pF \\\\\\\\in [3.35 .. 4.2]     \\\\\\\\\\\\\\\\ 0 & pF
\\\\\\\\ge 4.2\\\\\\\\end{cases}   Calculation procedure, as in BROOK
90:  Evapotranspiration from the canopy: :math:`\\\\\\\\lambda
ET_{canopy} = \\\\\\\\frac{r_{ac} \\\\\\\\Delta\\\\\\\\ R_{n,canopy} +
c_p\\\\\\\\rho D_0}{\\\\\\\\Delta \\\\\\\\gamma r_{ac} + \\\\\\\\gamma
r_{sc}}`  Evaporation from the ground: :math:`\\\\\\\\lambda
E_{ground} = \\\\\\\\frac{r_{as} \\\\\\\\Delta\\\\\\\\ R_{n,ground} +
c_p\\\\\\\\rho D_0}{\\\\\\\\Delta \\\\\\\\gamma r_{as} + \\\\\\\\gamma
r_{ss}}`  In case of a complete surface water covered ground, the
surface resistance :math:`r_{ss}` becomes 0. (GIR)  with
:math:`\\\\\\\\Delta = \\\\\\\\frac{de_s}{dT} = 4098\\\\\\\\ 0.6108
\\\\\\\\exp\\\\\\\\left(\\\\\\\\frac{17.27
T}{T+237.3}\\\\\\\\right)(T+237.3)^{-2}`, the slope of the sat. vap.
press. T function  :math:`R_{n,ground} = R_n \\\\\\\\exp(-C_R LAI)`,
the net radiation flux to the ground  :math:`R_{n,canopy} = R_n -
R_{n,ground}`, the net radiation flux to the canopy
:math:`\\\\\\\\lambda,c_p\\\\\\\\rho,\\\\\\\\gamma` latent heat of
vaporization, heat capacity of air, psychrometer constant  :math:`D_0`
vapor pressure deficit at effective source height, see function D0
:math:`r_{ac}, r_{sc}, r_{as}, r_{ss}` Resistances for the vapor
pressure (see below)  C++ includes: ShuttleworthWallace.h ";

%feature("docstring")  cmf_core::ShuttleworthWallace::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::ET::ShuttleworthWallace self, Cell cell, bool
allow_dew=True) -> ShuttleworthWallace
ShuttleworthWallace(cmf::upslope::Cell &cell, bool allow_dew=true)
Calculates the transpiration and the soil evaporation from dry
surfaces. ";

%feature("docstring")  cmf_core::ShuttleworthWallace::evap_from_canopy
"def evap_from_canopy(self, args, kwargs)

evap_from_canopy(ShuttleworthWallace self,
cmf::water::WaterStorage::ptr canopy, Time t) -> double  double
evap_from_canopy(cmf::water::WaterStorage::ptr canopy, cmf::math::Time
t) ";

%feature("docstring")  cmf_core::ShuttleworthWallace::evap_from_layer
"def evap_from_layer(self, args, kwargs)

evap_from_layer(ShuttleworthWallace self, cmf::upslope::SoilLayer::ptr
sl, Time t) -> double  double
evap_from_layer(cmf::upslope::SoilLayer::ptr sl, cmf::math::Time t) ";

%feature("docstring")  cmf_core::ShuttleworthWallace::evap_from_snow "def evap_from_snow(self, args, kwargs)

evap_from_snow(ShuttleworthWallace self, cmf::water::WaterStorage::ptr
snow, Time t) -> double  double
evap_from_snow(cmf::water::WaterStorage::ptr snow, cmf::math::Time t)
";

%feature("docstring")
cmf_core::ShuttleworthWallace::evap_from_surfacewater "def
evap_from_surfacewater(self, args, kwargs)

evap_from_surfacewater(ShuttleworthWallace self,
cmf::river::OpenWaterStorage::ptr ows, Time t) -> double  double
evap_from_surfacewater(cmf::river::OpenWaterStorage::ptr ows,
cmf::math::Time t) ";

%feature("docstring")
cmf_core::ShuttleworthWallace::get_aerodynamic_resistance "def
get_aerodynamic_resistance(self, args, kwargs)

get_aerodynamic_resistance(aerodynamic_resistance self, double & r_ag,
double & r_ac, Time t)  virtual void get_aerodynamic_resistance(double
&r_ag, double &r_ac, cmf::math::Time t) const =0  aerodynamic
resistance from ground to atmosphere (r_ag) and from canopy to
atmosphere (r_ac) ";

%feature("docstring")  cmf_core::ShuttleworthWallace::refresh "def
refresh(self, args)

refresh(ShuttleworthWallace self, Time t) refresh(ShuttleworthWallace
self)  void refresh() ";

%feature("docstring")
cmf_core::ShuttleworthWallace::set_RSS_parameters "def
set_RSS_parameters(args, kwargs)

set_RSS_parameters(double _RSSa=500., double _RSSb=1.0, double
_RSSa_pot=-3.22) ";

%feature("docstring")
cmf_core::ShuttleworthWallace::transp_from_layer "def
transp_from_layer(self, args, kwargs)

transp_from_layer(ShuttleworthWallace self,
cmf::upslope::SoilLayer::ptr sl, Time t) -> double  double
transp_from_layer(cmf::upslope::SoilLayer::ptr sl, cmf::math::Time t)
";

%feature("docstring")  cmf_core::ShuttleworthWallace::use_for_cell "def use_for_cell(args, kwargs)

use_for_cell(Cell cell) -> cmf::upslope::ET::ShuttleworthWallace::ptr
";


// File: classcmf_1_1upslope_1_1_e_t_1_1_shuttleworth_wallace.xml
%feature("docstring") cmf::upslope::ET::ShuttleworthWallace "

Calculates the sum of soil evaporation and transpiration according to
Shuttleworth & Wallace 1985, as implemented in BROOK 90 (Federer 1990)

The difference to BROOK90 is, that the actual transpiration is not
calculated by plant resitance and potential gradient between plant and
soil, but by an piecewise linear function of the pF value :math:`pF = \\\\log_{10}\\\\left(-\\\\Psi [hPa]\\\\right)`: 

.. math::

    
    \\\\frac{T_{act}}{T_{pot}} = \\\\begin{cases}1 & pF \\\\le 3.35
    \\\\\\\\ \\\\frac{pF - 4.2}{3.35 - 4.2} & pF \\\\in [3.35 .. 4.2]
    \\\\\\\\ 0 & pF \\\\ge 4.2\\\\end{cases} 

Calculation procedure, as in BROOK 90:

Evapotranspiration from the canopy: :math:`\\\\lambda ET_{canopy} = \\\\frac{r_{ac} \\\\Delta\\\\ R_{n,canopy} + c_p\\\\rho D_0}{\\\\Delta \\\\gamma r_{ac} + \\\\gamma r_{sc}}`

Evaporation from the ground: :math:`\\\\lambda E_{ground} = \\\\frac{r_{as} \\\\Delta\\\\ R_{n,ground} + c_p\\\\rho D_0}{\\\\Delta \\\\gamma r_{as} + \\\\gamma r_{ss}}`

In case of a complete surface water covered ground, the surface
resistance :math:`r_{ss}` becomes 0. (GIR)

with  :math:`\\\\Delta = \\\\frac{de_s}{dT} = 4098\\\\ 0.6108 \\\\exp\\\\left(\\\\frac{17.27 T}{T+237.3}\\\\right)(T+237.3)^{-2}`,
the slope of the sat. vap. press. T function

:math:`R_{n,ground} = R_n \\\\exp(-C_R LAI)`, the net radiation flux to
the ground

:math:`R_{n,canopy} = R_n - R_{n,ground}`, the net radiation flux to the
canopy

:math:`\\\\lambda,c_p\\\\rho,\\\\gamma` latent heat of vaporization, heat
capacity of air, psychrometer constant

:math:`D_0` vapor pressure deficit at effective source height, see
function D0

:math:`r_{ac}, r_{sc}, r_{as}, r_{ss}` Resistances for the vapor pressure
(see below)

C++ includes: ShuttleworthWallace.h ";

%feature("docstring")
cmf::upslope::ET::ShuttleworthWallace::ShuttleworthWallace "ShuttleworthWallace(cmf::upslope::Cell &cell, bool allow_dew=true)

Calculates the transpiration and the soil evaporation from dry
surfaces. ";

%feature("docstring")
cmf::upslope::ET::ShuttleworthWallace::~ShuttleworthWallace "~ShuttleworthWallace() ";

%feature("docstring")
cmf::upslope::ET::ShuttleworthWallace::evap_from_canopy "double
evap_from_canopy(cmf::water::WaterStorage::ptr canopy, cmf::math::Time
t) ";

%feature("docstring")
cmf::upslope::ET::ShuttleworthWallace::evap_from_layer "double
evap_from_layer(cmf::upslope::SoilLayer::ptr sl, cmf::math::Time t) ";

%feature("docstring")
cmf::upslope::ET::ShuttleworthWallace::evap_from_snow "double
evap_from_snow(cmf::water::WaterStorage::ptr snow, cmf::math::Time t)
";

%feature("docstring")
cmf::upslope::ET::ShuttleworthWallace::evap_from_surfacewater "double
evap_from_surfacewater(cmf::river::OpenWaterStorage::ptr ows,
cmf::math::Time t) ";

%feature("docstring")
cmf::upslope::ET::ShuttleworthWallace::get_aerodynamic_resistance "virtual void get_aerodynamic_resistance(double &r_ag, double &r_ac,
cmf::math::Time t) const

aerodynamic resistance from ground to atmosphere (r_ag) and from
canopy to atmosphere (r_ac) ";

%feature("docstring")  cmf::upslope::ET::ShuttleworthWallace::refresh
"void refresh(cmf::math::Time t)

Calculates all the values. ";

%feature("docstring")  cmf::upslope::ET::ShuttleworthWallace::refresh
"void refresh() ";

%feature("docstring")
cmf::upslope::ET::ShuttleworthWallace::transp_from_layer "double
transp_from_layer(cmf::upslope::SoilLayer::ptr sl, cmf::math::Time t)
";


// File: classcmf_1_1math_1_1root__finding_1_1sign__error.xml
%feature("docstring") cmf::math::root_finding::sign_error "";

%feature("docstring")  cmf::math::root_finding::sign_error::sign_error
"sign_error(const std::string &msg) ";


// File: classcmf_1_1upslope_1_1connections_1_1_simple_infiltration.xml
%feature("docstring") cmf::upslope::connections::SimpleInfiltration "

Connects the surfacewater and the most upper layer using a simplified
infiltration model suitable for conceptional models.



.. math::

     q_{inf} = \\\\left(1-e_{sat}\\\\left(W, W_0\\\\right)\\\\right)
    q_{inf,pot} 

where:  :math:`q_{inf}` Effective infiltration from
surface to first layer (soil)

:math:`e_{sat}(W, W_0)` Saturation excess, ranging from 0 (nowhere saturated
soil layer) to 1 (fully saturated). :math:`W` is the average wetness
calculated from the soil layer, :math:`W_0` is a parameter denoting the
wetness, where 50% of the layer is saturated using a sigmoidal
function:  :math:`e_{sat}(W_{soil}, W_0) = \\\\left(1+e^{-(W-W_0)0.2(1-W_0)}\\\\right)^{-1}`

:math:`q_{inf,pot}` is the potential infiltration, given by the incoming
fluxes limited by the saturated conductivity:  :math:`q_{inf,pot} = \\\\min(q_{in}, K_{sat} A)`  :math:`q_{in}` Sum of incoming fluxes to the
surfacewater in :math:`m^3/day`

:math:`K_{sat}` Saturated conductivity in :math:`m/day`

:math:`A` Cell area in :math:`m^2`

C++ includes: infiltration.h ";

%feature("docstring")
cmf::upslope::connections::SimpleInfiltration::SimpleInfiltration "SimpleInfiltration(cmf::upslope::SoilLayer::ptr soilwater,
cmf::water::flux_node::ptr surfacewater, real W0=0.9)

Creates the connection between surfacewater and first soil layer.

Parameters:
-----------

soilwater:  the infiltration target

surfacewater:  the infiltration source

W0:  the 50% saturation value ";

%feature("docstring")
cmf::upslope::connections::SimpleInfiltration::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::SimpleInfiltration::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::upslope::connections::SimpleInfiltration::get_ptr "ptr get_ptr()
const ";

%feature("docstring")
cmf::upslope::connections::SimpleInfiltration::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::SimpleInfiltration::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::SimpleInfiltration::get_tracer_filter "real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::SimpleInfiltration::get_tracer_filter "real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::SimpleInfiltration::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::SimpleInfiltration::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")
cmf::upslope::connections::SimpleInfiltration::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::SimpleInfiltration::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::SimpleInfiltration::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::SimpleInfiltration::set_tracer_filter "void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::SimpleInfiltration::set_tracer_filter "void set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::SimpleInfiltration::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::SimpleInfiltration::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_simple_infiltration.xml
%feature("docstring") cmf_core::SimpleInfiltration "

Connects the surfacewater and the most upper layer using a simplified
infiltration model suitable for conceptional models.    .. math::
q_{inf} = \\\\\\\\left(1-e_{sat}\\\\\\\\left(W,
W_0\\\\\\\\right)\\\\\\\\right)     q_{inf,pot}   where:
:math:`q_{inf}` Effective infiltration from surface to first layer
(soil)  :math:`e_{sat}(W, W_0)` Saturation excess, ranging from 0
(nowhere saturated soil layer) to 1 (fully saturated). :math:`W` is
the average wetness calculated from the soil layer, :math:`W_0` is a
parameter denoting the wetness, where 50% of the layer is saturated
using a sigmoidal function:  :math:`e_{sat}(W_{soil}, W_0) =
\\\\\\\\left(1+e^{-(W-W_0)0.2(1-W_0)}\\\\\\\\right)^{-1}`
:math:`q_{inf,pot}` is the potential infiltration, given by the
incoming fluxes limited by the saturated conductivity:
:math:`q_{inf,pot} = \\\\\\\\min(q_{in}, K_{sat} A)`  :math:`q_{in}`
Sum of incoming fluxes to the surfacewater in :math:`m^3/day`
:math:`K_{sat}` Saturated conductivity in :math:`m/day`  :math:`A`
Cell area in :math:`m^2`  C++ includes: infiltration.h ";

%feature("docstring")  cmf_core::SimpleInfiltration::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::SimpleInfiltration self,
cmf::upslope::SoilLayer::ptr soilwater, cmf::water::flux_node::ptr
surfacewater, real W0=0.9) -> SimpleInfiltration
SimpleInfiltration(cmf::upslope::SoilLayer::ptr soilwater,
cmf::water::flux_node::ptr surfacewater, real W0=0.9)  Creates the
connection between surfacewater and first soil layer.  Parameters:
-----------  soilwater:  the infiltration target  surfacewater:  the
infiltration source  W0:  the 50% saturation value ";

%feature("docstring")  cmf_core::SimpleInfiltration::__contains__ "def __contains__(self, cmp) ";

%feature("docstring")  cmf_core::SimpleInfiltration::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::SimpleInfiltration::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::SimpleInfiltration::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::SimpleInfiltration::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::SimpleInfiltration::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::SimpleInfiltration::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::SimpleInfiltration::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::SimpleInfiltration::get_tracer_filter
"def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::SimpleInfiltration::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::SimpleInfiltration::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::SimpleInfiltration::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::SimpleInfiltration::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::SimpleInfiltration::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::SimpleInfiltration::set_tracer_filter
"def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::SimpleInfiltration::short_string "def short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::SimpleInfiltration::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::SimpleInfiltration::use_for_cell "def use_for_cell(args, kwargs)

use_for_cell(Cell c) ";


// File: classcmf_1_1maps_1_1_simple_quad_tree.xml
%feature("docstring") cmf::maps::SimpleQuadTree "";

%feature("docstring")  cmf::maps::SimpleQuadTree::__init__ "def
__init__(self, dx=20, dy=20) ";

%feature("docstring")  cmf::maps::SimpleQuadTree::add_object "def
add_object(self, object, bounds) ";

%feature("docstring")  cmf::maps::SimpleQuadTree::get_objects "def
get_objects(self, bounds) ";


// File: classcmf__core_1_1_simple_tindex_snow_melt.xml
%feature("docstring") cmf_core::SimpleTindexSnowMelt "

Calculates snow melt using a simple degree day method.    .. math::
q_{melt} [mm/day] = (T-T_{thres}) * r   Usage:  C++ includes:
surfacefluxes.h ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::SimpleTindexSnowMelt self,
cmf::water::WaterStorage::ptr snow, cmf::water::flux_node::ptr
surface_water, Cell cell, real rate=7.0) -> SimpleTindexSnowMelt
SimpleTindexSnowMelt(cmf::water::WaterStorage::ptr snow,
cmf::water::flux_node::ptr surface_water, cmf::upslope::Cell &cell,
real rate=7.0)  Creates a new snow melt connection.  Parameters:
-----------  snow:  Snow storage, usually cel.snow  surface_water:
target of the melted water (usually cell.surfacewater)  cell:  The
cell, needed to get weather and area  rate:  The rate of snow melt,
given in mm/(degC day), default = 7.0 ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt::__contains__ "def __contains__(self, cmp) ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt::__getitem__ "def __getitem__(self, index) ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt::exchange_target
"def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt::get_target "def get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::SimpleTindexSnowMelt::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt::right_node "def right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::SimpleTindexSnowMelt::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt::short_string "def short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt::use_for_cell "def use_for_cell(args, kwargs)

use_for_cell(Cell cell) ";


// File: classcmf_1_1upslope_1_1connections_1_1_simple_tindex_snow_melt.xml
%feature("docstring") cmf::upslope::connections::SimpleTindexSnowMelt
"

Calculates snow melt using a simple degree day method.



.. math::

     q_{melt} [mm/day] = (T-T_{thres}) * r 

Usage:

C++ includes: surfacefluxes.h ";

%feature("docstring")
cmf::upslope::connections::SimpleTindexSnowMelt::SimpleTindexSnowMelt
"SimpleTindexSnowMelt(cmf::water::WaterStorage::ptr snow,
cmf::water::flux_node::ptr surface_water, cmf::upslope::Cell &cell,
real rate=7.0)

Creates a new snow melt connection.

Parameters:
-----------

snow:  Snow storage, usually cel.snow

surface_water:  target of the melted water (usually cell.surfacewater)

cell:  The cell, needed to get weather and area

rate:  The rate of snow melt, given in mm/(degC day), default = 7.0 ";

%feature("docstring")
cmf::upslope::connections::SimpleTindexSnowMelt::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::SimpleTindexSnowMelt::exchange_target "void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")
cmf::upslope::connections::SimpleTindexSnowMelt::get_ptr "ptr
get_ptr() const ";

%feature("docstring")
cmf::upslope::connections::SimpleTindexSnowMelt::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::SimpleTindexSnowMelt::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::SimpleTindexSnowMelt::get_tracer_filter "real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::SimpleTindexSnowMelt::get_tracer_filter "real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::SimpleTindexSnowMelt::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::SimpleTindexSnowMelt::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")
cmf::upslope::connections::SimpleTindexSnowMelt::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::SimpleTindexSnowMelt::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::SimpleTindexSnowMelt::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::SimpleTindexSnowMelt::set_tracer_filter "void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::SimpleTindexSnowMelt::set_tracer_filter "void set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::SimpleTindexSnowMelt::short_string "virtual std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::SimpleTindexSnowMelt::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_simpl_richards.xml
%feature("docstring") cmf_core::SimplRichards "

Calculates flow according to a simplified Richards equation.    ..
math::       q_{Richards} &=& (K(\\\\\\\\theta) - K(\\\\\\\\theta_r))
A \\\\\\\\\\\\\\\\    where  :math:`d [m]` is the distance between the
two soil layers  :math:`K(\\\\\\\\theta)\\\\\\\\left[\\\\\\\\frac
m{day}\\\\\\\\right]` is the geometric mean conductivity (see
SoilType::Kunsat)  :math:`A [m^2]` is the crosssectional area of the
flux  C++ includes: Percolation.h ";

%feature("docstring")  cmf_core::SimplRichards::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::SimplRichards self,
cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right)
-> SimplRichards  SimplRichards(cmf::upslope::SoilLayer::ptr left,
cmf::water::flux_node::ptr right) ";

%feature("docstring")  cmf_core::SimplRichards::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::SimplRichards::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::SimplRichards::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::SimplRichards::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::SimplRichards::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::SimplRichards::conc "def conc(self,
args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::SimplRichards::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::SimplRichards::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::SimplRichards::get_tracer_filter "def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::SimplRichards::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::SimplRichards::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::SimplRichards::q "def q(self, args,
kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::SimplRichards::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::SimplRichards::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::SimplRichards::set_tracer_filter "def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::SimplRichards::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::SimplRichards::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::SimplRichards::use_for_cell "def
use_for_cell(args, kwargs)

use_for_cell(Cell cell, bool no_override=True) ";


// File: classcmf_1_1upslope_1_1connections_1_1_simpl_richards.xml
%feature("docstring") cmf::upslope::connections::SimplRichards "

Calculates flow according to a simplified Richards equation.



.. math::

     q_{Richards} &=& (K(\\\\theta) - K(\\\\theta_r))
    A \\\\\\\\ 

 where  :math:`d [m]` is the distance between
the two soil layers

:math:`K(\\\\theta)\\\\left[\\\\frac m{day}\\\\right]` is the geometric
mean conductivity (see SoilType::Kunsat)

:math:`A [m^2]` is the crosssectional area of the flux

C++ includes: Percolation.h ";

%feature("docstring")
cmf::upslope::connections::SimplRichards::SimplRichards "SimplRichards(cmf::upslope::SoilLayer::ptr left,
cmf::water::flux_node::ptr right) ";

%feature("docstring")  cmf::upslope::connections::SimplRichards::conc
"real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::SimplRichards::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::upslope::connections::SimplRichards::get_ptr "ptr get_ptr()
const ";

%feature("docstring")
cmf::upslope::connections::SimplRichards::get_target "flux_node::ptr
get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::SimplRichards::get_target "flux_node::ptr
get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::SimplRichards::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::SimplRichards::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::SimplRichards::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::SimplRichards::left_node "flux_node::ptr
left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::connections::SimplRichards::q "real q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::SimplRichards::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::SimplRichards::right_node "flux_node::ptr
right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::SimplRichards::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::SimplRichards::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::SimplRichards::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::SimplRichards::to_string "virtual
std::string to_string() const ";


// File: classcmf_1_1upslope_1_1connections_1_1_snowfall.xml
%feature("docstring") cmf::upslope::connections::Snowfall "

A connection routing snowfall (precipitation below freezing Temp) to
the snow pack.

C++ includes: AtmosphericFluxes.h ";

%feature("docstring")  cmf::upslope::connections::Snowfall::Snowfall "Snowfall(cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell)
";

%feature("docstring")  cmf::upslope::connections::Snowfall::conc "real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::Snowfall::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::upslope::connections::Snowfall::get_ptr "ptr get_ptr() const ";

%feature("docstring")  cmf::upslope::connections::Snowfall::get_target
"flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::connections::Snowfall::get_target
"flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::Snowfall::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::Snowfall::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::connections::Snowfall::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::upslope::connections::Snowfall::left_node
"flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::connections::Snowfall::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::connections::Snowfall::refresh "void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::upslope::connections::Snowfall::right_node
"flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::Snowfall::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::Snowfall::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::Snowfall::short_string "virtual
std::string short_string() const ";

%feature("docstring")  cmf::upslope::connections::Snowfall::to_string
"virtual std::string to_string() const ";


// File: classcmf__core_1_1_snowfall.xml
%feature("docstring") cmf_core::Snowfall "

A connection routing snowfall (precipitation below freezing Temp) to
the snow pack.  C++ includes: AtmosphericFluxes.h ";

%feature("docstring")  cmf_core::Snowfall::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::Snowfall self,
cmf::water::flux_node::ptr target, Cell cell) -> Snowfall
Snowfall(cmf::water::flux_node::ptr target, cmf::upslope::Cell &cell)
";

%feature("docstring")  cmf_core::Snowfall::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::Snowfall::__eq__ "def __eq__(self,
args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::Snowfall::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::Snowfall::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::Snowfall::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::Snowfall::conc "def conc(self, args,
kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::Snowfall::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::Snowfall::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::Snowfall::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::Snowfall::kill_me "def kill_me(self,
args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::Snowfall::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::Snowfall::q "def q(self, args,
kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::Snowfall::refresh "def refresh(self,
args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::Snowfall::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::Snowfall::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::Snowfall::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::Snowfall::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf__core_1_1_soil_layer.xml
%feature("docstring") cmf_core::SoilLayer "

A representation of a SoilLayer.  C++ includes: SoilLayer.h ";

%feature("docstring")  cmf_core::SoilLayer::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::SoilLayer::__call__ "def
__call__(self, args, kwargs)

__call__(flux_node self, Time t) -> real ";

%feature("docstring")  cmf_core::SoilLayer::__eq__ "def __eq__(self,
args, kwargs)

__eq__(flux_node self, flux_node other) -> bool ";

%feature("docstring")  cmf_core::SoilLayer::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(WaterStorage self, solute X) -> SoluteStorage ";

%feature("docstring")  cmf_core::SoilLayer::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::SoilLayer::cast "def cast(args,
kwargs)

cast(cmf::water::flux_node::ptr node) -> cmf::upslope::SoilLayer::ptr
";

%feature("docstring")  cmf_core::SoilLayer::conc "def conc(self,
args, kwargs)

conc(flux_node self, Time t, solute Solute) -> real  virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const
Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf_core::SoilLayer::conc "def conc(self,
args)

conc(WaterStorage self, solute _Solute) -> real conc(WaterStorage
self, Time t, solute _Solute) -> real conc(WaterStorage self, solute
_Solute, real NewConcetration)  void conc(const cmf::water::solute
&_Solute, real NewConcetration)  Sets a new concentration. ";

%feature("docstring")  cmf_core::SoilLayer::connected_nodes "def
connected_nodes(self) ";

%feature("docstring")  cmf_core::SoilLayer::connection_to "def
connection_to(self, args, kwargs)

connection_to(flux_node self, flux_node target) -> flux_connection
cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)  Returns the connection between this and target. ";

%feature("docstring")  cmf_core::SoilLayer::create "def create(args,
kwargs)

create(project _project, real initial_state=0.0, real scale=1.0) ->
std::shared_ptr< cmf::water::WaterStorage > ";

%feature("docstring")  cmf_core::SoilLayer::dxdt "def dxdt(self,
args, kwargs)

dxdt(StateVariable self, Time time) -> real  virtual real dxdt(const
cmf::math::Time &time)=0  Returns the derivate of the state variable
at time time. ";

%feature("docstring")  cmf_core::SoilLayer::flux3d_to "def
flux3d_to(self, args, kwargs)

flux3d_to(flux_node self, flux_node target, Time t) -> point
cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf_core::SoilLayer::flux_to "def
flux_to(self, args, kwargs)

flux_to(flux_node self, flux_node target, Time t) -> real  real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)
Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf_core::SoilLayer::fluxes "def fluxes(self,
t) ";

%feature("docstring")  cmf_core::SoilLayer::from_node "def
from_node(args, kwargs)

from_node(cmf::water::flux_node::ptr node) -> std::shared_ptr<
cmf::water::WaterStorage > ";

%feature("docstring")  cmf_core::SoilLayer::get_3d_flux "def
get_3d_flux(self, args, kwargs)

get_3d_flux(flux_node self, Time t) -> point  cmf::geometry::point
get_3d_flux(cmf::math::Time t)  Returns the sum of all flux vectors.
";

%feature("docstring")  cmf_core::SoilLayer::get_abs_errtol "def
get_abs_errtol(self, args, kwargs)

get_abs_errtol(StateVariable self, real rel_errtol) -> real  virtual
real get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf_core::SoilLayer::get_capacity "def
get_capacity(self, args, kwargs)

get_capacity(SoilLayer self) -> real  virtual real get_capacity()
const  Returns the capacity of the water storage in m3. ";

%feature("docstring")  cmf_core::SoilLayer::get_flow_crosssection "def get_flow_crosssection(self, args, kwargs)

get_flow_crosssection(SoilLayer self, SoilLayer target, bool
HorizontalLayers=False) -> real  real get_flow_crosssection(const
cmf::upslope::SoilLayer &target, bool HorizontalLayers=false) const
Calculates the shared crosssectional area of this and another soil
water storage.  If both layers belong to the same cell, the area of
the cell is returned, if they belong to different cells the area of
the vertical shared boundary is returned get_area in m2  Parameters:
-----------  target:  The other soil water storage  HorizontalLayers:
If true, the layers are assumed to be parallel to the gravitational
potential, otherwise they are assumed to be parallel to the ground
topography ";

%feature("docstring")  cmf_core::SoilLayer::get_K "def get_K(self,
args, kwargs)

get_K(SoilLayer self, point direction) -> real  virtual real
get_K(cmf::geometry::point direction) const  Returns the actual
anisotropic conductivity along a direction :math:`K = (k_f
\\\\\\\\cdot d) K`. ";

%feature("docstring")  cmf_core::SoilLayer::get_saturated_depth "def
get_saturated_depth(self, args, kwargs)

get_saturated_depth(SoilLayer self) -> real  virtual real
get_saturated_depth() const  Returns the depth for saturation   ..
math::       z_{sat,this} =
\\\\\\\\left\\\\\\\\{z_{cell}-\\\\\\\\Psi_{tot} \\\\\\\\mbox{ if } W<1
\\\\\\\\\\\\\\\\     z_{sat,upper layer} \\\\\\\\right.   . ";

%feature("docstring")  cmf_core::SoilLayer::get_soil "def
get_soil(self, args, kwargs)

get_soil(SoilLayer self) -> RetentionCurve  virtual
cmf::upslope::RetentionCurve& get_soil() const  Returns the soil
properties of the water storage. ";

%feature("docstring")  cmf_core::SoilLayer::get_states "def
get_states(self, args, kwargs)

get_states(StateVariableOwner self) -> StateVariableList  virtual
StateVariableList get_states()=0  Add the state variables, owned by an
object derived from StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf_core::SoilLayer::is_connected "def
is_connected(self, args, kwargs)

is_connected(StateVariable self, StateVariable other) -> bool  virtual
bool is_connected(const cmf::math::StateVariable &other) const ";

%feature("docstring")  cmf_core::SoilLayer::is_empty "def
is_empty(self, args, kwargs)

is_empty(flux_node self) -> double  virtual double is_empty() const
Returns true if the node has no water. ";

%feature("docstring")  cmf_core::SoilLayer::is_storage "def
is_storage(self, args, kwargs)

is_storage(flux_node self) -> bool  virtual bool is_storage() const
true, if this is a waterstorage ";

%feature("docstring")  cmf_core::SoilLayer::RecalcFluxes "def
RecalcFluxes(self, args, kwargs)

RecalcFluxes(flux_node self, Time t) -> bool  virtual bool
RecalcFluxes(cmf::math::Time t)  Pure flux_nodes do not influence
fluxes, therefore no recalculation of fluxes is required by flux_node.
WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf_core::SoilLayer::remove_connection "def
remove_connection(self, args, kwargs)

remove_connection(flux_node self, cmf::water::flux_node::ptr To) ->
bool  bool remove_connection(cmf::water::flux_node::ptr To)  Remove
the connection. ";

%feature("docstring")  cmf_core::SoilLayer::set_soil "def
set_soil(self, args, kwargs)

set_soil(SoilLayer self, RetentionCurve r_curve)  virtual void
set_soil(const cmf::upslope::RetentionCurve &r_curve) ";

%feature("docstring")  cmf_core::SoilLayer::Solute "def Solute(self,
args)

Solute(WaterStorage self, solute _Solute) -> SoluteStorage
Solute(WaterStorage self, solute _Solute) -> SoluteStorage  const
SoluteStorage& Solute(const cmf::water::solute _Solute) const ";

%feature("docstring")  cmf_core::SoilLayer::to_string "def
to_string(self, args, kwargs)

to_string(StateVariable self) -> std::string  virtual std::string
to_string() const =0 ";

%feature("docstring")  cmf_core::SoilLayer::to_string "def
to_string(self, args, kwargs)

to_string(flux_node self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::SoilLayer::waterbalance "def
waterbalance(self, args, kwargs)

waterbalance(flux_node self, Time t, flux_connection Without=None) ->
real  real waterbalance(cmf::math::Time t, const flux_connection
*Without=0) const  Returns the sum of all fluxes (positive and
negative) at time t.  Single fluxes can be excluded from the
calculation  Parameters: -----------  t:  Time of the query  Without:
A flux_connection that is excluded from the waterbalance (e.g. to
prevent closed circuits) ";


// File: classcmf_1_1upslope_1_1_soil_layer.xml
%feature("docstring") cmf::upslope::SoilLayer "

A representation of a SoilLayer.

C++ includes: SoilLayer.h ";

/*  Overrides of flux_node  */

%feature("docstring")  cmf::upslope::SoilLayer::RecalcFluxes "virtual
bool RecalcFluxes(cmf::math::Time t)

Pure flux_nodes do not influence fluxes, therefore no recalculation of
fluxes is required by flux_node.

WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf::upslope::SoilLayer::is_empty "virtual
double is_empty() const

Returns true if the node has no water. ";

%feature("docstring")  cmf::upslope::SoilLayer::to_string "virtual
std::string to_string() const ";

%feature("docstring")  cmf::upslope::SoilLayer::add_connected_states "virtual void add_connected_states(cmf::math::StateVariable::list
&states) ";

%feature("docstring")  cmf::upslope::SoilLayer::conc "real conc(const
cmf::water::solute &_Solute) const

Returns the concentration of the given solute. ";

%feature("docstring")  cmf::upslope::SoilLayer::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute) const

Returns the current WaterQuality (concentration of all solutes) ";

%feature("docstring")  cmf::upslope::SoilLayer::conc "void conc(const
cmf::water::solute &_Solute, real NewConcetration)

Sets a new concentration. ";

%feature("docstring")  cmf::upslope::SoilLayer::connection_to "cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::upslope::SoilLayer::dxdt "virtual real
dxdt(const cmf::math::Time &time) ";

%feature("docstring")  cmf::upslope::SoilLayer::flux3d_to "cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf::upslope::SoilLayer::flux_to "real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf::upslope::SoilLayer::get_3d_flux "cmf::geometry::point get_3d_flux(cmf::math::Time t)

Returns the sum of all flux vectors. ";

%feature("docstring")  cmf::upslope::SoilLayer::get_abs_errtol "real
get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf::upslope::SoilLayer::get_capacity "virtual
real get_capacity() const

Returns the capacity of the water storage in m3. ";

%feature("docstring")  cmf::upslope::SoilLayer::get_connections "cmf::water::connection_list get_connections() const ";

%feature("docstring")  cmf::upslope::SoilLayer::get_flow_crosssection
"real get_flow_crosssection(const cmf::upslope::SoilLayer &target,
bool HorizontalLayers=false) const

Calculates the shared crosssectional area of this and another soil
water storage.

If both layers belong to the same cell, the area of the cell is
returned, if they belong to different cells the area of the vertical
shared boundary is returned get_area in m2

Parameters:
-----------

target:  The other soil water storage

HorizontalLayers:  If true, the layers are assumed to be parallel to
the gravitational potential, otherwise they are assumed to be parallel
to the ground topography ";

%feature("docstring")
cmf::upslope::SoilLayer::get_gravitational_potential "real
get_gravitational_potential() const

Gravitational get_potential in m, reference height is sea level.

If the layer is saturated, it returns the saturated depth above sea
level, otherwise it returns the upperboundary of the layer 

.. math::

    
    \\\\Psi_G=h 

";

%feature("docstring")  cmf::upslope::SoilLayer::get_ice_fraction "real get_ice_fraction() const

real (Ice_fraction) ";

%feature("docstring")  cmf::upslope::SoilLayer::get_K "real get_K()
const

Returns the actual isotropic conductivity using the function from soil
:math:`\\\\frac{m}{day}`. ";

%feature("docstring")  cmf::upslope::SoilLayer::get_K "virtual real
get_K(cmf::geometry::point direction) const

Returns the actual anisotropic conductivity along a direction :math:`K = (k_f \\\\cdot d) K`. ";

%feature("docstring")  cmf::upslope::SoilLayer::get_Ksat "real
get_Ksat() const ";

%feature("docstring")  cmf::upslope::SoilLayer::get_lower "ptr
get_lower() const ";

%feature("docstring")  cmf::upslope::SoilLayer::get_lower_boundary "virtual real get_lower_boundary() const

Returns the lower boundary of the water storage below ground in m. ";

%feature("docstring")  cmf::upslope::SoilLayer::get_matrix_potential "virtual real get_matrix_potential() const

Calls RetentionCurve::Matrixpotential. ";

%feature("docstring")  cmf::upslope::SoilLayer::get_porosity "real
get_porosity() const

Returns the mean porosity in the layer. ";

%feature("docstring")  cmf::upslope::SoilLayer::get_potential "virtual real get_potential() const

Returns the total potential in m 

.. math::

     \\\\Psi = \\\\Psi_M + \\\\Psi_G
    

. ";

%feature("docstring")  cmf::upslope::SoilLayer::get_project "cmf::project& get_project() const

Returns the project, this node is part of. ";

%feature("docstring")  cmf::upslope::SoilLayer::get_rootfraction "real get_rootfraction() const

Returns the root fraction of the layer. If it is not explicitly set,
it uses the parameters of the vegetation object of the cell. ";

%feature("docstring")  cmf::upslope::SoilLayer::get_saturated_depth "virtual real get_saturated_depth() const

Returns the depth for saturation 

.. math::

     z_{sat,this} =
    \\\\left\\\\{z_{cell}-\\\\Psi_{tot} \\\\mbox{ if } W<1 \\\\\\\\
    z_{sat,upper layer} \\\\right. 

. ";

%feature("docstring")  cmf::upslope::SoilLayer::get_soil "virtual
cmf::upslope::RetentionCurve& get_soil() const

Returns the soil properties of the water storage. ";

%feature("docstring")  cmf::upslope::SoilLayer::get_state "real
get_state() const ";

%feature("docstring")
cmf::upslope::SoilLayer::get_state_variable_content "char
get_state_variable_content() const

A character indicating the integrated variable (either 'V' for Volume
or 'h' for head) ";

%feature("docstring")  cmf::upslope::SoilLayer::get_states "cmf::math::StateVariableList get_states()

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf::upslope::SoilLayer::get_theta "virtual
real get_theta() const

Returns the actual volumetric water content of the water storage. ";

%feature("docstring")  cmf::upslope::SoilLayer::get_thickness "real
get_thickness() const ";

%feature("docstring")  cmf::upslope::SoilLayer::get_upper "ptr
get_upper() const ";

%feature("docstring")  cmf::upslope::SoilLayer::get_upper_boundary "virtual real get_upper_boundary() const

Returns the upper boundary of the water storage below ground in m. ";

%feature("docstring")  cmf::upslope::SoilLayer::get_volume "virtual
real get_volume() const

Returns the volume of water in this storage in m3 ";

%feature("docstring")  cmf::upslope::SoilLayer::get_wetness "virtual
real get_wetness() const

Returns the wetness of the soil :math:`\\\\frac{V_{H_2O}}{V_{pores}}`. ";

%feature("docstring")  cmf::upslope::SoilLayer::is_connected "virtual
bool is_connected(const cmf::math::StateVariable &other) const

Returns True if this waterstorage is effected by another state. ";

%feature("docstring")  cmf::upslope::SoilLayer::is_storage "virtual
bool is_storage() const

Returns true, since this is a storage. ";

%feature("docstring")  cmf::upslope::SoilLayer::remove_connection "bool remove_connection(cmf::water::flux_node::ptr To)

Remove the connection. ";

%feature("docstring")  cmf::upslope::SoilLayer::set_ice_fraction "void set_ice_fraction(real val)

Parameters:
-----------

val:  Ice_fraction (real) ";

%feature("docstring")  cmf::upslope::SoilLayer::set_potential "virtual void set_potential(real waterhead)

Sets the potential of this soil water storage. ";

%feature("docstring")  cmf::upslope::SoilLayer::set_rootfraction "void set_rootfraction(real rootfraction)

Sets the root fraction in this layer explicitly. ";

%feature("docstring")  cmf::upslope::SoilLayer::set_soil "virtual
void set_soil(const cmf::upslope::RetentionCurve &r_curve) ";

%feature("docstring")  cmf::upslope::SoilLayer::set_state "void
set_state(real newState) ";

%feature("docstring")
cmf::upslope::SoilLayer::set_state_variable_content "void
set_state_variable_content(char content)

A character indicating the integrated variable (either 'V' for Volume
or 'h' for head) ";

%feature("docstring")  cmf::upslope::SoilLayer::set_theta "virtual
void set_theta(real Value) ";

%feature("docstring")  cmf::upslope::SoilLayer::set_volume "virtual
void set_volume(real newwatercontent)

Sets the volume of water in this storage in m3 ";

%feature("docstring")  cmf::upslope::SoilLayer::set_wetness "virtual
void set_wetness(real wetness) ";

%feature("docstring")  cmf::upslope::SoilLayer::Solute "SoluteStorage& Solute(const cmf::water::solute _Solute)

Returns the water quality of the water storage. ";

%feature("docstring")  cmf::upslope::SoilLayer::Solute "const
SoluteStorage& Solute(const cmf::water::solute _Solute) const ";

%feature("docstring")  cmf::upslope::SoilLayer::waterbalance "real
waterbalance(cmf::math::Time t, const flux_connection *Without=0)
const

Returns the sum of all fluxes (positive and negative) at time t.

Single fluxes can be excluded from the calculation

Parameters:
-----------

t:  Time of the query

Without:  A flux_connection that is excluded from the waterbalance
(e.g. to prevent closed circuits) ";


// File: classcmf__core_1_1solute.xml
%feature("docstring") cmf_core::solute "

A structure to identify a solute.  C++ includes: Solute.h ";

%feature("docstring")  cmf_core::solute::__init__ "def __init__(self,
args, kwargs)

__init__(cmf::water::solute self, solute copy) -> solute  solute(const
solute &copy) ";

%feature("docstring")  cmf_core::solute::__eq__ "def __eq__(self,
args, kwargs)

__eq__(solute self, solute cmp) -> bool ";

%feature("docstring")  cmf_core::solute::__ge__ "def __ge__(self,
args, kwargs)

__ge__(solute self, solute cmp) -> bool ";

%feature("docstring")  cmf_core::solute::__gt__ "def __gt__(self,
args, kwargs)

__gt__(solute self, solute cmp) -> bool ";

%feature("docstring")  cmf_core::solute::__le__ "def __le__(self,
args, kwargs)

__le__(solute self, solute cmp) -> bool ";

%feature("docstring")  cmf_core::solute::__lt__ "def __lt__(self,
args, kwargs)

__lt__(solute self, solute cmp) -> bool ";

%feature("docstring")  cmf_core::solute::__ne__ "def __ne__(self,
args, kwargs)

__ne__(solute self, solute cmp) -> bool ";

%feature("docstring")  cmf_core::solute::__repr__ "def __repr__(self,
args, kwargs)

__repr__(solute self) -> std::string ";


// File: structcmf_1_1water_1_1solute.xml
%feature("docstring") cmf::water::solute "

A structure to identify a solute.

C++ includes: Solute.h ";

%feature("docstring")  cmf::water::solute::solute "solute(const
solute &copy) ";


// File: classcmf__core_1_1solute__vector.xml
%feature("docstring") cmf_core::solute_vector "

Manages the solutes of the model.  C++ includes: Solute.h ";

%feature("docstring")  cmf_core::solute_vector::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::water::solute_vector self, std::string str) ->
solute_vector  solute_vector(std::string str)  Creates a solute vector
from solute names, separated by whitespace. E.g. solutes=
solute_vector(\"dO18 dH2\") ";

%feature("docstring")  cmf_core::solute_vector::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(solute_vector self, int i) -> solute ";

%feature("docstring")  cmf_core::solute_vector::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::solute_vector::__len__ "def
__len__(self, args, kwargs)

__len__(solute_vector self) -> size_t ";

%feature("docstring")  cmf_core::solute_vector::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::solute_vector::get_solute "def
get_solute(self, args, kwargs)

get_solute(solute_vector self, int position) -> solute
cmf::water::solute* get_solute(int position) ";

%feature("docstring")  cmf_core::solute_vector::size "def size(self,
args, kwargs)

size(solute_vector self) -> size_t  size_t size() const ";


// File: classcmf_1_1water_1_1solute__vector.xml
%feature("docstring") cmf::water::solute_vector "

Manages the solutes of the model.

C++ includes: Solute.h ";

%feature("docstring")  cmf::water::solute_vector::solute_vector "solute_vector(std::string str)

Creates a solute vector from solute names, separated by whitespace.
E.g. solutes= solute_vector(\"dO18 dH2\") ";

%feature("docstring")  cmf::water::solute_vector::begin "const_iterator begin() const ";

%feature("docstring")  cmf::water::solute_vector::end "const_iterator
end() const ";

%feature("docstring")  cmf::water::solute_vector::get_solute "cmf::water::solute* get_solute(int position) ";

%feature("docstring")  cmf::water::solute_vector::size "size_t size()
const ";


// File: classcmf__core_1_1_solute_storage.xml
%feature("docstring") cmf_core::SoluteStorage "

A class for the storage of any tracer.  The state is the amount (mol,
kg etc. see cmf::water) of the tracer in the storage.  The derivative
function is given by:   .. math::
\\\\\\\\frac{dX}{dt}&=&\\\\\\\\sum_{f=1}^{F}\\\\\\\\left( q_f
[X]_f\\\\\\\\right) +     X_{in} - r^-X
\\\\\\\\left[\\\\\\\\frac{mol}{day}\\\\\\\\right]\\\\\\\\\\\\\\\\ F&=&
\\\\\\\\mbox{Number of fluxes in water storage} \\\\\\\\\\\\\\\\
q_f&=&     \\\\\\\\mbox{Water flux in } \\\\\\\\frac{m^3}{day}
\\\\\\\\\\\\\\\\     \\\\\\\\left[X\\\\\\\\right]_f &=&
\\\\\\\\mbox{Concentration of solute X in flux     }q_f \\\\\\\\mbox{
in } \\\\\\\\frac{mol}{m^3} \\\\\\\\\\\\\\\\ X_{in} &=&
\\\\\\\\mbox{Absolute source or sink term} \\\\\\\\frac{mol}{day}
\\\\\\\\\\\\\\\\ r^-     &=& \\\\\\\\mbox{Decay rate} \\\\\\\\frac
1{day} \\\\\\\\\\\\\\\\ V &=&     \\\\\\\\mbox{Volume of water in
water storage }\\\\\\\\left[m^3\\\\\\\\right]     C++ includes:
SoluteStorage.h ";

%feature("docstring")  cmf_core::SoluteStorage::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::SoluteStorage::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::SoluteStorage::add_connected_states "def add_connected_states(self, args, kwargs)

add_connected_states(SoluteStorage self,
cmf::math::StateVariable::list & states)  virtual void
add_connected_states(cmf::math::StateVariable::list &states) ";

%feature("docstring")  cmf_core::SoluteStorage::dxdt "def dxdt(self,
args, kwargs)

dxdt(StateVariable self, Time time) -> real  virtual real dxdt(const
cmf::math::Time &time)=0  Returns the derivate of the state variable
at time time. ";

%feature("docstring")  cmf_core::SoluteStorage::get_abs_errtol "def
get_abs_errtol(self, args, kwargs)

get_abs_errtol(StateVariable self, real rel_errtol) -> real  virtual
real get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf_core::SoluteStorage::get_water "def
get_water(self, args, kwargs)

get_water(SoluteStorage self) -> WaterStorage  const WaterStorage&
get_water() const  get the waterstorge of the solute storage ";

%feature("docstring")  cmf_core::SoluteStorage::is_connected "def
is_connected(self, args, kwargs)

is_connected(StateVariable self, StateVariable other) -> bool  virtual
bool is_connected(const cmf::math::StateVariable &other) const ";

%feature("docstring")  cmf_core::SoluteStorage::set_adsorption "def
set_adsorption(self, args, kwargs)

set_adsorption(SoluteStorage self, Adsorption newadsorption, real
m=-1)  void set_adsorption(const Adsorption &newadsorption, real m=-1)
";

%feature("docstring")  cmf_core::SoluteStorage::to_string "def
to_string(self, args, kwargs)

to_string(StateVariable self) -> std::string  virtual std::string
to_string() const =0 ";


// File: classcmf_1_1water_1_1_solute_storage.xml
%feature("docstring") cmf::water::SoluteStorage "

A class for the storage of any tracer.

The state is the amount (mol, kg etc. see cmf::water) of the tracer in
the storage.

The derivative function is given by: 

.. math::

    
    \\\\frac{dX}{dt}&=&\\\\sum_{f=1}^{F}\\\\left( q_f [X]_f\\\\right) +
    X_{in} - r^-X \\\\left[\\\\frac{mol}{day}\\\\right]\\\\\\\\ F&=&
    \\\\mbox{Number of fluxes in water storage} \\\\\\\\ q_f&=&
    \\\\mbox{Water flux in } \\\\frac{m^3}{day} \\\\\\\\
    \\\\left[X\\\\right]_f &=& \\\\mbox{Concentration of solute X in flux
    }q_f \\\\mbox{ in } \\\\frac{mol}{m^3} \\\\\\\\ X_{in} &=&
    \\\\mbox{Absolute source or sink term} \\\\frac{mol}{day} \\\\\\\\ r^-
    &=& \\\\mbox{Decay rate} \\\\frac 1{day} \\\\\\\\ V &=&
    \\\\mbox{Volume of water in water storage }\\\\left[m^3\\\\right]
    



C++ includes: SoluteStorage.h ";

%feature("docstring")  cmf::water::SoluteStorage::add_connected_states
"virtual void add_connected_states(cmf::math::StateVariable::list
&states) ";

%feature("docstring")  cmf::water::SoluteStorage::dxdt "virtual real
dxdt(const cmf::math::Time &time) ";

%feature("docstring")  cmf::water::SoluteStorage::get_abs_errtol "virtual real get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf::water::SoluteStorage::get_conc "real
get_conc() const

Returns the concentration of the solute. ";

%feature("docstring")  cmf::water::SoluteStorage::get_state "real
get_state() const

Returns the current state of the variable. ";

%feature("docstring")  cmf::water::SoluteStorage::get_water "const
WaterStorage& get_water() const

get the waterstorge of the solute storage ";

%feature("docstring")  cmf::water::SoluteStorage::is_connected "virtual bool is_connected(const cmf::math::StateVariable &other) const

Returns True if this solute storage is effected by another state. ";

%feature("docstring")  cmf::water::SoluteStorage::set_adsorption "void set_adsorption(const Adsorption &newadsorption, real m=-1) ";

%feature("docstring")  cmf::water::SoluteStorage::set_conc "void
set_conc(real NewConcentration)

set a new concentration of dissolved tracers.

In case of adsorption functions, the isotherm is used ";

%feature("docstring")  cmf::water::SoluteStorage::set_state "void
set_state(real newState)

Gives access to the state variable. ";

%feature("docstring")  cmf::water::SoluteStorage::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_solute_timeseries.xml
%feature("docstring") cmf_core::SoluteTimeseries "

A map of concentration time series for solutes.  C++ includes:
Solute.h ";

%feature("docstring")  cmf_core::SoluteTimeseries::__init__ "def
__init__(self, args)

__init__(cmf::water::SoluteTimeseries self) -> SoluteTimeseries
__init__(cmf::water::SoluteTimeseries self, solute_vector solutes,
Time begin, Time step) -> SoluteTimeseries
__init__(cmf::water::SoluteTimeseries self, SoluteTimeseries sts) ->
SoluteTimeseries  SoluteTimeseries(const cmf::water::SoluteTimeseries
&sts) ";

%feature("docstring")  cmf_core::SoluteTimeseries::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(SoluteTimeseries self, solute solute) -> timeseries ";

%feature("docstring")  cmf_core::SoluteTimeseries::__len__ "def
__len__(self, args, kwargs)

__len__(SoluteTimeseries self) -> size_t ";

%feature("docstring")  cmf_core::SoluteTimeseries::__setitem__ "def
__setitem__(self, args, kwargs)

__setitem__(SoluteTimeseries self, solute solute, timeseries
concentration) ";

%feature("docstring")  cmf_core::SoluteTimeseries::conc "def
conc(self, args, kwargs)

conc(SoluteTimeseries self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute) const ";

%feature("docstring")  cmf_core::SoluteTimeseries::size "def
size(self, args, kwargs)

size(SoluteTimeseries self) -> size_t  size_t size() const  Returns
the number of solutes in the solution. ";


// File: classcmf_1_1water_1_1_solute_timeseries.xml
%feature("docstring") cmf::water::SoluteTimeseries "

A map of concentration time series for solutes.

C++ includes: Solute.h ";

%feature("docstring")  cmf::water::SoluteTimeseries::SoluteTimeseries
"SoluteTimeseries() ";

%feature("docstring")  cmf::water::SoluteTimeseries::SoluteTimeseries
"SoluteTimeseries(const solute_vector &solutes, cmf::math::Time
begin, cmf::math::Time step) ";

%feature("docstring")  cmf::water::SoluteTimeseries::SoluteTimeseries
"SoluteTimeseries(const cmf::water::SoluteTimeseries &sts) ";

%feature("docstring")  cmf::water::SoluteTimeseries::begin "iterator
begin() ";

%feature("docstring")  cmf::water::SoluteTimeseries::begin "const_iterator begin() const ";

%feature("docstring")  cmf::water::SoluteTimeseries::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute) const ";

%feature("docstring")  cmf::water::SoluteTimeseries::end "iterator
end() ";

%feature("docstring")  cmf::water::SoluteTimeseries::end "const_iterator end() const ";

%feature("docstring")  cmf::water::SoluteTimeseries::size "size_t
size() const

Returns the number of solutes in the solution. ";


// File: classcmf__core_1_1_solute_water_integrator.xml
%feature("docstring") cmf_core::SoluteWaterIntegrator "

A SoluteWaterIntegrator implements the cmf::math::Integrator
interface, but consists of two independent ODE-solvers.  Added
statevariables are sorted by waterstorages and solute storages and
assigned to the correct solver.  C++ includes: WaterSoluteIntegrator.h
";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::__init__ "def
__init__(self, args)

__init__(cmf::math::SoluteWaterIntegrator self, solute_vector solutes,
Integrator water_integrator, Integrator solute_integrator) ->
SoluteWaterIntegrator __init__(cmf::math::SoluteWaterIntegrator self,
solute_vector solutes, Integrator water_integrator, Integrator
solute_integrator, StateVariableOwner states) -> SoluteWaterIntegrator
SoluteWaterIntegrator(cmf::water::solute_vector solutes, const
cmf::math::Integrator &water_integrator, const cmf::math::Integrator
&solute_integrator, cmf::math::StateVariableOwner &states)  Creates a
new SoluteWaterIntegrator.  Parameters: -----------  solutes:  Solutes
of the project  water_integrator:  Template for the integrator of
WaterStorage state variables  solute_integrator:  Template for the
integrator of soluteStorage state variables  states:  States to be
added to the integrators ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::__call__ "def
__call__(self, t, dt=None, reset=False)

Advances the integration until `t`  A shortcut to .integrate_until
Parameters ---------- t : cmf.Time     The time step to advance to. If
t < current time, the solver will     advance to self.t + t dt :
cmf.Time, optional     The timestep for the integration. If not given
try to integrate in one step reset : bool, optional     If True, the
solver will perform a reset before starting  Returns ------- cmf.Time
The new time stamp ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::__getitem__ "def __getitem__(self, args, kwargs)

__getitem__(Integrator self, long position) ->
cmf::math::StateVariable::ptr ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::__len__ "def
__len__(self, args, kwargs)

__len__(Integrator self) -> size_t ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::__repr__ "def
__repr__(self) ";

%feature("docstring")
cmf_core::SoluteWaterIntegrator::add_single_state "def
add_single_state(self, args, kwargs)

add_single_state(Integrator self, cmf::math::StateVariable::ptr state)
virtual void add_single_state(cmf::math::StateVariable::ptr state)
Adds a single state variable to the integrator. ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::add_states "def add_states(self, args, kwargs)

add_states(Integrator self, StateVariableOwner stateOwner)  virtual
void add_states(cmf::math::StateVariableOwner &stateOwner)  Add state
variables from a StateVariableOwner. ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::copy "def
copy(self, args, kwargs)

copy(SoluteWaterIntegrator self) -> SoluteWaterIntegrator  virtual
cmf::math::SoluteWaterIntegrator* copy() const  Polymorphic copy
constructor. ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::get_dt "def
get_dt(self, args, kwargs)

get_dt(Integrator self) -> Time  cmf::math::Time get_dt() const
Returns the last time step. ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::get_dxdt "def
get_dxdt(self, args, kwargs)

get_dxdt(Integrator self, Time time) -> cmf::math::num_array
cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::get_state "def get_state(self, args, kwargs)

get_state(Integrator self, ptrdiff_t position) -> real  real
get_state(ptrdiff_t position) const  Returns the statevariable at
position Simplifies the assessment of state variables. ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::get_states "def get_states(self, args)

get_states(Integrator self) -> cmf::math::num_array
get_states(Integrator self) -> StateVariableList  StateVariableList
get_states()  gets the state variables of the integrator ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::get_t "def
get_t(self, args, kwargs)

get_t(Integrator self) -> Time  cmf::math::Time get_t() const  Returns
the current model time. ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::integrate "def integrate(self, args, kwargs)

integrate(Integrator self, Time t_max, Time dt) -> int  virtual int
integrate(cmf::math::Time t_max, cmf::math::Time dt)=0  Integrates the
vector of state variables.  Parameters: -----------  t_max:  To stop
the model (if running in a model framework) at time steps of value
exchange e.g. full hours, the next value exchange time can be given
dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")
cmf_core::SoluteWaterIntegrator::integrate_until "def
integrate_until(self, args, kwargs)

integrate_until(Integrator self, Time t_max, Time dt, bool
reset=False)  void integrate_until(cmf::math::Time t_max,
cmf::math::Time dt=Time(), bool reset=false)  Integrates the vector of
state variables until t_max.  Parameters: -----------  t_max:   Time,
the solver should run to  dt:   Time step (may be omitted)  reset:  If
true, solver is reseted before integration starts ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::reset "def
reset(self, args, kwargs)

reset(Integrator self)  virtual void reset()  Resets any saved history
(for multistep methods) ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::run "def
run(self, start=None, end=None, step=day *1, max_errors=0,
reset=False)

Returns an iterator over the timesteps start..end  **Examples:**  >>>
solver=cmf.CVodeIntegrator(...) >>> for t in solver.run(solver.t,
solver.t + cmf.week, cmf.h): >>>    print(t, solver[0].state) or with
list comprehension >>> states = [solver[0].state for t in
solver.run(solver.t, solver.t + cmf.week, cmf.h)]  Parameters
---------- start : cmf.Time, optional Start time for the solver
iteration end : cmf.Time, optional End time of the iteration step :
cmf.Time, optional Step size for the integration max_errors: int
Number of tolerated errors. If >0, up to these number of runtime
errors will be saved with their time and the integration proceeds
after a reset of the solver. Some systems operate with values close to
their physical limits and inifinite values in the integration can
easily occur. For these kind of systems set max_errors to eg. 10. A
larger number of errors should be eliminated usually. reset: bool If
True, the solver performs a `reset` at every time step  Yields ------
cmf.Time      the actual timestep ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::set_state "def set_state(self, args, kwargs)

set_state(Integrator self, ptrdiff_t position, real newState)  void
set_state(ptrdiff_t position, real newState)  Simplifies the
assessment of state variables. ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::set_t "def
set_t(self, args, kwargs)

set_t(Integrator self, Time val)  void set_t(cmf::math::Time val) Sets
the current model time. ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::size "def
size(self, args, kwargs)

size(Integrator self) -> size_t  size_t size() const  returns the
number of state variables ";

%feature("docstring")  cmf_core::SoluteWaterIntegrator::to_string "def to_string(self, args, kwargs)

to_string(SoluteWaterIntegrator self) -> std::string  std::string
to_string() const ";


// File: classcmf_1_1math_1_1_solute_water_integrator.xml
%feature("docstring") cmf::math::SoluteWaterIntegrator "

A SoluteWaterIntegrator implements the cmf::math::Integrator
interface, but consists of two independent ODE-solvers.

Added statevariables are sorted by waterstorages and solute storages
and assigned to the correct solver.

C++ includes: WaterSoluteIntegrator.h ";

/*  Accuracy parameters  */

/*  model time  */

%feature("docstring")  cmf::math::SoluteWaterIntegrator::get_t "cmf::math::Time get_t() const

Returns the current model time. ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::set_t "void
set_t(cmf::math::Time val)

Sets the current model time. ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::get_dt "cmf::math::Time get_dt() const

Returns the last time step. ";

/*  Integrate  */

%feature("docstring")
cmf::math::SoluteWaterIntegrator::integrate_until "void
integrate_until(cmf::math::Time t_max, cmf::math::Time dt=Time(), bool
reset=false)

Integrates the vector of state variables until t_max.

Parameters:
-----------

t_max:   Time, the solver should run to

dt:   Time step (may be omitted)

reset:  If true, solver is reseted before integration starts ";

%feature("docstring")
cmf::math::SoluteWaterIntegrator::SoluteWaterIntegrator "SoluteWaterIntegrator(const cmf::water::solute_vector &solutes, const
cmf::math::Integrator &water_integrator, const cmf::math::Integrator
&solute_integrator)

Creates a new SoluteWaterIntegrator.

Parameters:
-----------

solutes:  Solutes of the project

water_integrator:  Template for the integrator of WaterStorage state
variables

solute_integrator:  Template for the integrator of soluteStorage state
variables ";

%feature("docstring")
cmf::math::SoluteWaterIntegrator::SoluteWaterIntegrator "SoluteWaterIntegrator(cmf::water::solute_vector solutes, const
cmf::math::Integrator &water_integrator, const cmf::math::Integrator
&solute_integrator, cmf::math::StateVariableOwner &states)

Creates a new SoluteWaterIntegrator.

Parameters:
-----------

solutes:  Solutes of the project

water_integrator:  Template for the integrator of WaterStorage state
variables

solute_integrator:  Template for the integrator of soluteStorage state
variables

states:  States to be added to the integrators ";

%feature("docstring")
cmf::math::SoluteWaterIntegrator::~SoluteWaterIntegrator "~SoluteWaterIntegrator() ";

%feature("docstring")
cmf::math::SoluteWaterIntegrator::add_single_state "virtual void
add_single_state(cmf::math::StateVariable::ptr state)

Adds a single state variable to the integrator. ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::add_states "void add_states(cmf::math::StateVariableOwner &stateOwner)

Add state variables from a StateVariableOwner. ";

%feature("docstring")
cmf::math::SoluteWaterIntegrator::add_values_to_states "void
add_values_to_states(const num_array &operands)

Adds the values in operands to the current states. ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::copy "virtual cmf::math::SoluteWaterIntegrator* copy() const

Polymorphic copy constructor. ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::copy_dxdt "void copy_dxdt(Time time, num_array &destination, real factor=1) const

Copies the derivatives at time step \"time\" to a numeric vector using
use_OpenMP.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Vector to be overwritten by the results

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::copy_dxdt "void copy_dxdt(Time time, real *destination, real factor=1) const

Copies the derivatives at time step \"time\" to an preallocated c
array.

Parameters:
-----------

time:   Time at which the derivatives should be calculated

destination:  Allocated c array

factor:  A factor that is multiplied to the derivate (e.g. unit
conversion or integration length) ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::copy_states "void copy_states(num_array &destination) const

Copies the states to a numeric vector using use_OpenMP. ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::copy_states "void copy_states(real *destination) const ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::get_dxdt "cmf::math::num_array get_dxdt(Time time) const ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::get_state "real get_state(ptrdiff_t position) const

Returns the statevariable at position Simplifies the assessment of
state variables. ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::get_states "cmf::math::num_array get_states() const ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::get_states "StateVariableList get_states()

gets the state variables of the integrator ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::integrate "int integrate(cmf::math::Time t_max, cmf::math::Time dt)

Integrates the vector of state variables.

Parameters:
-----------

t_max:  To stop the model (if running in a model framework) at time
steps of value exchange e.g. full hours, the next value exchange time
can be given

dt:  Takes the proposed time step, and changes it into the effectively
used time step according to the local stiffness of the problem and
MaxTime ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::reset "virtual void reset()

Resets the integrators (only needed for multistep methods) ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::set_state "void set_state(ptrdiff_t position, real newState)

Simplifies the assessment of state variables. ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::set_states "void set_states(const num_array &newStates)

Copies the new states to the actual states. ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::set_states "void set_states(real *newStates) ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::size "size_t
size() const

returns the number of state variables ";

%feature("docstring")  cmf::math::SoluteWaterIntegrator::to_string "std::string to_string() const ";


// File: classcmf__core_1_1sparse__structure.xml
%feature("docstring") cmf_core::sparse_structure "

Proxy of C++ cmf::math::sparse_structure class. ";

%feature("docstring")  cmf_core::sparse_structure::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::math::sparse_structure self) -> sparse_structure
sparse_structure()  Creates the sparse row compressed structure from
states variable list. ";

%feature("docstring")  cmf_core::sparse_structure::generate "def
generate(self, args, kwargs)

generate(sparse_structure self, StateVariableList states) -> size_t
size_t generate(const StateVariableList &states) ";


// File: structcmf_1_1math_1_1sparse__structure.xml
%feature("docstring") cmf::math::sparse_structure "";

%feature("docstring")  cmf::math::sparse_structure::sparse_structure "sparse_structure()

Creates the sparse row compressed structure from states variable list.
";

%feature("docstring")  cmf::math::sparse_structure::generate "size_t
generate(const StateVariableList &states) ";


// File: classcmf_1_1water_1_1statecontrol__connection.xml
%feature("docstring") cmf::water::statecontrol_connection "

Calculates a flux to or from a water storage to hold it's state at a
more or less constant level.



.. math::

     q=\\\\frac{h_1 - h_{target}}{t_c [days]} 

where:  :math:`q` the
resulting flux in m3/day

:math:`h_1` the reference state

:math:`h_{target}` the state of the target (right) node

:math:`t_c` the time to reach the target state

C++ includes: simple_connections.h ";

%feature("docstring")
cmf::water::statecontrol_connection::statecontrol_connection "statecontrol_connection(cmf::water::WaterStorage::ptr
controlled_storage, cmf::water::flux_node::ptr other_end, real
target_state, cmf::math::Time reaction_time)

Creates a flux connection to control the state of a storage.

Parameters:
-----------

controlled_storage:  Water storage, to be controlled

other_end:  source of missing water or target of excessive water

target_state:  State the controlled storage should hold (
:math:`h_{target}`)

reaction_time:  Time to reach state ( :math:`t_c`) ";

%feature("docstring")  cmf::water::statecontrol_connection::conc "real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::water::statecontrol_connection::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::water::statecontrol_connection::get_ptr "ptr get_ptr() const ";

%feature("docstring")  cmf::water::statecontrol_connection::get_target
"flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::water::statecontrol_connection::get_target
"flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::water::statecontrol_connection::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::statecontrol_connection::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::water::statecontrol_connection::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::water::statecontrol_connection::left_node
"flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::water::statecontrol_connection::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::water::statecontrol_connection::refresh "void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::water::statecontrol_connection::right_node
"flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::water::statecontrol_connection::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::statecontrol_connection::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::water::statecontrol_connection::short_string "virtual
std::string short_string() const ";

%feature("docstring")  cmf::water::statecontrol_connection::to_string
"virtual std::string to_string() const ";


// File: classcmf__core_1_1statecontrol__connection.xml
%feature("docstring") cmf_core::statecontrol_connection "

Calculates a flux to or from a water storage to hold it's state at a
more or less constant level.    .. math::       q=\\\\\\\\frac{h_1 -
h_{target}}{t_c [days]}   where:  :math:`q` the resulting flux in
m3/day  :math:`h_1` the reference state  :math:`h_{target}` the state
of the target (right) node  :math:`t_c` the time to reach the target
state  C++ includes: simple_connections.h ";

%feature("docstring")  cmf_core::statecontrol_connection::__init__ "def __init__(self, args, kwargs)

__init__(cmf::water::statecontrol_connection self,
cmf::water::WaterStorage::ptr controlled_storage,
cmf::water::flux_node::ptr other_end, real target_state, Time
reaction_time) -> statecontrol_connection
statecontrol_connection(cmf::water::WaterStorage::ptr
controlled_storage, cmf::water::flux_node::ptr other_end, real
target_state, cmf::math::Time reaction_time)  Creates a flux
connection to control the state of a storage.  Parameters: -----------
controlled_storage:  Water storage, to be controlled  other_end:
source of missing water or target of excessive water  target_state:
State the controlled storage should hold ( :math:`h_{target}`)
reaction_time:  Time to reach state ( :math:`t_c`) ";

%feature("docstring")  cmf_core::statecontrol_connection::__contains__
"def __contains__(self, cmp) ";

%feature("docstring")  cmf_core::statecontrol_connection::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::statecontrol_connection::__getitem__
"def __getitem__(self, index) ";

%feature("docstring")  cmf_core::statecontrol_connection::__iter__ "def __iter__(self) ";

%feature("docstring")  cmf_core::statecontrol_connection::__repr__ "def __repr__(self) ";

%feature("docstring")  cmf_core::statecontrol_connection::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::statecontrol_connection::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::statecontrol_connection::get_target "def get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::statecontrol_connection::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::statecontrol_connection::kill_me "def kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::statecontrol_connection::left_node "def left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::statecontrol_connection::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::statecontrol_connection::refresh "def refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::statecontrol_connection::right_node "def right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::statecontrol_connection::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::statecontrol_connection::short_string
"def short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::statecontrol_connection::to_string "def to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf__core_1_1_state_variable.xml
%feature("docstring") cmf_core::StateVariable "

Proxy of C++ cmf::math::StateVariable class. ";

%feature("docstring")  cmf_core::StateVariable::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::StateVariable::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::StateVariable::dxdt "def dxdt(self,
args, kwargs)

dxdt(StateVariable self, Time time) -> real  virtual real dxdt(const
cmf::math::Time &time)=0  Returns the derivate of the state variable
at time time. ";

%feature("docstring")  cmf_core::StateVariable::get_abs_errtol "def
get_abs_errtol(self, args, kwargs)

get_abs_errtol(StateVariable self, real rel_errtol) -> real  virtual
real get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf_core::StateVariable::is_connected "def
is_connected(self, args, kwargs)

is_connected(StateVariable self, StateVariable other) -> bool  virtual
bool is_connected(const cmf::math::StateVariable &other) const ";

%feature("docstring")  cmf_core::StateVariable::to_string "def
to_string(self, args, kwargs)

to_string(StateVariable self) -> std::string  virtual std::string
to_string() const =0 ";


// File: classcmf_1_1math_1_1_state_variable.xml
%feature("docstring") cmf::math::StateVariable "";

%feature("docstring")  cmf::math::StateVariable::StateVariable "StateVariable(real InitialState=0, real scale=1)

ctor ";

%feature("docstring")  cmf::math::StateVariable::~StateVariable "virtual ~StateVariable() ";

%feature("docstring")  cmf::math::StateVariable::add_connected_states
"virtual void add_connected_states(list &states) ";

%feature("docstring")  cmf::math::StateVariable::dxdt "virtual real
dxdt(const cmf::math::Time &time)=0

Returns the derivate of the state variable at time time. ";

%feature("docstring")  cmf::math::StateVariable::get_abs_errtol "virtual real get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf::math::StateVariable::get_state "real
get_state() const

Returns the current state of the variable. ";

%feature("docstring")  cmf::math::StateVariable::is_connected "virtual bool is_connected(const cmf::math::StateVariable &other) const
";

%feature("docstring")  cmf::math::StateVariable::set_state "void
set_state(real newState)

Gives access to the state variable. ";

%feature("docstring")  cmf::math::StateVariable::to_string "virtual
std::string to_string() const =0 ";


// File: classcmf__core_1_1_state_variable_list.xml
%feature("docstring") cmf_core::StateVariableList "

Proxy of C++ cmf::math::StateVariableList class. ";

%feature("docstring")  cmf_core::StateVariableList::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::math::StateVariableList self) -> StateVariableList ";

%feature("docstring")  cmf_core::StateVariableList::__iadd__ "def
__iadd__(self, args)

__iadd__(StateVariableList self, StateVariableList food) ->
StateVariableList __iadd__(StateVariableList self, StateVariableOwner
svo) -> StateVariableList ";

%feature("docstring")  cmf_core::StateVariableList::__len__ "def
__len__(self, args, kwargs)

__len__(StateVariableList self) -> size_t ";

%feature("docstring")  cmf_core::StateVariableList::append "def
append(self, args, kwargs)

append(StateVariableList self, cmf::math::StateVariable::ptr sv)  void
append(StateVariable::ptr sv) ";

%feature("docstring")  cmf_core::StateVariableList::extend "def
extend(self, args, kwargs)

extend(StateVariableList self, StateVariableOwner svo)  void
extend(StateVariableOwner &svo) ";

%feature("docstring")  cmf_core::StateVariableList::get_states "def
get_states(self, args, kwargs)

get_states(StateVariableOwner self) -> StateVariableList  virtual
StateVariableList get_states()=0  Add the state variables, owned by an
object derived from StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf_core::StateVariableList::size "def
size(self, args, kwargs)

size(StateVariableList self) -> size_t  size_t size() const ";


// File: classcmf_1_1math_1_1_state_variable_list.xml
%feature("docstring") cmf::math::StateVariableList "";

%feature("docstring")
cmf::math::StateVariableList::~StateVariableList "virtual
~StateVariableList() ";

%feature("docstring")  cmf::math::StateVariableList::append "void
append(StateVariable::ptr sv) ";

%feature("docstring")  cmf::math::StateVariableList::begin "state_vector::iterator begin() ";

%feature("docstring")  cmf::math::StateVariableList::begin "state_vector::const_iterator begin() const ";

%feature("docstring")  cmf::math::StateVariableList::end "state_vector::iterator end() ";

%feature("docstring")  cmf::math::StateVariableList::end "state_vector::const_iterator end() const ";

%feature("docstring")  cmf::math::StateVariableList::extend "void
extend(StateVariableOwner &svo) ";

%feature("docstring")  cmf::math::StateVariableList::get_states "StateVariableList get_states() ";

%feature("docstring")  cmf::math::StateVariableList::size "size_t
size() const ";


// File: classcmf_1_1math_1_1_state_variable_owner.xml
%feature("docstring") cmf::math::StateVariableOwner "

An abstract class, that owns one or more state variables, that can add
them to a vector of state variables in a certain order.

C++ includes: statevariable.h ";

%feature("docstring")
cmf::math::StateVariableOwner::~StateVariableOwner "virtual
~StateVariableOwner() ";

%feature("docstring")  cmf::math::StateVariableOwner::get_states "virtual StateVariableList get_states()=0

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";


// File: classcmf__core_1_1_state_variable_owner.xml
%feature("docstring") cmf_core::StateVariableOwner "

An abstract class, that owns one or more state variables, that can add
them to a vector of state variables in a certain order.  C++ includes:
statevariable.h ";

%feature("docstring")  cmf_core::StateVariableOwner::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::StateVariableOwner::get_states "def
get_states(self, args, kwargs)

get_states(StateVariableOwner self) -> StateVariableList  virtual
StateVariableList get_states()=0  Add the state variables, owned by an
object derived from StateVariableOwner, to the given vector. ";


// File: classcmf_1_1stopwatch_1_1_stop_watch.xml
%feature("docstring") cmf::stopwatch::StopWatch "

A stopwatch to estimated the total time of a process    Creating a
StopWatch: >>>stopwatch=StopWatch(start,stop)  Start and end are
indicators to describe the progress of a process.  Start is the
indicator value at the beginning of the process. As default they are
0.0 and 1.0.  Starting the StopWatch again: >>>stopwatch.start()
Getting the elapsed time, the total time and the remaining time of the
process in seconds: >>>elapsed,total,remaining = stopwatch(progress)
Where progress is a process progress indicator matching start and stop
Example: stopwatch=StopWatch(0,10) for i in range(10): time.sleep(1)
print('elapsed = %0.2fs, total= %0.2fs, remaining = %0.2fs' %
stopwatch(i+1)) ";

%feature("docstring")  cmf::stopwatch::StopWatch::__init__ "def
__init__(self, start=0.0, stop=1.0) ";

%feature("docstring")  cmf::stopwatch::StopWatch::__call__ "def
__call__(self, progress) ";

%feature("docstring")  cmf::stopwatch::StopWatch::start "def
start(self) ";


// File: classcmf_1_1upslope_1_1_e_t_1_1stressed_e_t.xml
%feature("docstring") cmf::upslope::ET::stressedET "

An abstract base class for ET Methods with a WaterStressFunction.

C++ includes: ET.h ";

%feature("docstring")  cmf::upslope::ET::stressedET::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")  cmf::upslope::ET::stressedET::ETpot "virtual
real ETpot(cmf::math::Time t) const ";

%feature("docstring")  cmf::upslope::ET::stressedET::exchange_target "void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")  cmf::upslope::ET::stressedET::get_layer "SoilLayer::ptr get_layer() const ";

%feature("docstring")  cmf::upslope::ET::stressedET::get_ptr "ptr
get_ptr() const ";

%feature("docstring")  cmf::upslope::ET::stressedET::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::ET::stressedET::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")  cmf::upslope::ET::stressedET::get_tracer_filter
"real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")  cmf::upslope::ET::stressedET::get_tracer_filter
"real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::ET::stressedET::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::upslope::ET::stressedET::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::ET::stressedET::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::ET::stressedET::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::upslope::ET::stressedET::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::ET::stressedET::set_stressfunction "void
set_stressfunction(const RootUptakeStessFunction &stressfunction)

Sets the stress function to limit water uptake. ";

%feature("docstring")  cmf::upslope::ET::stressedET::set_tracer_filter
"void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")  cmf::upslope::ET::stressedET::set_tracer_filter
"void set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf::upslope::ET::stressedET::short_string "virtual std::string short_string() const ";

%feature("docstring")  cmf::upslope::ET::stressedET::to_string "std::string to_string() const ";


// File: classcmf__core_1_1stressed_e_t.xml
%feature("docstring") cmf_core::stressedET "

An abstract base class for ET Methods with a WaterStressFunction.  C++
includes: ET.h ";

%feature("docstring")  cmf_core::stressedET::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::stressedET::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::stressedET::__eq__ "def __eq__(self,
args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::stressedET::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::stressedET::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::stressedET::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::stressedET::conc "def conc(self,
args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::stressedET::ETpot "def ETpot(self,
args, kwargs)

ETpot(stressedET self, Time t) -> real  virtual real
ETpot(cmf::math::Time t) const ";

%feature("docstring")  cmf_core::stressedET::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::stressedET::get_layer "def
get_layer(self, args, kwargs)

get_layer(stressedET self) -> cmf::upslope::SoilLayer::ptr
SoilLayer::ptr get_layer() const ";

%feature("docstring")  cmf_core::stressedET::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::stressedET::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::stressedET::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::stressedET::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::stressedET::q "def q(self, args,
kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::stressedET::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::stressedET::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::stressedET::set_stressfunction "def
set_stressfunction(self, args, kwargs)

set_stressfunction(stressedET self, RootUptakeStessFunction
stressfunction)  void set_stressfunction(const RootUptakeStessFunction
&stressfunction)  Sets the stress function to limit water uptake. ";

%feature("docstring")  cmf_core::stressedET::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::stressedET::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::stressedET::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1subcatchment.xml
%feature("docstring") cmf::upslope::subcatchment "

A class to structure cells in a project using their main outlets.

C++ includes: algorithm.h ";

%feature("docstring")  cmf::upslope::subcatchment::subcatchment "subcatchment(cmf::upslope::Cell &pourpoint, double
area_threshold=1e308)

Creates a subcatchment from a pourpoint cell.

Parameters:
-----------

pourpoint:  The pourpoint (outlet of the subcatchment)

area_threshold:  Minimum contributing area size to form a
subcatchment. When area_threshold > area(cells), all upslope cells of
pourpoint are used. ";


// File: classcmf__core_1_1subcatchment.xml
%feature("docstring") cmf_core::subcatchment "

A class to structure cells in a project using their main outlets.  C++
includes: algorithm.h ";

%feature("docstring")  cmf_core::subcatchment::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::subcatchment self, Cell pourpoint, double
area_threshold=1e308) -> subcatchment  subcatchment(cmf::upslope::Cell
&pourpoint, double area_threshold=1e308)  Creates a subcatchment from
a pourpoint cell.  Parameters: -----------  pourpoint:  The pourpoint
(outlet of the subcatchment)  area_threshold:  Minimum contributing
area size to form a subcatchment. When area_threshold > area(cells),
all upslope cells of pourpoint are used. ";


// File: classcmf__core_1_1_suction_stress.xml
%feature("docstring") cmf_core::SuctionStress "

The classical suction depending transpiration Stress curve after
Feddes.  The ability of roots to take water from the soil up is
limited by the suction pressure (matrix potential) of the soil. The
stress is defined using a trapezoid function, with P0 being the
pressure, where water uptake is prohibited by saturation. Between P0
and P1 the saturation stress gets lower. Between P1 and P2, no stress
occurs ( ET=ETpot) and with a pressure below P2, water uptake is
limited by drought. P3 indicates the highest suction (lowest pressure)
to which plants can extract water (wilting point).  Default values:
:math:`P_0 = \\\\\\\\infty, P_1=\\\\\\\\infty, P_2=-5m, P_3=-160m`,
resulting in no saturation stress and draught stress starting at -5m
and a wilting point of -160m.  If one would like to include saturation
stress, typical values for P0 and P1 are 0.0m and 0.1m. By changing P2
and P3, you can account for different drought sensibility for
different plant types.  C++ includes: waterstress.h ";

%feature("docstring")  cmf_core::SuctionStress::__init__ "def
__init__(self, args)

__init__(cmf::upslope::ET::SuctionStress self, real P0=1e308, real
P1=1e307, real P2=-5, real P3=-160) -> SuctionStress
__init__(cmf::upslope::ET::SuctionStress self, SuctionStress other) ->
SuctionStress  SuctionStress(const SuctionStress &other) ";

%feature("docstring")  cmf_core::SuctionStress::copy "def copy(self,
args, kwargs)

copy(SuctionStress self) -> SuctionStress
cmf::upslope::ET::SuctionStress* copy() const  Creates a new copy of
this wetness. ";

%feature("docstring")  cmf_core::SuctionStress::Tact "def Tact(self,
args, kwargs)

Tact(RootUptakeStessFunction self, stressedET connection, real Tpot)
-> real  virtual real Tact(const stressedET *connection, real Tpot)
const =0  Calculates the water stress for a layer.  Parameters:
-----------  connection:  The stressedET connection this stress
function belongs to  Tpot:  Potential Transpiration in mm/day (for the
full profile)  Actual flux from layer in m3/day ";

%feature("docstring")  cmf_core::SuctionStress::to_string "def
to_string(self, args, kwargs)

to_string(RootUptakeStessFunction self) -> std::string  virtual
std::string to_string() const =0 ";


// File: classcmf_1_1upslope_1_1_e_t_1_1_suction_stress.xml
%feature("docstring") cmf::upslope::ET::SuctionStress "

The classical suction depending transpiration Stress curve after
Feddes.

The ability of roots to take water from the soil up is limited by the
suction pressure (matrix potential) of the soil. The stress is defined
using a trapezoid function, with P0 being the pressure, where water
uptake is prohibited by saturation. Between P0 and P1 the saturation
stress gets lower. Between P1 and P2, no stress occurs ( ET=ETpot) and
with a pressure below P2, water uptake is limited by drought. P3
indicates the highest suction (lowest pressure) to which plants can
extract water (wilting point).

Default values: :math:`P_0 = \\\\infty, P_1=\\\\infty, P_2=-5m, P_3=-160m`,
resulting in no saturation stress and draught stress starting at -5m
and a wilting point of -160m.

If one would like to include saturation stress, typical values for P0
and P1 are 0.0m and 0.1m. By changing P2 and P3, you can account for
different drought sensibility for different plant types.

C++ includes: waterstress.h ";

%feature("docstring")  cmf::upslope::ET::SuctionStress::SuctionStress
"SuctionStress(real P0=1e308, real P1=1e307, real P2=-5, real
P3=-160)

Creates a new suction stress function. ";

%feature("docstring")  cmf::upslope::ET::SuctionStress::SuctionStress
"SuctionStress(const SuctionStress &other) ";

%feature("docstring")  cmf::upslope::ET::SuctionStress::~SuctionStress
"virtual ~SuctionStress() ";

%feature("docstring")  cmf::upslope::ET::SuctionStress::copy "cmf::upslope::ET::SuctionStress* copy() const

Creates a new copy of this wetness. ";

%feature("docstring")  cmf::upslope::ET::SuctionStress::Tact "real
Tact(const stressedET *connection, real Tpot) const

Calculates the water stress for a layer.

Parameters:
-----------

connection:  The stressedET connection this stress function belongs to

Tpot:  Potential Transpiration in mm/day (for the full profile)

Actual flux from layer in m3/day ";

%feature("docstring")  cmf::upslope::ET::SuctionStress::to_string "std::string to_string() const ";


// File: classcmf_1_1upslope_1_1_surface_water.xml
%feature("docstring") cmf::upslope::SurfaceWater "

A child class of OpenWaterStorage to model surface water on a cell.

Specially created to connect a SurfaceWater with other nodes, is the
flux connection cmf::upslope::connections::KinematicSurfaceRunoff

C++ includes: surfacewater.h ";

/*  Overrides of flux_node  */

%feature("docstring")  cmf::upslope::SurfaceWater::RecalcFluxes "virtual bool RecalcFluxes(cmf::math::Time t)

Pure flux_nodes do not influence fluxes, therefore no recalculation of
fluxes is required by flux_node.

WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf::upslope::SurfaceWater::is_empty "virtual
double is_empty() const

Returns true if the node has no water. ";

%feature("docstring")  cmf::upslope::SurfaceWater::to_string "virtual
std::string to_string() const ";

%feature("docstring")
cmf::upslope::SurfaceWater::add_connected_states "virtual void
add_connected_states(cmf::math::StateVariable::list &states) ";

%feature("docstring")  cmf::upslope::SurfaceWater::conc "real
conc(cmf::math::Time t, const cmf::water::solute &solute) const

Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf::upslope::SurfaceWater::conc "real
conc(const cmf::water::solute &_Solute) const

Returns the concentration of the given solute. ";

%feature("docstring")  cmf::upslope::SurfaceWater::conc "void
conc(const cmf::water::solute &_Solute, real NewConcetration)

Sets a new concentration. ";

%feature("docstring")  cmf::upslope::SurfaceWater::connection_to "cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::upslope::SurfaceWater::dxdt "virtual real
dxdt(const cmf::math::Time &time) ";

%feature("docstring")  cmf::upslope::SurfaceWater::flux3d_to "cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf::upslope::SurfaceWater::flux_to "real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf::upslope::SurfaceWater::get_3d_flux "cmf::geometry::point get_3d_flux(cmf::math::Time t)

Returns the sum of all flux vectors. ";

%feature("docstring")  cmf::upslope::SurfaceWater::get_abs_errtol "real get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf::upslope::SurfaceWater::get_cell "Cell&
get_cell() const

Get the cell of the surface. ";

%feature("docstring")  cmf::upslope::SurfaceWater::get_connections "cmf::water::connection_list get_connections() const ";

%feature("docstring")  cmf::upslope::SurfaceWater::get_coverage "double get_coverage() const

Get surface coverage as a function of the actual volume. ";

%feature("docstring")  cmf::upslope::SurfaceWater::get_depth "real
get_depth() const

Returns the water table depth. ";

%feature("docstring")  cmf::upslope::SurfaceWater::get_height_function
"virtual const cmf::river::Prism& get_height_function() const

Gets the height function (a cmf::river::Prism) for further reference.
";

%feature("docstring")  cmf::upslope::SurfaceWater::get_nManning "real
get_nManning() const

get Manning roughness (n) of the surface

From Python use this as a property: ";

%feature("docstring")  cmf::upslope::SurfaceWater::get_potential "virtual real get_potential() const

Returns the water potential of the node in m waterhead.

The base class water storage always returns the height of the location
";

%feature("docstring")  cmf::upslope::SurfaceWater::get_project "cmf::project& get_project() const

Returns the project, this node is part of. ";

%feature("docstring")  cmf::upslope::SurfaceWater::get_puddledepth "real get_puddledepth() const

Get water depth at which runoff starts.

From Python use this as a property: ";

%feature("docstring")  cmf::upslope::SurfaceWater::get_state "real
get_state() const ";

%feature("docstring")
cmf::upslope::SurfaceWater::get_state_variable_content "char
get_state_variable_content() const

A character indicating the integrated variable (either 'V' for Volume
or 'h' for head) ";

%feature("docstring")  cmf::upslope::SurfaceWater::get_states "cmf::math::StateVariableList get_states()

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf::upslope::SurfaceWater::get_volume "virtual real get_volume() const

Returns the volume of water in this storage in m3 ";

%feature("docstring")  cmf::upslope::SurfaceWater::is_connected "virtual bool is_connected(const cmf::math::StateVariable &other) const

Returns True if this waterstorage is effected by another state. ";

%feature("docstring")  cmf::upslope::SurfaceWater::is_storage "virtual bool is_storage() const

Returns true, since this is a storage. ";

%feature("docstring")  cmf::upslope::SurfaceWater::remove_connection "bool remove_connection(cmf::water::flux_node::ptr To)

Remove the connection. ";

%feature("docstring")  cmf::upslope::SurfaceWater::set_depth "void
set_depth(real new_depth) ";

%feature("docstring")  cmf::upslope::SurfaceWater::set_height_function
"virtual void set_height_function(const
cmf::river::IVolumeHeightFunction &val)

Prevents the change of the height function. A SurfaceWater storage has
always a Prism height function. ";

%feature("docstring")  cmf::upslope::SurfaceWater::set_nManning "void
set_nManning(real n)

set Manning roughness (n) of the surface

From Python use this as a property: ";

%feature("docstring")  cmf::upslope::SurfaceWater::set_potential "virtual void set_potential(real newpotential)

Sets the potential of this flux node. ";

%feature("docstring")  cmf::upslope::SurfaceWater::set_puddledepth "void set_puddledepth(real puddledepth)

Set water depth at which runoff starts.

From Python use this as a property: ";

%feature("docstring")  cmf::upslope::SurfaceWater::set_state "void
set_state(real newState) ";

%feature("docstring")
cmf::upslope::SurfaceWater::set_state_variable_content "void
set_state_variable_content(char content)

A character indicating the integrated variable (either 'V' for Volume
or 'h' for head) ";

%feature("docstring")  cmf::upslope::SurfaceWater::set_volume "virtual void set_volume(real newwatercontent)

Sets the volume of water in this storage in m3 ";

%feature("docstring")  cmf::upslope::SurfaceWater::Solute "SoluteStorage& Solute(const cmf::water::solute _Solute)

Returns the water quality of the water storage. ";

%feature("docstring")  cmf::upslope::SurfaceWater::Solute "const
SoluteStorage& Solute(const cmf::water::solute _Solute) const ";

%feature("docstring")  cmf::upslope::SurfaceWater::waterbalance "real
waterbalance(cmf::math::Time t, const flux_connection *Without=0)
const

Returns the sum of all fluxes (positive and negative) at time t.

Single fluxes can be excluded from the calculation

Parameters:
-----------

t:  Time of the query

Without:  A flux_connection that is excluded from the waterbalance
(e.g. to prevent closed circuits) ";

%feature("docstring")  cmf::upslope::SurfaceWater::wet_area "real
wet_area() const

Returns the exposed surface area in m2. ";


// File: classcmf__core_1_1_surface_water.xml
%feature("docstring") cmf_core::SurfaceWater "

A child class of OpenWaterStorage to model surface water on a cell.
Specially created to connect a SurfaceWater with other nodes, is the
flux connection cmf::upslope::connections::KinematicSurfaceRunoff  C++
includes: surfacewater.h ";

%feature("docstring")  cmf_core::SurfaceWater::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::SurfaceWater::__call__ "def
__call__(self, args, kwargs)

__call__(flux_node self, Time t) -> real ";

%feature("docstring")  cmf_core::SurfaceWater::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_node self, flux_node other) -> bool ";

%feature("docstring")  cmf_core::SurfaceWater::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(WaterStorage self, solute X) -> SoluteStorage ";

%feature("docstring")  cmf_core::SurfaceWater::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::SurfaceWater::cast "def cast(args,
kwargs)

cast(cmf::water::flux_node::ptr node) ->
cmf::upslope::SurfaceWater::ptr ";

%feature("docstring")  cmf_core::SurfaceWater::conc "def conc(self,
args, kwargs)

conc(flux_node self, Time t, solute Solute) -> real  virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const
Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf_core::SurfaceWater::conc "def conc(self,
args)

conc(WaterStorage self, solute _Solute) -> real conc(WaterStorage
self, Time t, solute _Solute) -> real conc(WaterStorage self, solute
_Solute, real NewConcetration)  void conc(const cmf::water::solute
&_Solute, real NewConcetration)  Sets a new concentration. ";

%feature("docstring")  cmf_core::SurfaceWater::connected_nodes "def
connected_nodes(self) ";

%feature("docstring")  cmf_core::SurfaceWater::connection_to "def
connection_to(self, args, kwargs)

connection_to(flux_node self, flux_node target) -> flux_connection
cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)  Returns the connection between this and target. ";

%feature("docstring")  cmf_core::SurfaceWater::create "def
create(args, kwargs)

create(project _project, real initial_state=0.0, real scale=1.0) ->
std::shared_ptr< cmf::water::WaterStorage > ";

%feature("docstring")  cmf_core::SurfaceWater::create "def
create(args)

create(project _project, real Area) ->
cmf::river::OpenWaterStorage::ptr create(project _project,
IVolumeHeightFunction base_geo) -> cmf::river::OpenWaterStorage::ptr
";

%feature("docstring")  cmf_core::SurfaceWater::dxdt "def dxdt(self,
args, kwargs)

dxdt(StateVariable self, Time time) -> real  virtual real dxdt(const
cmf::math::Time &time)=0  Returns the derivate of the state variable
at time time. ";

%feature("docstring")  cmf_core::SurfaceWater::flux3d_to "def
flux3d_to(self, args, kwargs)

flux3d_to(flux_node self, flux_node target, Time t) -> point
cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf_core::SurfaceWater::flux_to "def
flux_to(self, args, kwargs)

flux_to(flux_node self, flux_node target, Time t) -> real  real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)
Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf_core::SurfaceWater::fluxes "def
fluxes(self, t) ";

%feature("docstring")  cmf_core::SurfaceWater::from_node "def
from_node(args, kwargs)

from_node(cmf::water::flux_node::ptr node) -> std::shared_ptr<
cmf::water::WaterStorage > ";

%feature("docstring")  cmf_core::SurfaceWater::get_3d_flux "def
get_3d_flux(self, args, kwargs)

get_3d_flux(flux_node self, Time t) -> point  cmf::geometry::point
get_3d_flux(cmf::math::Time t)  Returns the sum of all flux vectors.
";

%feature("docstring")  cmf_core::SurfaceWater::get_abs_errtol "def
get_abs_errtol(self, args, kwargs)

get_abs_errtol(StateVariable self, real rel_errtol) -> real  virtual
real get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf_core::SurfaceWater::get_cell "def
get_cell(self, args, kwargs)

get_cell(SurfaceWater self) -> Cell  Cell& get_cell() const  Get the
cell of the surface. ";

%feature("docstring")  cmf_core::SurfaceWater::get_coverage "def
get_coverage(self, args, kwargs)

get_coverage(SurfaceWater self) -> double  double get_coverage() const
Get surface coverage as a function of the actual volume. ";

%feature("docstring")  cmf_core::SurfaceWater::get_height_function "def get_height_function(self, args, kwargs)

get_height_function(SurfaceWater self) -> Prism  virtual const
cmf::river::Prism& get_height_function() const  Gets the height
function (a cmf::river::Prism) for further reference. ";

%feature("docstring")  cmf_core::SurfaceWater::get_states "def
get_states(self, args, kwargs)

get_states(StateVariableOwner self) -> StateVariableList  virtual
StateVariableList get_states()=0  Add the state variables, owned by an
object derived from StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf_core::SurfaceWater::is_connected "def
is_connected(self, args, kwargs)

is_connected(StateVariable self, StateVariable other) -> bool  virtual
bool is_connected(const cmf::math::StateVariable &other) const ";

%feature("docstring")  cmf_core::SurfaceWater::is_empty "def
is_empty(self, args, kwargs)

is_empty(flux_node self) -> double  virtual double is_empty() const
Returns true if the node has no water. ";

%feature("docstring")  cmf_core::SurfaceWater::is_storage "def
is_storage(self, args, kwargs)

is_storage(flux_node self) -> bool  virtual bool is_storage() const
true, if this is a waterstorage ";

%feature("docstring")  cmf_core::SurfaceWater::RecalcFluxes "def
RecalcFluxes(self, args, kwargs)

RecalcFluxes(flux_node self, Time t) -> bool  virtual bool
RecalcFluxes(cmf::math::Time t)  Pure flux_nodes do not influence
fluxes, therefore no recalculation of fluxes is required by flux_node.
WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf_core::SurfaceWater::remove_connection "def
remove_connection(self, args, kwargs)

remove_connection(flux_node self, cmf::water::flux_node::ptr To) ->
bool  bool remove_connection(cmf::water::flux_node::ptr To)  Remove
the connection. ";

%feature("docstring")  cmf_core::SurfaceWater::set_height_function "def set_height_function(self, args, kwargs)

set_height_function(OpenWaterStorage self, IVolumeHeightFunction val)
virtual void set_height_function(const IVolumeHeightFunction &val) ";

%feature("docstring")  cmf_core::SurfaceWater::Solute "def
Solute(self, args)

Solute(WaterStorage self, solute _Solute) -> SoluteStorage
Solute(WaterStorage self, solute _Solute) -> SoluteStorage  const
SoluteStorage& Solute(const cmf::water::solute _Solute) const ";

%feature("docstring")  cmf_core::SurfaceWater::to_string "def
to_string(self, args, kwargs)

to_string(StateVariable self) -> std::string  virtual std::string
to_string() const =0 ";

%feature("docstring")  cmf_core::SurfaceWater::to_string "def
to_string(self, args, kwargs)

to_string(flux_node self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::SurfaceWater::waterbalance "def
waterbalance(self, args, kwargs)

waterbalance(flux_node self, Time t, flux_connection Without=None) ->
real  real waterbalance(cmf::math::Time t, const flux_connection
*Without=0) const  Returns the sum of all fluxes (positive and
negative) at time t.  Single fluxes can be excluded from the
calculation  Parameters: -----------  t:  Time of the query  Without:
A flux_connection that is excluded from the waterbalance (e.g. to
prevent closed circuits) ";

%feature("docstring")  cmf_core::SurfaceWater::wet_area "def
wet_area(self, args, kwargs)

wet_area(OpenWaterStorage self) -> real  real wet_area() const Returns
the exposed surface area in m2. ";


// File: classcmf__core_1_1_s_w__evap__from__canopy.xml
%feature("docstring") cmf_core::SW_evap_from_canopy "

Connection for Shuttleworth-Wallace canopy interception evaporation.
C++ includes: ShuttleworthWallace.h ";

%feature("docstring")  cmf_core::SW_evap_from_canopy::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::ET::SW_evap_from_canopy self,
cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr
ET_target, cmf::upslope::ET::ShuttleworthWallace::ptr owner) ->
SW_evap_from_canopy  SW_evap_from_canopy(cmf::water::WaterStorage::ptr
source, cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr
owner) ";

%feature("docstring")  cmf_core::SW_evap_from_canopy::__contains__ "def __contains__(self, cmp) ";

%feature("docstring")  cmf_core::SW_evap_from_canopy::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::SW_evap_from_canopy::__getitem__ "def __getitem__(self, index) ";

%feature("docstring")  cmf_core::SW_evap_from_canopy::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::SW_evap_from_canopy::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::SW_evap_from_canopy::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::SW_evap_from_canopy::exchange_target
"def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::SW_evap_from_canopy::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::SW_evap_from_canopy::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::SW_evap_from_canopy::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::SW_evap_from_canopy::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::SW_evap_from_canopy::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::SW_evap_from_canopy::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::SW_evap_from_canopy::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::SW_evap_from_canopy::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::SW_evap_from_canopy::short_string "def short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::SW_evap_from_canopy::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1_e_t_1_1_s_w__evap__from__canopy.xml
%feature("docstring") cmf::upslope::ET::SW_evap_from_canopy "

Connection for Shuttleworth-Wallace canopy interception evaporation.

C++ includes: ShuttleworthWallace.h ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_canopy::SW_evap_from_canopy "SW_evap_from_canopy(cmf::water::WaterStorage::ptr source,
cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr owner)
";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_canopy::conc "real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_canopy::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_canopy::get_ptr
"ptr get_ptr() const ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_canopy::get_target "flux_node::ptr
get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_canopy::get_target "flux_node::ptr
get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_canopy::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_canopy::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_canopy::kill_me
"bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_canopy::left_node "flux_node::ptr
left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_canopy::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_canopy::refresh
"void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_canopy::right_node "flux_node::ptr
right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_canopy::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_canopy::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_canopy::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_canopy::to_string "virtual std::string
to_string() const ";


// File: classcmf__core_1_1_s_w__evap__from__layer.xml
%feature("docstring") cmf_core::SW_evap_from_layer "

Connection for Shuttleworth-Wallace ground evaporation.  C++ includes:
ShuttleworthWallace.h ";

%feature("docstring")  cmf_core::SW_evap_from_layer::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::ET::SW_evap_from_layer self,
cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr
ET_target, cmf::upslope::ET::ShuttleworthWallace::ptr owner) ->
SW_evap_from_layer  SW_evap_from_layer(cmf::upslope::SoilLayer::ptr
source, cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr
owner) ";

%feature("docstring")  cmf_core::SW_evap_from_layer::__contains__ "def __contains__(self, cmp) ";

%feature("docstring")  cmf_core::SW_evap_from_layer::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::SW_evap_from_layer::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::SW_evap_from_layer::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::SW_evap_from_layer::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::SW_evap_from_layer::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::SW_evap_from_layer::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::SW_evap_from_layer::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::SW_evap_from_layer::get_tracer_filter
"def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::SW_evap_from_layer::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::SW_evap_from_layer::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::SW_evap_from_layer::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::SW_evap_from_layer::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::SW_evap_from_layer::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::SW_evap_from_layer::set_tracer_filter
"def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::SW_evap_from_layer::short_string "def short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::SW_evap_from_layer::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1_e_t_1_1_s_w__evap__from__layer.xml
%feature("docstring") cmf::upslope::ET::SW_evap_from_layer "

Connection for Shuttleworth-Wallace ground evaporation.

C++ includes: ShuttleworthWallace.h ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_layer::SW_evap_from_layer "SW_evap_from_layer(cmf::upslope::SoilLayer::ptr source,
cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr owner)
";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_layer::conc "real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_layer::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_layer::get_ptr "ptr get_ptr() const ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_layer::get_target "flux_node::ptr
get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_layer::get_target "flux_node::ptr
get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_layer::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_layer::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_layer::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_layer::left_node
"flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_layer::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_layer::refresh "void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_layer::right_node "flux_node::ptr
right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_layer::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_layer::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_layer::short_string "virtual
std::string short_string() const ";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_layer::to_string
"virtual std::string to_string() const ";


// File: classcmf__core_1_1_s_w__evap__from__snow.xml
%feature("docstring") cmf_core::SW_evap_from_snow "

Connection for Shuttleworth-Wallace canopy interception evaporation.
C++ includes: ShuttleworthWallace.h ";

%feature("docstring")  cmf_core::SW_evap_from_snow::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::ET::SW_evap_from_snow self,
cmf::water::WaterStorage::ptr source, cmf::water::flux_node::ptr
ET_target, cmf::upslope::ET::ShuttleworthWallace::ptr owner) ->
SW_evap_from_snow  SW_evap_from_snow(cmf::water::WaterStorage::ptr
source, cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr
owner) ";

%feature("docstring")  cmf_core::SW_evap_from_snow::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::SW_evap_from_snow::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::SW_evap_from_snow::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::SW_evap_from_snow::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::SW_evap_from_snow::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::SW_evap_from_snow::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::SW_evap_from_snow::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::SW_evap_from_snow::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::SW_evap_from_snow::get_tracer_filter
"def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::SW_evap_from_snow::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::SW_evap_from_snow::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::SW_evap_from_snow::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::SW_evap_from_snow::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::SW_evap_from_snow::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::SW_evap_from_snow::set_tracer_filter
"def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::SW_evap_from_snow::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::SW_evap_from_snow::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1_e_t_1_1_s_w__evap__from__snow.xml
%feature("docstring") cmf::upslope::ET::SW_evap_from_snow "

Connection for Shuttleworth-Wallace canopy interception evaporation.

C++ includes: ShuttleworthWallace.h ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_snow::SW_evap_from_snow "SW_evap_from_snow(cmf::water::WaterStorage::ptr source,
cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr owner)
";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_snow::conc "real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_snow::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_snow::get_ptr "ptr get_ptr() const ";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_snow::get_target
"flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_snow::get_target
"flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_snow::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_snow::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_snow::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_snow::left_node
"flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_snow::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_snow::refresh "void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_snow::right_node
"flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_snow::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_snow::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_snow::short_string "virtual
std::string short_string() const ";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_snow::to_string
"virtual std::string to_string() const ";


// File: classcmf_1_1upslope_1_1_e_t_1_1_s_w__evap__from__surfacewater.xml
%feature("docstring") cmf::upslope::ET::SW_evap_from_surfacewater "

Connection for Shuttleworth-Wallace canopy interception evaporation.

C++ includes: ShuttleworthWallace.h ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_surfacewater::SW_evap_from_surfacewater
"SW_evap_from_surfacewater(cmf::river::OpenWaterStorage::ptr source,
cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr owner)
";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_surfacewater::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_surfacewater::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_surfacewater::get_ptr "ptr get_ptr()
const ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_surfacewater::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_surfacewater::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_surfacewater::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_surfacewater::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_surfacewater::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_surfacewater::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::ET::SW_evap_from_surfacewater::q
"real q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_surfacewater::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_surfacewater::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_surfacewater::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_surfacewater::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_surfacewater::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::upslope::ET::SW_evap_from_surfacewater::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_s_w__evap__from__surfacewater.xml
%feature("docstring") cmf_core::SW_evap_from_surfacewater "

Connection for Shuttleworth-Wallace canopy interception evaporation.
C++ includes: ShuttleworthWallace.h ";

%feature("docstring")  cmf_core::SW_evap_from_surfacewater::__init__ "def __init__(self, args, kwargs)

__init__(cmf::upslope::ET::SW_evap_from_surfacewater self,
cmf::river::OpenWaterStorage::ptr source, cmf::water::flux_node::ptr
ET_target, cmf::upslope::ET::ShuttleworthWallace::ptr owner) ->
SW_evap_from_surfacewater
SW_evap_from_surfacewater(cmf::river::OpenWaterStorage::ptr source,
cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr owner)
";

%feature("docstring")
cmf_core::SW_evap_from_surfacewater::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::SW_evap_from_surfacewater::__eq__ "def __eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")
cmf_core::SW_evap_from_surfacewater::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::SW_evap_from_surfacewater::__iter__ "def __iter__(self) ";

%feature("docstring")  cmf_core::SW_evap_from_surfacewater::__repr__ "def __repr__(self) ";

%feature("docstring")  cmf_core::SW_evap_from_surfacewater::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::SW_evap_from_surfacewater::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::SW_evap_from_surfacewater::get_target
"def get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::SW_evap_from_surfacewater::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::SW_evap_from_surfacewater::kill_me "def kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::SW_evap_from_surfacewater::left_node
"def left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::SW_evap_from_surfacewater::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::SW_evap_from_surfacewater::refresh "def refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::SW_evap_from_surfacewater::right_node
"def right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::SW_evap_from_surfacewater::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf_core::SW_evap_from_surfacewater::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::SW_evap_from_surfacewater::to_string
"def to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf__core_1_1_s_w__transpiration.xml
%feature("docstring") cmf_core::SW_transpiration "

Connection for Shuttleworth-Wallace transpiration.  C++ includes:
ShuttleworthWallace.h ";

%feature("docstring")  cmf_core::SW_transpiration::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::ET::SW_transpiration self,
cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr
ET_target, cmf::upslope::ET::ShuttleworthWallace::ptr owner) ->
SW_transpiration  SW_transpiration(cmf::upslope::SoilLayer::ptr
source, cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr
owner) ";

%feature("docstring")  cmf_core::SW_transpiration::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::SW_transpiration::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::SW_transpiration::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::SW_transpiration::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::SW_transpiration::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::SW_transpiration::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::SW_transpiration::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::SW_transpiration::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::SW_transpiration::get_tracer_filter "def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::SW_transpiration::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::SW_transpiration::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::SW_transpiration::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::SW_transpiration::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::SW_transpiration::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::SW_transpiration::set_tracer_filter "def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::SW_transpiration::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::SW_transpiration::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1_e_t_1_1_s_w__transpiration.xml
%feature("docstring") cmf::upslope::ET::SW_transpiration "

Connection for Shuttleworth-Wallace transpiration.

C++ includes: ShuttleworthWallace.h ";

%feature("docstring")
cmf::upslope::ET::SW_transpiration::SW_transpiration "SW_transpiration(cmf::upslope::SoilLayer::ptr source,
cmf::water::flux_node::ptr ET_target, ShuttleworthWallace::ptr owner)
";

%feature("docstring")  cmf::upslope::ET::SW_transpiration::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::ET::SW_transpiration::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::upslope::ET::SW_transpiration::get_ptr "ptr get_ptr() const ";

%feature("docstring")  cmf::upslope::ET::SW_transpiration::get_target
"flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::ET::SW_transpiration::get_target
"flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::ET::SW_transpiration::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::SW_transpiration::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::ET::SW_transpiration::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::upslope::ET::SW_transpiration::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::ET::SW_transpiration::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::ET::SW_transpiration::refresh "void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::upslope::ET::SW_transpiration::right_node
"flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::ET::SW_transpiration::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::SW_transpiration::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::ET::SW_transpiration::short_string "virtual std::string
short_string() const ";

%feature("docstring")  cmf::upslope::ET::SW_transpiration::to_string "virtual std::string to_string() const ";


// File: classcmf__core_1_1_s_w_a_t_percolation.xml
%feature("docstring") cmf_core::SWATPercolation "

A tipping bucket percolation approach similar to the approach in SWAT.
.. math::       q_{perc} &=&
V_{H_2O,drain}\\\\\\\\left(1-e^{-\\\\\\\\frac
1{-TT_{perc}}}\\\\\\\\right)     \\\\\\\\\\\\\\\\ TT_{perc} &=&
\\\\\\\\frac{V_{pores,drain} - V_{field     cap.}}{K_{sat}}
\\\\\\\\\\\\\\\\ V_{x,drain} &=& V_{x,drain} - V_{field cap.}     C++
includes: Percolation.h ";

%feature("docstring")  cmf_core::SWATPercolation::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::SWATPercolation self,
cmf::upslope::SoilLayer::ptr upperLayer, cmf::upslope::SoilLayer::ptr
lowerLayer) -> SWATPercolation
SWATPercolation(cmf::upslope::SoilLayer::ptr upperLayer,
cmf::upslope::SoilLayer::ptr lowerLayer) ";

%feature("docstring")  cmf_core::SWATPercolation::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::SWATPercolation::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::SWATPercolation::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::SWATPercolation::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::SWATPercolation::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::SWATPercolation::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::SWATPercolation::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::SWATPercolation::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::SWATPercolation::get_tracer_filter "def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::SWATPercolation::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::SWATPercolation::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::SWATPercolation::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::SWATPercolation::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::SWATPercolation::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::SWATPercolation::set_tracer_filter "def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::SWATPercolation::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::SWATPercolation::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::SWATPercolation::use_for_cell "def
use_for_cell(args, kwargs)

use_for_cell(Cell cell, bool no_override=True) ";


// File: classcmf_1_1upslope_1_1connections_1_1_s_w_a_t_percolation.xml
%feature("docstring") cmf::upslope::connections::SWATPercolation "

A tipping bucket percolation approach similar to the approach in SWAT.



.. math::

     q_{perc} &=&
    V_{H_2O,drain}\\\\left(1-e^{-\\\\frac 1{-TT_{perc}}}\\\\right)
    \\\\\\\\ TT_{perc} &=& \\\\frac{V_{pores,drain} - V_{field
    cap.}}{K_{sat}} \\\\\\\\ V_{x,drain} &=& V_{x,drain} - V_{field cap.}
    



C++ includes: Percolation.h ";

%feature("docstring")
cmf::upslope::connections::SWATPercolation::SWATPercolation "SWATPercolation(cmf::upslope::SoilLayer::ptr upperLayer,
cmf::upslope::SoilLayer::ptr lowerLayer) ";

%feature("docstring")
cmf::upslope::connections::SWATPercolation::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::SWATPercolation::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::upslope::connections::SWATPercolation::get_ptr "ptr get_ptr()
const ";

%feature("docstring")
cmf::upslope::connections::SWATPercolation::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::SWATPercolation::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::SWATPercolation::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::SWATPercolation::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::SWATPercolation::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::SWATPercolation::left_node "flux_node::ptr
left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::connections::SWATPercolation::q "real q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::SWATPercolation::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::SWATPercolation::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::SWATPercolation::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::SWATPercolation::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::SWATPercolation::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::SWATPercolation::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_s_w_a_t_reach_type.xml
%feature("docstring") cmf_core::SWATReachType "

Structure for the description of structural parameters of a reach.
Uses the SWAT IChannel geometry (see SWAT Theoretical Documentation,
Version 2005 (ch. 7:1.1), Neitsch et al. 2005), in this class
referenced as SWATtheoDoc. Differences to the SWAT geometry: The flood
plain is not plain, but has a small slope=0.5%, but has an infinite
width  C++ includes: ReachType.h ";

%feature("docstring")  cmf_core::SWATReachType::__init__ "def
__init__(self, args)

__init__(cmf::river::SWATReachType self, SWATReachType copy) ->
SWATReachType __init__(cmf::river::SWATReachType self, double l) ->
SWATReachType __init__(cmf::river::SWATReachType self, double l,
double BankWidth, double Depth) -> SWATReachType  SWATReachType(double
l, double BankWidth, double Depth)  Creates a new reach structure from
a give width and depth.  Parameters: -----------  l:  length of the
channel [m]  BankWidth:  get_channel_width of the reach from bank to
bank [m]  Depth:  Depth of the reach [m] ";

%feature("docstring")  cmf_core::SWATReachType::A "def A(self, args,
kwargs)

A(IVolumeHeightFunction self, double V) -> double  virtual double
A(double V) const =0  Returns the area of the surface for a given
volume. ";

%feature("docstring")  cmf_core::SWATReachType::copy "def copy(self,
args, kwargs)

copy(SWATReachType self) -> SWATReachType  SWATReachType* copy() const
";

%feature("docstring")  cmf_core::SWATReachType::get_channel_width "def get_channel_width(self, args, kwargs)

get_channel_width(IChannel self, double depth) -> double  virtual
double get_channel_width(double depth) const =0  Calculates the flow
width from a given actual depth [m] using the actual IChannel
geometry. ";

%feature("docstring")  cmf_core::SWATReachType::get_depth "def
get_depth(self, args, kwargs)

get_depth(IChannel self, double area) -> double  virtual double
get_depth(double area) const =0  Calculates the actual depth of the
reach using the IChannel geometry.  get_depth of the reach [m]
Parameters: -----------  area:  Wetted area of a river cross section
[m2], can be obtained by V/l, where V is the stored volume and l is
the reach length ";

%feature("docstring")  cmf_core::SWATReachType::get_flux_crossection "def get_flux_crossection(self, args, kwargs)

get_flux_crossection(IChannel self, double depth) -> double  virtual
double get_flux_crossection(double depth) const =0  Calculates the
wetted area from a given depth using the IChannel geometry.  In most
cases use get_flux_crossection=V/l, where V is the stored volume and l
is the reach length Wetted area of a river cross section [m2]
Parameters: -----------  depth:  depth of the reach [m] ";

%feature("docstring")  cmf_core::SWATReachType::get_length "def
get_length(self, args, kwargs)

get_length(IChannel self) -> double  virtual double get_length() const
=0  Length of the reach. ";

%feature("docstring")  cmf_core::SWATReachType::get_nManning "def
get_nManning(self, args, kwargs)

get_nManning(IChannel self) -> double  virtual double get_nManning()
const =0 ";

%feature("docstring")  cmf_core::SWATReachType::get_wetted_perimeter "def get_wetted_perimeter(self, args, kwargs)

get_wetted_perimeter(IChannel self, double depth) -> double  virtual
double get_wetted_perimeter(double depth) const =0  Calculates the
wetted perimeter from a given actual depth [m] using the actual
IChannel geometry. ";

%feature("docstring")  cmf_core::SWATReachType::h "def h(self, args,
kwargs)

h(IVolumeHeightFunction self, double V) -> double  virtual double
h(double V) const =0  Returns the depth of a given volume. ";

%feature("docstring")  cmf_core::SWATReachType::q "def q(self, args,
kwargs)

q(IVolumeHeightFunction self, double h, double slope) -> double
virtual double q(double h, double slope) const ";

%feature("docstring")  cmf_core::SWATReachType::qManning "def
qManning(self, args, kwargs)

qManning(IChannel self, double A, double slope) -> double  virtual
double qManning(double A, double slope) const  Calculates the flow
rate from a given water volume in the reach   .. math:: q_{Manning}&=&
A R^{\\\\\\\\frac 2 3}     \\\\\\\\sqrt{\\\\\\\\frac {\\\\\\\\Delta_z}
n} \\\\\\\\\\\\\\\\ A &=& \\\\\\\\frac V l \\\\\\\\mbox{,
(Crosssectional area of the wetted crossection, Volume per
length)} \\\\\\\\\\\\\\\\ R &=& \\\\\\\\frac A {P(d)} \\\\\\\\\\\\\\\\
P(d) &=& \\\\\\\\mbox{     the perimeter of the wetted crosssection, a
function of reach depth}     \\\\\\\\\\\\\\\\ d(V) &=& \\\\\\\\mbox{
the depth of the reach a function of the volume} \\\\\\\\\\\\\\\\
\\\\\\\\Delta_z &=& \\\\\\\\frac{z_{max} - z_{min}}{l}
\\\\\\\\mbox{ Slope of the reach}   .  Flow rate [m3/s]  Parameters:
-----------  A:  The area of the cross section [m2]  slope:  The slope
of the reach [m/m] ";

%feature("docstring")  cmf_core::SWATReachType::set_nManning "def
set_nManning(self, args, kwargs)

set_nManning(IChannel self, double val)  virtual void
set_nManning(double val)=0 ";

%feature("docstring")  cmf_core::SWATReachType::typecode "def
typecode(self, args, kwargs)

typecode(IChannel self) -> char  virtual char typecode() const =0 ";

%feature("docstring")  cmf_core::SWATReachType::V "def V(self, args,
kwargs)

V(IVolumeHeightFunction self, double h) -> double  virtual double
V(double h) const =0 ";


// File: classcmf_1_1river_1_1_s_w_a_t_reach_type.xml
%feature("docstring") cmf::river::SWATReachType "

Structure for the description of structural parameters of a reach.

Uses the SWAT IChannel geometry (see SWAT Theoretical Documentation,
Version 2005 (ch. 7:1.1), Neitsch et al. 2005), in this class
referenced as SWATtheoDoc. Differences to the SWAT geometry: The flood
plain is not plain, but has a small slope=0.5%, but has an infinite
width

C++ includes: ReachType.h ";

%feature("docstring")  cmf::river::SWATReachType::SWATReachType "SWATReachType(const SWATReachType &copy) ";

%feature("docstring")  cmf::river::SWATReachType::SWATReachType "SWATReachType(double l)

Creates a new reach structure with standard values (small natural
river) BottomWidth = 3m, ChannelDepth = 0.5m, BankSlope = 2, nManning
= 0.0035, FloodPlainSlope = 200. ";

%feature("docstring")  cmf::river::SWATReachType::SWATReachType "SWATReachType(double l, double BankWidth, double Depth)

Creates a new reach structure from a give width and depth.

Parameters:
-----------

l:  length of the channel [m]

BankWidth:  get_channel_width of the reach from bank to bank [m]

Depth:  Depth of the reach [m] ";

%feature("docstring")  cmf::river::SWATReachType::~SWATReachType "virtual ~SWATReachType() ";

%feature("docstring")  cmf::river::SWATReachType::A "virtual double
A(double V) const

Returns the area of the surface for a given volume. ";

%feature("docstring")  cmf::river::SWATReachType::copy "SWATReachType* copy() const ";

%feature("docstring")  cmf::river::SWATReachType::get_channel_width "virtual double get_channel_width(double depth) const

Calculates the flow width from a given actual depth [m] using the
actual IChannel geometry 

.. math::

     \\\\mbox{If } d\\\\le
    d_{IChannel} && \\\\\\\\ w &=& w_{bottom} + 2 \\\\Delta_{bank} d
    \\\\\\\\ \\\\mbox{else, } && \\\\mbox{if the river floods the flood
    plain} \\\\\\\\ w &=& w_{bank} + 2 \\\\Delta_{Floodplain}
    (d-d_{IChannel} \\\\\\\\ 

.

See:  SWATtheoDoc eq. 7:1.1.3 ";

%feature("docstring")  cmf::river::SWATReachType::get_depth "virtual
double get_depth(double area) const

Calculates the actual depth of the reach using the IChannel geometry


.. math::

     d &=& \\\\sqrt{\\\\frac{A}{\\\\Delta_{bank}} +
    \\\\frac{{w_{bottom}}^2}{4 {\\\\Delta_{bank}}^2}} -
    \\\\frac{w_{bottom}}{2 \\\\Delta_{bank}} \\\\\\\\ \\\\mbox{If }
    d>d_{IChannel} &&\\\\\\\\
    d&=&d_{IChannel}+\\\\sqrt{\\\\frac{A-A(d_{IChannel})}{\\\\Delta_{flood\\\\
    plain}} + \\\\frac{{w(d_{IChannel})}^2}{4 {\\\\Delta_{flood\\\\
    plain}}^2}} - \\\\frac{w(d_{IChannel})}{2 \\\\Delta_{flood\\\\ plain}}
    \\\\\\\\ 

.

See:  SWATtheoDoc eq. 7:1.2.4

get_depth of the reach [m]

Parameters:
-----------

area:  Wetted area of a river cross section [m2], can be obtained by
V/l, where V is the stored volume and l is the reach length ";

%feature("docstring")  cmf::river::SWATReachType::get_flux_crossection
"virtual double get_flux_crossection(double depth) const

Calculates the wetted area from a given depth using the IChannel
geometry.

In most cases use get_flux_crossection=V/l, where V is the stored
volume and l is the reach length 

.. math::

     \\\\mbox{If }
    d>d_{IChannel} &&\\\\\\\\ A &=& \\\\left(w_{bottom} + \\\\Delta_{bank}
    d\\\\right) d \\\\\\\\ \\\\mbox{else, } && \\\\mbox{if the river
    floods the flood plain} \\\\\\\\ A &=& A(d_{IChannel}) +
    \\\\left(w(d_{IChannel} + \\\\Delta_{flood\\\\ plain}
    \\\\left(d-d_{IChannel}\\\\right)\\\\right) (d-d_{IChannel}) \\\\\\\\
    

 See:  SWATtheoDoc eq. 7:1.1.4

Wetted area of a river cross section [m2]

Parameters:
-----------

depth:  Depth of the reach [m] ";

%feature("docstring")  cmf::river::SWATReachType::get_length "double
get_length() const

Length of the reach. ";

%feature("docstring")  cmf::river::SWATReachType::get_nManning "virtual double get_nManning() const ";

%feature("docstring")  cmf::river::SWATReachType::get_wetted_perimeter
"virtual double get_wetted_perimeter(double depth) const

Calculates the wetted perimeter from a given actual depth [m] using
the actual IChannel geometry 

.. math::

     \\\\mbox{If }
    d\\\\le d_{IChannel} && \\\\\\\\ P &=& w_{bottom} + 2 \\\\sqrt{1+
    {\\\\Delta_{bank}}^2} d \\\\\\\\ \\\\mbox{else, } && \\\\mbox{if the
    river floods the flood plain} \\\\\\\\ P &=& P(d_{IChannel} + 2
    \\\\sqrt{1+ {\\\\Delta_{flood\\\\ plain}}^2} (d-d_{IChannel}) \\\\\\\\
    

.

See:  SWATtheoDoc eq. 7:1.1.5

Parameters:
-----------

depth:  Actual depth of the reach [m] ";

%feature("docstring")  cmf::river::SWATReachType::h "virtual double
h(double V) const

Returns the depth of a given volume. ";

%feature("docstring")  cmf::river::SWATReachType::q "virtual double
q(double h, double slope) const ";

%feature("docstring")  cmf::river::SWATReachType::qManning "virtual
double qManning(double A, double slope) const

Calculates the flow rate from a given water volume in the reach


.. math::

     q_{Manning}&=& A R^{\\\\frac 2 3}
    \\\\sqrt{\\\\frac {\\\\Delta_z} n} \\\\\\\\ A &=& \\\\frac V l
    \\\\mbox{, (Crosssectional area of the wetted crossection, Volume per
    length)} \\\\\\\\ R &=& \\\\frac A {P(d)} \\\\\\\\ P(d) &=& \\\\mbox{
    the perimeter of the wetted crosssection, a function of reach depth}
    \\\\\\\\ d(V) &=& \\\\mbox{ the depth of the reach a function of the
    volume} \\\\\\\\ \\\\Delta_z &=& \\\\frac{z_{max} - z_{min}}{l}
    \\\\mbox{ Slope of the reach} 

.

Flow rate [m3/s]

Parameters:
-----------

A:  The area of the cross section [m2]

slope:  The slope of the reach [m/m] ";

%feature("docstring")  cmf::river::SWATReachType::set_nManning "virtual void set_nManning(double nManning) ";

%feature("docstring")  cmf::river::SWATReachType::typecode "char
typecode() const ";

%feature("docstring")  cmf::river::SWATReachType::V "virtual double
V(double h) const ";


// File: classcmf__core_1_1_swig_py_iterator.xml
%feature("docstring") cmf_core::SwigPyIterator "

Proxy of C++ swig::SwigPyIterator class. ";

%feature("docstring")  cmf_core::SwigPyIterator::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::SwigPyIterator::__add__ "def
__add__(self, args, kwargs)

__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator ";

%feature("docstring")  cmf_core::SwigPyIterator::__eq__ "def
__eq__(self, args, kwargs)

__eq__(SwigPyIterator self, SwigPyIterator x) -> bool ";

%feature("docstring")  cmf_core::SwigPyIterator::__iadd__ "def
__iadd__(self, args, kwargs)

__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator ";

%feature("docstring")  cmf_core::SwigPyIterator::__isub__ "def
__isub__(self, args, kwargs)

__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator ";

%feature("docstring")  cmf_core::SwigPyIterator::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::SwigPyIterator::__ne__ "def
__ne__(self, args, kwargs)

__ne__(SwigPyIterator self, SwigPyIterator x) -> bool ";

%feature("docstring")  cmf_core::SwigPyIterator::__next__ "def
__next__(self, args, kwargs)

__next__(SwigPyIterator self) -> PyObject * ";

%feature("docstring")  cmf_core::SwigPyIterator::__sub__ "def
__sub__(self, args)

__sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
__sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t ";

%feature("docstring")  cmf_core::SwigPyIterator::advance "def
advance(self, args, kwargs)

advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator ";

%feature("docstring")  cmf_core::SwigPyIterator::copy "def copy(self,
args, kwargs)

copy(SwigPyIterator self) -> SwigPyIterator ";

%feature("docstring")  cmf_core::SwigPyIterator::decr "def decr(self,
args, kwargs)

decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator ";

%feature("docstring")  cmf_core::SwigPyIterator::distance "def
distance(self, args, kwargs)

distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t ";

%feature("docstring")  cmf_core::SwigPyIterator::equal "def
equal(self, args, kwargs)

equal(SwigPyIterator self, SwigPyIterator x) -> bool ";

%feature("docstring")  cmf_core::SwigPyIterator::incr "def incr(self,
args, kwargs)

incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator ";

%feature("docstring")  cmf_core::SwigPyIterator::next "def next(self,
args, kwargs)

next(SwigPyIterator self) -> PyObject * ";

%feature("docstring")  cmf_core::SwigPyIterator::previous "def
previous(self, args, kwargs)

previous(SwigPyIterator self) -> PyObject * ";

%feature("docstring")  cmf_core::SwigPyIterator::value "def
value(self, args, kwargs)

value(SwigPyIterator self) -> PyObject * ";


// File: classcmf__core_1_1_system_bridge.xml
%feature("docstring") cmf_core::SystemBridge "

A SystemBridge is an advanced feature for tuning of the calculation
time.  A SystemBridge can be used to replace an existing connection
between nodes. It is created using the system_bridge function. After
installation, the two nodes can more safely be added to different
integrator systems. One node (called upper) is connected with the
system bridge with the connection formerly connecting the nodes, the
second node (called lower) is connected to the system bridge with as a
Neumann boundary condition. The flux equals the average flux of the
connection upper <-> SystemBridge. Therefore, the downward flux needs
to be integrated over time by the solver the upper node belongs to.
Use as an upper system (system upper node is belonging to) the faster
reacting system. For the connection between upper and SystemBridge,
the SystemBridge reacts as an Dirichlet boundary condition, providing
the potential of the lower node.  The following example code creates a
system bridge between the nodes upper and lower. To integrate the flux
over each timestep automatically, the systembridge is added to the
solver of upper, as an integratable  C++ includes: system_bridge.h ";

%feature("docstring")  cmf_core::SystemBridge::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::SystemBridge::__call__ "def
__call__(self, args, kwargs)

__call__(flux_node self, Time t) -> real ";

%feature("docstring")  cmf_core::SystemBridge::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_node self, flux_node other) -> bool ";

%feature("docstring")  cmf_core::SystemBridge::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::SystemBridge::conc "def conc(self,
args, kwargs)

conc(flux_node self, Time t, solute Solute) -> real  virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const
Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf_core::SystemBridge::connected_nodes "def
connected_nodes(self) ";

%feature("docstring")  cmf_core::SystemBridge::connection_to "def
connection_to(self, args, kwargs)

connection_to(flux_node self, flux_node target) -> flux_connection
cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)  Returns the connection between this and target. ";

%feature("docstring")  cmf_core::SystemBridge::down_flux_integrator "def down_flux_integrator(self, args, kwargs)

down_flux_integrator(SystemBridge self) ->
cmf::water::flux_integrator::ptr  flux_integrator::ptr
down_flux_integrator() const ";

%feature("docstring")  cmf_core::SystemBridge::flux3d_to "def
flux3d_to(self, args, kwargs)

flux3d_to(flux_node self, flux_node target, Time t) -> point
cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf_core::SystemBridge::flux_to "def
flux_to(self, args, kwargs)

flux_to(flux_node self, flux_node target, Time t) -> real  real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)
Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf_core::SystemBridge::fluxes "def
fluxes(self, t) ";

%feature("docstring")  cmf_core::SystemBridge::get_3d_flux "def
get_3d_flux(self, args, kwargs)

get_3d_flux(flux_node self, Time t) -> point  cmf::geometry::point
get_3d_flux(cmf::math::Time t)  Returns the sum of all flux vectors.
";

%feature("docstring")  cmf_core::SystemBridge::get_down_flux "def
get_down_flux(self, args, kwargs)

get_down_flux(SystemBridge self) -> double  double get_down_flux()
const  Returns the currently integrated flux to the lower node. ";

%feature("docstring")  cmf_core::SystemBridge::get_lower_node "def
get_lower_node(self, args, kwargs)

get_lower_node(SystemBridge self) -> cmf::water::flux_node::ptr
flux_node::ptr get_lower_node() const  Returns the lower node. ";

%feature("docstring")  cmf_core::SystemBridge::get_upper_node "def
get_upper_node(self, args, kwargs)

get_upper_node(SystemBridge self) -> cmf::water::flux_node::ptr
flux_node::ptr get_upper_node() const  Returns the upper node. ";

%feature("docstring")  cmf_core::SystemBridge::is_empty "def
is_empty(self, args, kwargs)

is_empty(flux_node self) -> double  virtual double is_empty() const
Returns true if the node has no water. ";

%feature("docstring")  cmf_core::SystemBridge::is_storage "def
is_storage(self, args, kwargs)

is_storage(flux_node self) -> bool  virtual bool is_storage() const
true, if this is a waterstorage ";

%feature("docstring")  cmf_core::SystemBridge::RecalcFluxes "def
RecalcFluxes(self, args, kwargs)

RecalcFluxes(flux_node self, Time t) -> bool  virtual bool
RecalcFluxes(cmf::math::Time t)  Pure flux_nodes do not influence
fluxes, therefore no recalculation of fluxes is required by flux_node.
WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf_core::SystemBridge::remove_connection "def
remove_connection(self, args, kwargs)

remove_connection(flux_node self, cmf::water::flux_node::ptr To) ->
bool  bool remove_connection(cmf::water::flux_node::ptr To)  Remove
the connection. ";

%feature("docstring")  cmf_core::SystemBridge::to_string "def
to_string(self, args, kwargs)

to_string(flux_node self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::SystemBridge::waterbalance "def
waterbalance(self, args, kwargs)

waterbalance(flux_node self, Time t, flux_connection Without=None) ->
real  real waterbalance(cmf::math::Time t, const flux_connection
*Without=0) const  Returns the sum of all fluxes (positive and
negative) at time t.  Single fluxes can be excluded from the
calculation  Parameters: -----------  t:  Time of the query  Without:
A flux_connection that is excluded from the waterbalance (e.g. to
prevent closed circuits) ";


// File: classcmf_1_1water_1_1_system_bridge.xml
%feature("docstring") cmf::water::SystemBridge "

A SystemBridge is an advanced feature for tuning of the calculation
time.

A SystemBridge can be used to replace an existing connection between
nodes. It is created using the system_bridge function. After
installation, the two nodes can more safely be added to different
integrator systems. One node (called upper) is connected with the
system bridge with the connection formerly connecting the nodes, the
second node (called lower) is connected to the system bridge with as a
Neumann boundary condition. The flux equals the average flux of the
connection upper <-> SystemBridge. Therefore, the downward flux needs
to be integrated over time by the solver the upper node belongs to.
Use as an upper system (system upper node is belonging to) the faster
reacting system. For the connection between upper and SystemBridge,
the SystemBridge reacts as an Dirichlet boundary condition, providing
the potential of the lower node.

The following example code creates a system bridge between the nodes
upper and lower. To integrate the flux over each timestep
automatically, the systembridge is added to the solver of upper, as an
integratable

C++ includes: system_bridge.h ";

%feature("docstring")  cmf::water::SystemBridge::conc "virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const

Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf::water::SystemBridge::connection_to "cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::water::SystemBridge::down_flux_integrator
"flux_integrator::ptr down_flux_integrator() const ";

%feature("docstring")  cmf::water::SystemBridge::flux3d_to "cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf::water::SystemBridge::flux_to "real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf::water::SystemBridge::get_3d_flux "cmf::geometry::point get_3d_flux(cmf::math::Time t)

Returns the sum of all flux vectors. ";

%feature("docstring")  cmf::water::SystemBridge::get_connections "cmf::water::connection_list get_connections() const ";

%feature("docstring")  cmf::water::SystemBridge::get_down_flux "double get_down_flux() const

Returns the currently integrated flux to the lower node. ";

%feature("docstring")  cmf::water::SystemBridge::get_lower_node "flux_node::ptr get_lower_node() const

Returns the lower node. ";

%feature("docstring")  cmf::water::SystemBridge::get_potential "double get_potential() const

Returns the water potential of the node in m waterhead.

The base class water storage always returns the height of the location
";

%feature("docstring")  cmf::water::SystemBridge::get_project "cmf::project& get_project() const

Returns the project, this node is part of. ";

%feature("docstring")  cmf::water::SystemBridge::get_upper_node "flux_node::ptr get_upper_node() const

Returns the upper node. ";

%feature("docstring")  cmf::water::SystemBridge::is_empty "virtual
double is_empty() const

Returns true if the node has no water. ";

%feature("docstring")  cmf::water::SystemBridge::is_storage "virtual
bool is_storage() const

true, if this is a waterstorage ";

%feature("docstring")  cmf::water::SystemBridge::RecalcFluxes "virtual bool RecalcFluxes(cmf::math::Time t)

Pure flux_nodes do not influence fluxes, therefore no recalculation of
fluxes is required by flux_node.

WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf::water::SystemBridge::remove_connection "bool remove_connection(cmf::water::flux_node::ptr To)

Remove the connection. ";

%feature("docstring")  cmf::water::SystemBridge::set_potential "virtual void set_potential(real new_potential)

Sets the potential of this flux node. ";

%feature("docstring")  cmf::water::SystemBridge::to_string "virtual
std::string to_string() const ";

%feature("docstring")  cmf::water::SystemBridge::waterbalance "real
waterbalance(cmf::math::Time t, const flux_connection *Without=0)
const

Returns the sum of all fluxes (positive and negative) at time t.

Single fluxes can be excluded from the calculation

Parameters:
-----------

t:  Time of the query

Without:  A flux_connection that is excluded from the waterbalance
(e.g. to prevent closed circuits) ";


// File: classcmf__core_1_1_system_bridge_connection.xml
%feature("docstring") cmf_core::SystemBridgeConnection "

Connects a system bridge with its lower node. Is created automatically
when creating a SystemBridge.  C++ includes: system_bridge.h ";

%feature("docstring")  cmf_core::SystemBridgeConnection::__init__ "def __init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::SystemBridgeConnection::__contains__
"def __contains__(self, cmp) ";

%feature("docstring")  cmf_core::SystemBridgeConnection::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::SystemBridgeConnection::__getitem__ "def __getitem__(self, index) ";

%feature("docstring")  cmf_core::SystemBridgeConnection::__iter__ "def __iter__(self) ";

%feature("docstring")  cmf_core::SystemBridgeConnection::__repr__ "def __repr__(self) ";

%feature("docstring")  cmf_core::SystemBridgeConnection::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::SystemBridgeConnection::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::SystemBridgeConnection::get_target "def get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::SystemBridgeConnection::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::SystemBridgeConnection::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::SystemBridgeConnection::left_node "def left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::SystemBridgeConnection::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::SystemBridgeConnection::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::SystemBridgeConnection::right_node "def right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::SystemBridgeConnection::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::SystemBridgeConnection::short_string
"def short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::SystemBridgeConnection::to_string "def to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1water_1_1_system_bridge_connection.xml
%feature("docstring") cmf::water::SystemBridgeConnection "

Connects a system bridge with its lower node. Is created automatically
when creating a SystemBridge.

C++ includes: system_bridge.h ";

%feature("docstring")  cmf::water::SystemBridgeConnection::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::water::SystemBridgeConnection::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::water::SystemBridgeConnection::get_ptr "ptr get_ptr() const ";

%feature("docstring")  cmf::water::SystemBridgeConnection::get_target
"flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::water::SystemBridgeConnection::get_target
"flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::water::SystemBridgeConnection::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::SystemBridgeConnection::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::water::SystemBridgeConnection::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::water::SystemBridgeConnection::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::water::SystemBridgeConnection::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::water::SystemBridgeConnection::refresh "void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::water::SystemBridgeConnection::right_node
"flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::water::SystemBridgeConnection::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::SystemBridgeConnection::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::water::SystemBridgeConnection::short_string "virtual std::string
short_string() const ";

%feature("docstring")  cmf::water::SystemBridgeConnection::to_string "virtual std::string to_string() const ";


// File: classcmf_1_1water_1_1_technical_flux.xml
%feature("docstring") cmf::water::TechnicalFlux "

Produces a constant but changeable flux from a source to a target, if
enough water is present in the source.



.. math::

     q=\\\\begin{cases}0 & V_{source}\\\\le V_{min}\\\\\\\\ q_0
    \\\\frac{V_{source} - V_{min}}{t_{decr} q_{0} - V_{min}} & V_{source}
    \\\\le t_{decr} q_{0}\\\\\\\\ q_{0} & \\\\end{cases}

This is similar to a neumann boundary, however this is not a boundary
condition, but water is taken from the source (left) water storage and
limited by that water storage.

C++ includes: simple_connections.h ";

%feature("docstring")  cmf::water::TechnicalFlux::TechnicalFlux "TechnicalFlux(cmf::water::WaterStorage::ptr source,
cmf::water::flux_node::ptr target, real maximum_flux, real
minimal_state=0, cmf::math::Time flux_decrease_time=cmf::math::h)

Produces a constant but changeable flux from a source to a target, if
enough water is present in the source.

Parameters:
-----------

source:  The source of the water

target:  The target of the water

maximum_flux:  The requested flux :math:`q_{0}`

minimal_state:  Minimal volume of stored water in source

flux_decrease_time:  ( cmf::math::Time) ";

%feature("docstring")  cmf::water::TechnicalFlux::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")  cmf::water::TechnicalFlux::exchange_target "void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")  cmf::water::TechnicalFlux::get_ptr "ptr
get_ptr() const ";

%feature("docstring")  cmf::water::TechnicalFlux::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::water::TechnicalFlux::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")  cmf::water::TechnicalFlux::get_tracer_filter "real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")  cmf::water::TechnicalFlux::get_tracer_filter "real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::water::TechnicalFlux::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::water::TechnicalFlux::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::water::TechnicalFlux::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::water::TechnicalFlux::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::water::TechnicalFlux::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")  cmf::water::TechnicalFlux::set_tracer_filter "void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")  cmf::water::TechnicalFlux::set_tracer_filter "void set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf::water::TechnicalFlux::short_string "virtual std::string short_string() const ";

%feature("docstring")  cmf::water::TechnicalFlux::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_technical_flux.xml
%feature("docstring") cmf_core::TechnicalFlux "

Produces a constant but changeable flux from a source to a target, if
enough water is present in the source.    .. math::
q=\\\\\\\\begin{cases}0 & V_{source}\\\\\\\\le V_{min}\\\\\\\\\\\\\\\\
q_0     \\\\\\\\frac{V_{source} - V_{min}}{t_{decr} q_{0} - V_{min}} &
V_{source}     \\\\\\\\le t_{decr} q_{0}\\\\\\\\\\\\\\\\ q_{0} &
\\\\\\\\end{cases}  This is similar to a neumann boundary, however
this is not a boundary condition, but water is taken from the source
(left) water storage and limited by that water storage.  C++ includes:
simple_connections.h ";

%feature("docstring")  cmf_core::TechnicalFlux::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::water::TechnicalFlux self, cmf::water::WaterStorage::ptr
source, cmf::water::flux_node::ptr target, real maximum_flux, real
minimal_state=0, Time flux_decrease_time) -> TechnicalFlux
TechnicalFlux(cmf::water::WaterStorage::ptr source,
cmf::water::flux_node::ptr target, real maximum_flux, real
minimal_state=0, cmf::math::Time flux_decrease_time=cmf::math::h)
Produces a constant but changeable flux from a source to a target, if
enough water is present in the source.  Parameters: -----------
source:  The source of the water  target:  The target of the water
maximum_flux:  The requested flux :math:`q_{0}`  minimal_state:
Minimal volume of stored water in source  flux_decrease_time:  (
cmf::math::Time) ";

%feature("docstring")  cmf_core::TechnicalFlux::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::TechnicalFlux::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::TechnicalFlux::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::TechnicalFlux::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::TechnicalFlux::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::TechnicalFlux::conc "def conc(self,
args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::TechnicalFlux::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::TechnicalFlux::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::TechnicalFlux::get_tracer_filter "def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::TechnicalFlux::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::TechnicalFlux::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::TechnicalFlux::q "def q(self, args,
kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::TechnicalFlux::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::TechnicalFlux::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::TechnicalFlux::set_tracer_filter "def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::TechnicalFlux::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::TechnicalFlux::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1math_1_1_time.xml
%feature("docstring") cmf::math::Time "

A time class, used to pass around current modelling times.

Timespans and dates in cmf are used with a special object, called
Time. An extra class has the advantage, that the user does not have to
remember, which unit of time he or she uses or what time unit is
accepted by a specific function of the model. Arithmetic and boolean
operators are supported by Time. Internally the time classes stores
the time as integer milliseconds, therefore rounding issues will only
appear at very small time ranges. Absolute time (like dates) are
represented as milliseconds gone by from Dec, 31st 1899. Microsoft
Excel dates are represented as days from that time, using floating
point numbers, therefore it is very simple to convert Excel time
representations to cmf time.

Another object is Date, which is doesn't provide the operators, but
has a nice printed version and some special date functions, like day
of year (DOY) and provides access to the current hour of day and so
on, which only applyto dates and not to time spans. You can convert
Time to Date an vice versa. The printing is not culture aware and uses
the European representation. If you use the Python standard library
datetime, conversion between Python time and cmf time is possible

Creating absolute time values (dates) Creating time spans

In principle, there are three ways to create time spans. One is to use
one of the static functions, another is to multiply an existing time
span (like one of the build in constants) or to substrate two absolute
times.

Available constants  : 4.1 seconds

: 2.3 hours (138 min)

: 2.3 hours (138 min)

: 60 hours (2.5 days)

: 7 days

: 365/12 days (30.4167 days)

: 365 days

Available operators:

time + time = time, time - time = time

time * float = time ,time / float = time

time/time=float

>, <, ==, !=

Conversions

Converting to python datetime

Converting to numbers

t.AsMilliseconds()

t.AsSeconds()

t.AsMinutes()

t.AsHours()

t.AsDays()

t.AsYears()

Creating time ranges

C++ includes: time.h ";

/*  Constructors  */

%feature("docstring")  cmf::math::Time::Time "Time(int day, int
month, int year, int hour=0, int minute=0, int second=0, int ms=0)

Construction from date and stores the time as Excel-Time (0 =
31.12.1899 0:00:00) ";

%feature("docstring")  cmf::math::Time::Time "Time(Date date)

Conversion constructor. ";

%feature("docstring")  cmf::math::Time::Time "Time(const Time &t)

Copy constructor. ";

%feature("docstring")  cmf::math::Time::Time "Time()

Standard constructor. ";

%feature("docstring")  cmf::math::Time::Time "Time(long long
milliseconds) ";

/*  Time unit conversion  */

%feature("docstring")  cmf::math::Time::AsDays "double AsDays() const

Time in days. ";

%feature("docstring")  cmf::math::Time::AsHours "double AsHours()
const

Time in hours. ";

%feature("docstring")  cmf::math::Time::AsMinutes "double AsMinutes()
const

Time in minutes. ";

%feature("docstring")  cmf::math::Time::AsSeconds "double AsSeconds()
const

Time in seconds. ";

%feature("docstring")  cmf::math::Time::AsMilliseconds "long long
AsMilliseconds() const

Time in milliseconds. ";

%feature("docstring")  cmf::math::Time::AsDate "Date AsDate() const
";

%feature("docstring")  cmf::math::Time::to_string "std::string
to_string(char seperator=':') ";

%feature("docstring")  cmf::math::Time::is_not_0 "bool is_not_0()
const ";

%feature("docstring")  cmf::math::Time::DOY "double DOY() const ";

/*  Arithmetic operators  */

%feature("docstring")  cmf::math::Time::times_in "long long
times_in(const Time &t1) const

Returns the number of times this is included in t1. ";

/*  Boolean Operators  */


// File: classcmf__core_1_1_time.xml
%feature("docstring") cmf_core::Time "

A time class, used to pass around current modelling times.  Timespans
and dates in cmf are used with a special object, called Time. An extra
class has the advantage, that the user does not have to remember,
which unit of time he or she uses or what time unit is accepted by a
specific function of the model. Arithmetic and boolean operators are
supported by Time. Internally the time classes stores the time as
integer milliseconds, therefore rounding issues will only appear at
very small time ranges. Absolute time (like dates) are represented as
milliseconds gone by from Dec, 31st 1899. Microsoft Excel dates are
represented as days from that time, using floating point numbers,
therefore it is very simple to convert Excel time representations to
cmf time.  Another object is Date, which is doesn't provide the
operators, but has a nice printed version and some special date
functions, like day of year (DOY) and provides access to the current
hour of day and so on, which only applyto dates and not to time spans.
You can convert Time to Date an vice versa. The printing is not
culture aware and uses the European representation. If you use the
Python standard library datetime, conversion between Python time and
cmf time is possible  Creating absolute time values (dates) Creating
time spans  In principle, there are three ways to create time spans.
One is to use one of the static functions, another is to multiply an
existing time span (like one of the build in constants) or to
substrate two absolute times.  Available constants  : 4.1 seconds  :
2.3 hours (138 min)  : 2.3 hours (138 min)  : 60 hours (2.5 days)  : 7
days  : 365/12 days (30.4167 days)  : 365 days  Available operators:
time + time = time, time - time = time  time * float = time ,time /
float = time  time/time=float  >, <, ==, !=  Conversions  Converting
to python datetime  Converting to numbers  t.AsMilliseconds()
t.AsSeconds()  t.AsMinutes()  t.AsHours()  t.AsDays()  t.AsYears()
Creating time ranges  C++ includes: time.h ";

%feature("docstring")  cmf_core::Time::__init__ "def __init__(self,
args)

__init__(cmf::math::Time self, int day, int month, int year, int
hour=0, int minute=0, int second=0, int ms=0) -> Time
__init__(cmf::math::Time self, Date date) -> Time
__init__(cmf::math::Time self, Time t) -> Time
__init__(cmf::math::Time self) -> Time __init__(cmf::math::Time self,
long long milliseconds) -> Time  Time(long long milliseconds) ";

%feature("docstring")  cmf_core::Time::__add__ "def __add__(self,
args, kwargs)

__add__(Time self, Time t1) -> Time ";

%feature("docstring")  cmf_core::Time::__eq__ "def __eq__(self, args,
kwargs)

__eq__(Time self, Time t1) -> bool ";

%feature("docstring")  cmf_core::Time::__format__ "def
__format__(self, fmt) ";

%feature("docstring")  cmf_core::Time::__ge__ "def __ge__(self, args,
kwargs)

__ge__(Time self, Time t1) -> bool ";

%feature("docstring")  cmf_core::Time::__getstate__ "def
__getstate__(self) ";

%feature("docstring")  cmf_core::Time::__gt__ "def __gt__(self, args,
kwargs)

__gt__(Time self, Time t1) -> bool ";

%feature("docstring")  cmf_core::Time::__iadd__ "def __iadd__(self,
args, kwargs)

__iadd__(Time self, Time t1) -> Time ";

%feature("docstring")  cmf_core::Time::__imod__ "def __imod__(self,
args, kwargs)

__imod__(Time self, Time t1) -> Time ";

%feature("docstring")  cmf_core::Time::__imul__ "def __imul__(self,
args)

__imul__(Time self, double x) -> Time __imul__(Time self, long long x)
-> Time __imul__(Time self, int x) -> Time ";

%feature("docstring")  cmf_core::Time::__isub__ "def __isub__(self,
args, kwargs)

__isub__(Time self, Time t1) -> Time ";

%feature("docstring")  cmf_core::Time::__itruediv__ "def
__itruediv__(self, args) ";

%feature("docstring")  cmf_core::Time::__le__ "def __le__(self, args,
kwargs)

__le__(Time self, Time t1) -> bool ";

%feature("docstring")  cmf_core::Time::__lt__ "def __lt__(self, args,
kwargs)

__lt__(Time self, Time t1) -> bool ";

%feature("docstring")  cmf_core::Time::__mod__ "def __mod__(self,
args, kwargs)

__mod__(Time self, Time t1) -> Time ";

%feature("docstring")  cmf_core::Time::__mul__ "def __mul__(self,
args)

__mul__(Time self, double x) -> Time __mul__(Time self, long long x)
-> Time __mul__(Time self, int x) -> Time ";

%feature("docstring")  cmf_core::Time::__ne__ "def __ne__(self, args,
kwargs)

__ne__(Time self, Time t1) -> bool ";

%feature("docstring")  cmf_core::Time::__nonzero__ "def
__nonzero__(self) ";

%feature("docstring")  cmf_core::Time::__radd__ "def __radd__(self,
other) ";

%feature("docstring")  cmf_core::Time::__repr__ "def __repr__(self)
";

%feature("docstring")  cmf_core::Time::__rmul__ "def __rmul__(self,
other) ";

%feature("docstring")  cmf_core::Time::__setstate__ "def
__setstate__(self, data) ";

%feature("docstring")  cmf_core::Time::__sub__ "def __sub__(self,
args, kwargs)

__sub__(Time self, Time t1) -> Time ";

%feature("docstring")  cmf_core::Time::__truediv__ "def
__truediv__(self, args) ";

%feature("docstring")  cmf_core::Time::as_datetime "def
as_datetime(self) ";

%feature("docstring")  cmf_core::Time::as_timedelta "def
as_timedelta(self) ";

%feature("docstring")  cmf_core::Time::AsDate "def AsDate(self, args,
kwargs)

AsDate(Time self) -> Date  Date AsDate() const ";

%feature("docstring")  cmf_core::Time::AsDays "def AsDays(self, args,
kwargs)

AsDays(Time self) -> double  double AsDays() const  Time in days. ";

%feature("docstring")  cmf_core::Time::AsHours "def AsHours(self,
args, kwargs)

AsHours(Time self) -> double  double AsHours() const  Time in hours.
";

%feature("docstring")  cmf_core::Time::AsMilliseconds "def
AsMilliseconds(self, args, kwargs)

AsMilliseconds(Time self) -> long long  long long AsMilliseconds()
const  Time in milliseconds. ";

%feature("docstring")  cmf_core::Time::AsMinutes "def AsMinutes(self,
args, kwargs)

AsMinutes(Time self) -> double  double AsMinutes() const  Time in
minutes. ";

%feature("docstring")  cmf_core::Time::AsPython "def AsPython(self)

Deprecated function name, use as_datetime as equivalent ";

%feature("docstring")  cmf_core::Time::AsSeconds "def AsSeconds(self,
args, kwargs)

AsSeconds(Time self) -> double  double AsSeconds() const  Time in
seconds. ";

%feature("docstring")  cmf_core::Time::DOY "def DOY(self, args,
kwargs)

DOY(Time self) -> double  double DOY() const ";

%feature("docstring")  cmf_core::Time::is_not_0 "def is_not_0(self,
args, kwargs)

is_not_0(Time self) -> bool  bool is_not_0() const ";

%feature("docstring")  cmf_core::Time::times_in "def times_in(self,
args, kwargs)

times_in(Time self, Time t1) -> long long  long long times_in(const
Time &t1) const  Returns the number of times this is included in t1.
";

%feature("docstring")  cmf_core::Time::to_string "def to_string(self,
args, kwargs)

to_string(Time self, char seperator) -> std::string  std::string
to_string(char seperator=':') ";


// File: classcmf__core_1_1timeseries.xml
%feature("docstring") cmf_core::timeseries "

A timeseries is a list of values, equally distributed over time.  To
create one, one have to provide as start date and a step size. The end
time is calculated from the number of values. Values queried for times
before the start time are returned as the first item, values after the
end time equal the last item. A timeseries with only one item reacts
like a scalar value.  Creating a time series  With this technique it
is simple to read files or databases to fill timeseries.<b> Using a
timeseries</b>  C++ includes: timeseries.h ";

%feature("docstring")  cmf_core::timeseries::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::math::timeseries self, Time begin, Time step, int
interpolationmethod=1, size_t count=0) -> timeseries  timeseries(const
cmf::math::timeseries &ts) ";

%feature("docstring")  cmf_core::timeseries::__add__ "def
__add__(self, args)

__add__(timeseries self, timeseries arg2) -> timeseries
__add__(timeseries self, double arg2) -> timeseries ";

%feature("docstring")  cmf_core::timeseries::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::timeseries::__getstate__ "def
__getstate__(self) ";

%feature("docstring")  cmf_core::timeseries::__iadd__ "def
__iadd__(self, args)

__iadd__(timeseries self, timeseries arg2) -> timeseries
__iadd__(timeseries self, double arg2) -> timeseries ";

%feature("docstring")  cmf_core::timeseries::__imul__ "def
__imul__(self, args)

__imul__(timeseries self, timeseries arg2) -> timeseries
__imul__(timeseries self, double arg2) -> timeseries ";

%feature("docstring")  cmf_core::timeseries::__isub__ "def
__isub__(self, args)

__isub__(timeseries self, timeseries arg2) -> timeseries
__isub__(timeseries self, double arg2) -> timeseries ";

%feature("docstring")  cmf_core::timeseries::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::timeseries::__itruediv__ "def
__itruediv__(self, args) ";

%feature("docstring")  cmf_core::timeseries::__len__ "def
__len__(self, args, kwargs)

__len__(timeseries self) -> ptrdiff_t ";

%feature("docstring")  cmf_core::timeseries::__mul__ "def
__mul__(self, args)

__mul__(timeseries self, timeseries arg2) -> timeseries
__mul__(timeseries self, double arg2) -> timeseries ";

%feature("docstring")  cmf_core::timeseries::__neg__ "def
__neg__(self, args, kwargs)

__neg__(timeseries self) -> timeseries ";

%feature("docstring")  cmf_core::timeseries::__radd__ "def
__radd__(self, other) ";

%feature("docstring")  cmf_core::timeseries::__rdiv__ "def
__rdiv__(self, other) ";

%feature("docstring")  cmf_core::timeseries::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::timeseries::__rmul__ "def
__rmul__(self, other) ";

%feature("docstring")  cmf_core::timeseries::__rsub__ "def
__rsub__(self, other) ";

%feature("docstring")  cmf_core::timeseries::__setitem__ "def
__setitem__(self, index, value) ";

%feature("docstring")  cmf_core::timeseries::__setstate__ "def
__setstate__(self, data) ";

%feature("docstring")  cmf_core::timeseries::__sub__ "def
__sub__(self, args)

__sub__(timeseries self, timeseries arg2) -> timeseries
__sub__(timeseries self, double arg2) -> timeseries ";

%feature("docstring")  cmf_core::timeseries::__truediv__ "def
__truediv__(self, args) ";

%feature("docstring")  cmf_core::timeseries::add "def add(self, args,
kwargs)

add(timeseries self, double Value)  void add(double Value)  Appends a
measurement. ";

%feature("docstring")  cmf_core::timeseries::adress "def adress(self,
args, kwargs)

adress(timeseries self) -> size_t  size_t adress() const ";

%feature("docstring")  cmf_core::timeseries::as_array "def
as_array(self, args, kwargs)

as_array(timeseries self) -> cmf::math::num_array cmf::math::num_array
as_array() const ";

%feature("docstring")  cmf_core::timeseries::clear "def clear(self,
args, kwargs)

clear(timeseries self)  void clear() ";

%feature("docstring")  cmf_core::timeseries::copy "def copy(self,
args, kwargs)

copy(timeseries self) -> timeseries  timeseries copy() const ";

%feature("docstring")  cmf_core::timeseries::count_values "def
count_values(self, args, kwargs)

count_values(timeseries self) -> size_t  size_t count_values() const
Number of valid values (=size - # of NaN's) ";

%feature("docstring")  cmf_core::timeseries::exp "def exp(self, args,
kwargs)

exp(timeseries self) -> timeseries  timeseries exp() const ";

%feature("docstring")  cmf_core::timeseries::extend "def extend(self,
list)

Adds the values of a sequence to the timeseries ";

%feature("docstring")  cmf_core::timeseries::floating_avg "def
floating_avg(self, args)

floating_avg(timeseries self, Time window_width) -> timeseries
floating_avg(timeseries self, size_t window_size) -> timeseries
timeseries floating_avg(size_t window_size) const ";

%feature("docstring")  cmf_core::timeseries::floating_max "def
floating_max(self, args, kwargs)

floating_max(timeseries self, Time window_width) -> timeseries
timeseries floating_max(cmf::math::Time window_width) const ";

%feature("docstring")  cmf_core::timeseries::floating_min "def
floating_min(self, args, kwargs)

floating_min(timeseries self, Time window_width) -> timeseries
timeseries floating_min(cmf::math::Time window_width) const ";

%feature("docstring")  cmf_core::timeseries::from_array "def
from_array(args, kwargs)

from_array(Time begin, Time step, cmf::math::num_array const & data)
-> timeseries ";

%feature("docstring")  cmf_core::timeseries::from_buffer "def
from_buffer(cls, buf) ";

%feature("docstring")  cmf_core::timeseries::from_file "def
from_file(args, kwargs)

from_file(std::string filename) -> timeseries ";

%feature("docstring")  cmf_core::timeseries::from_file "def
from_file(cls, f)

Loads a timeseries saved with to_file from a file  Description of the
file layout: byte:  0   Number of (int64) 8   Begin of timeseries (in
ms since 31.12.1899 00:00) (int64) 16  Step size of timeseries (in ms)
(int64) 24  Interpolation power (int64) 32  First value of timeseries
(float64) ";

%feature("docstring")  cmf_core::timeseries::from_scalar "def
from_scalar(args, kwargs)

from_scalar(double scalar) -> timeseries ";

%feature("docstring")  cmf_core::timeseries::from_sequence "def
from_sequence(cls, begin, step, sequence, interpolation_mode=1) ";

%feature("docstring")  cmf_core::timeseries::get_i "def get_i(self,
args, kwargs)

get_i(timeseries self, ptrdiff_t i) -> double  double get_i(ptrdiff_t
i) const ";

%feature("docstring")  cmf_core::timeseries::get_slice "def
get_slice(self, args)

get_slice(timeseries self, Time _begin, Time _end, Time _step) ->
timeseries get_slice(timeseries self, ptrdiff_t _begin, ptrdiff_t
_end, ptrdiff_t step=1) -> timeseries  cmf::math::timeseries
get_slice(ptrdiff_t _begin, ptrdiff_t _end, ptrdiff_t step=1) ";

%feature("docstring")  cmf_core::timeseries::get_t "def get_t(self,
args, kwargs)

get_t(timeseries self, Time t) -> double  double get_t(cmf::math::Time
t) const ";

%feature("docstring")  cmf_core::timeseries::interpolate "def
interpolate(self, begin, end, step)

Returns a generator returning the interpolated values at the timesteps
";

%feature("docstring")  cmf_core::timeseries::interpolationpower "def
interpolationpower(self, args, kwargs)

interpolationpower(timeseries self) -> int  int interpolationpower()
const  Method for the interpolation (0 - Nearest neighbor, 1- linear,
2 - cubic spline (not implemented yet) ";

%feature("docstring")  cmf_core::timeseries::inv "def inv(self, args,
kwargs)

inv(timeseries self) -> timeseries  timeseries inv() const ";

%feature("docstring")  cmf_core::timeseries::is_empty "def
is_empty(self, args, kwargs)

is_empty(timeseries self) -> bool  bool is_empty() const  returns true
if no values are added to the timeseries ";

%feature("docstring")  cmf_core::timeseries::iter_time "def
iter_time(self)

Returns an iterator to iterate over each timestep ";

%feature("docstring")  cmf_core::timeseries::log "def log(self, args,
kwargs)

log(timeseries self) -> timeseries  timeseries log() const ";

%feature("docstring")  cmf_core::timeseries::log10 "def log10(self,
args, kwargs)

log10(timeseries self) -> timeseries  timeseries log10() const ";

%feature("docstring")  cmf_core::timeseries::max "def max(self, args,
kwargs)

max(timeseries self) -> double  double max() const ";

%feature("docstring")  cmf_core::timeseries::mean "def mean(self,
args, kwargs)

mean(timeseries self) -> double  double mean() const ";

%feature("docstring")  cmf_core::timeseries::min "def min(self, args,
kwargs)

min(timeseries self) -> double  double min() const ";

%feature("docstring")  cmf_core::timeseries::power "def power(self,
args, kwargs)

power(timeseries self, double exponent) -> timeseries  timeseries
power(double exponent) const ";

%feature("docstring")  cmf_core::timeseries::reduce_avg "def
reduce_avg(self, args, kwargs)

reduce_avg(timeseries self, Time begin, Time step) -> timeseries
timeseries reduce_avg(cmf::math::Time begin, cmf::math::Time step)
const  Creates a timeseries with a bigger timestep, containing the
average. ";

%feature("docstring")  cmf_core::timeseries::reduce_max "def
reduce_max(self, args, kwargs)

reduce_max(timeseries self, Time begin, Time step) -> timeseries
timeseries reduce_max(cmf::math::Time begin, cmf::math::Time step)
const  Creates a timeseries with a bigger timestep, containing the
maximum. ";

%feature("docstring")  cmf_core::timeseries::reduce_min "def
reduce_min(self, args, kwargs)

reduce_min(timeseries self, Time begin, Time step) -> timeseries
timeseries reduce_min(cmf::math::Time begin, cmf::math::Time step)
const  Creates a timeseries with a bigger timestep, containing the
minimum. ";

%feature("docstring")  cmf_core::timeseries::reduce_sum "def
reduce_sum(self, args, kwargs)

reduce_sum(timeseries self, Time begin, Time step) -> timeseries
timeseries reduce_sum(cmf::math::Time begin, cmf::math::Time step)
const  Creates a timeseries with a bigger timestep, containing the
sum. ";

%feature("docstring")  cmf_core::timeseries::remove_nodata "def
remove_nodata(self, args, kwargs)

remove_nodata(timeseries self, double nodata_value)  void
remove_nodata(double nodata_value) ";

%feature("docstring")  cmf_core::timeseries::set_begin "def
set_begin(self, args, kwargs)

set_begin(timeseries self, Time new_begin)  void
set_begin(cmf::math::Time new_begin) ";

%feature("docstring")  cmf_core::timeseries::set_i "def set_i(self,
args, kwargs)

set_i(timeseries self, ptrdiff_t i, double value)  void
set_i(ptrdiff_t i, double value) ";

%feature("docstring")  cmf_core::timeseries::set_interpolationpower "def set_interpolationpower(self, args, kwargs)

set_interpolationpower(timeseries self, int new_ip)  void
set_interpolationpower(int new_ip) ";

%feature("docstring")  cmf_core::timeseries::set_slice "def
set_slice(self, args)

set_slice(timeseries self, Time _begin, Time _end, timeseries values)
set_slice(timeseries self, ptrdiff_t _begin, ptrdiff_t _end,
timeseries _values)  void set_slice(ptrdiff_t _begin, ptrdiff_t _end,
cmf::math::timeseries _values) ";

%feature("docstring")  cmf_core::timeseries::set_step "def
set_step(self, args, kwargs)

set_step(timeseries self, Time new_step)  void
set_step(cmf::math::Time new_step) ";

%feature("docstring")  cmf_core::timeseries::set_t "def set_t(self,
args, kwargs)

set_t(timeseries self, Time t, double value)  void
set_t(cmf::math::Time t, double value) ";

%feature("docstring")  cmf_core::timeseries::size "def size(self,
args, kwargs)

size(timeseries self) -> size_t  size_t size() const  Number of items
in the timeseries. ";

%feature("docstring")  cmf_core::timeseries::to_buffer "def
to_buffer(self)

Returns a binary buffer filled with the data of self ";

%feature("docstring")  cmf_core::timeseries::to_file "def
to_file(self, f)

Saves a timeseries in a special binary format. The format consists of
4 integers with 64 bit, indicating the milliseconds after the
31.12.1899 00:00 of the beginning of the timeseries, the milliseconds
of the time step, the interpolation power and the number of values.
The following 64 bit floats, are the values of the timeseries ";

%feature("docstring")  cmf_core::timeseries::to_pandas "def
to_pandas(self)

Returns the timeseries as a pandas Series object :return: A
pandas.Series object with the timesteps as index ";


// File: classcmf_1_1math_1_1timeseries.xml
%feature("docstring") cmf::math::timeseries "

A timeseries is a list of values, equally distributed over time.

To create one, one have to provide as start date and a step size. The
end time is calculated from the number of values. Values queried for
times before the start time are returned as the first item, values
after the end time equal the last item. A timeseries with only one
item reacts like a scalar value.

Creating a time series

With this technique it is simple to read files or databases to fill
timeseries.<b> Using a timeseries</b>

C++ includes: timeseries.h ";

/*  Operators  */

/* Binary operators defined as free operators:

x = {+,-,*,/}

Defined for (x is one of the operators above): timeseries = timeseries
x timeseries

timeseries = double x timeseries

timeseries = timeseries x double

*/

%feature("docstring")  cmf::math::timeseries::inv "timeseries inv()
const ";

%feature("docstring")  cmf::math::timeseries::reduce_min "timeseries
reduce_min(cmf::math::Time begin, cmf::math::Time step) const

Creates a timeseries with a bigger timestep, containing the minimum.
";

%feature("docstring")  cmf::math::timeseries::reduce_max "timeseries
reduce_max(cmf::math::Time begin, cmf::math::Time step) const

Creates a timeseries with a bigger timestep, containing the maximum.
";

%feature("docstring")  cmf::math::timeseries::reduce_sum "timeseries
reduce_sum(cmf::math::Time begin, cmf::math::Time step) const

Creates a timeseries with a bigger timestep, containing the sum. ";

%feature("docstring")  cmf::math::timeseries::reduce_avg "timeseries
reduce_avg(cmf::math::Time begin, cmf::math::Time step) const

Creates a timeseries with a bigger timestep, containing the average.
";

%feature("docstring")  cmf::math::timeseries::floating_avg "timeseries floating_avg(cmf::math::Time window_width) const ";

%feature("docstring")  cmf::math::timeseries::floating_avg "timeseries floating_avg(size_t window_size) const ";

%feature("docstring")  cmf::math::timeseries::floating_max "timeseries floating_max(cmf::math::Time window_width) const ";

%feature("docstring")  cmf::math::timeseries::floating_min "timeseries floating_min(cmf::math::Time window_width) const ";

%feature("docstring")  cmf::math::timeseries::mean "double mean()
const ";

%feature("docstring")  cmf::math::timeseries::min "double min() const
";

%feature("docstring")  cmf::math::timeseries::max "double max() const
";

%feature("docstring")  cmf::math::timeseries::log "timeseries log()
const ";

%feature("docstring")  cmf::math::timeseries::log10 "timeseries
log10() const ";

%feature("docstring")  cmf::math::timeseries::power "timeseries
power(double exponent) const ";

%feature("docstring")  cmf::math::timeseries::exp "timeseries exp()
const ";

%feature("docstring")  cmf::math::timeseries::timeseries "timeseries(cmf::math::Time begin=cmf::math::Time(), cmf::math::Time
step=cmf::math::day, int interpolationmethod=1, size_t count=0)

Constructor of a time series.

Parameters:
-----------

begin:  First date of measurement

step:   Time between measurements

interpolationmethod:  Method for the interpolation (0 - Nearest
neighbor, 1- linear, 2 - cubic spline (not implemented yet)

count:  Initial number of items. Items are filled with 0.0 ";

%feature("docstring")  cmf::math::timeseries::timeseries "timeseries(const cmf::math::timeseries &ts) ";

%feature("docstring")  cmf::math::timeseries::add "void add(double
Value)

Appends a measurement. ";

%feature("docstring")  cmf::math::timeseries::adress "size_t adress()
const ";

%feature("docstring")  cmf::math::timeseries::as_array "cmf::math::num_array as_array() const ";

%feature("docstring")  cmf::math::timeseries::begin "cmf::math::Time
begin() const

First date of measurement. ";

%feature("docstring")  cmf::math::timeseries::clear "void clear() ";

%feature("docstring")  cmf::math::timeseries::copy "timeseries copy()
const ";

%feature("docstring")  cmf::math::timeseries::count_values "size_t
count_values() const

Number of valid values (=size - # of NaN's) ";

%feature("docstring")  cmf::math::timeseries::end "cmf::math::Time
end() const

Last date of measurements. ";

%feature("docstring")  cmf::math::timeseries::get_i "double
get_i(ptrdiff_t i) const ";

%feature("docstring")  cmf::math::timeseries::get_slice "cmf::math::timeseries get_slice(cmf::math::Time _begin,
cmf::math::Time _end, cmf::math::Time _step=cmf::math::Time()) ";

%feature("docstring")  cmf::math::timeseries::get_slice "cmf::math::timeseries get_slice(ptrdiff_t _begin, ptrdiff_t _end,
ptrdiff_t step=1) ";

%feature("docstring")  cmf::math::timeseries::get_t "double
get_t(cmf::math::Time t) const ";

%feature("docstring")  cmf::math::timeseries::interpolationpower "int
interpolationpower() const

Method for the interpolation (0 - Nearest neighbor, 1- linear, 2 -
cubic spline (not implemented yet) ";

%feature("docstring")  cmf::math::timeseries::is_empty "bool
is_empty() const

returns true if no values are added to the timeseries ";

%feature("docstring")  cmf::math::timeseries::remove_nodata "void
remove_nodata(double nodata_value) ";

%feature("docstring")  cmf::math::timeseries::set_begin "void
set_begin(cmf::math::Time new_begin) ";

%feature("docstring")  cmf::math::timeseries::set_i "void
set_i(ptrdiff_t i, double value) ";

%feature("docstring")  cmf::math::timeseries::set_interpolationpower "void set_interpolationpower(int new_ip) ";

%feature("docstring")  cmf::math::timeseries::set_slice "void
set_slice(cmf::math::Time _begin, cmf::math::Time _end,
cmf::math::timeseries values) ";

%feature("docstring")  cmf::math::timeseries::set_slice "void
set_slice(ptrdiff_t _begin, ptrdiff_t _end, cmf::math::timeseries
_values) ";

%feature("docstring")  cmf::math::timeseries::set_step "void
set_step(cmf::math::Time new_step) ";

%feature("docstring")  cmf::math::timeseries::set_t "void
set_t(cmf::math::Time t, double value) ";

%feature("docstring")  cmf::math::timeseries::size "size_t size()
const

Number of items in the timeseries. ";

%feature("docstring")  cmf::math::timeseries::step "cmf::math::Time
step() const

Time between the measurements. ";


// File: structcmf_1_1math_1_1timeseries_1_1timeseries__data.xml


// File: classcmf_1_1upslope_1_1_e_t_1_1timeseries_e_tpot.xml
%feature("docstring") cmf::upslope::ET::timeseriesETpot "

A timeseries driven evapotranspiration.

Uses a timeseries of measured or elsewhere modelled ETpot. Actual
Evapotranspiration is calculated from rootdepth and actual matrix
potential in the layers using Tact. The value of ETpot can be changed
during runtime

C++ includes: ET.h ";

%feature("docstring")
cmf::upslope::ET::timeseriesETpot::timeseriesETpot "timeseriesETpot(cmf::upslope::SoilLayer::ptr source,
cmf::water::flux_node::ptr ET_target, cmf::math::timeseries
ETpot_values) ";

%feature("docstring")  cmf::upslope::ET::timeseriesETpot::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")  cmf::upslope::ET::timeseriesETpot::ETpot "virtual real ETpot(cmf::math::Time t) const ";

%feature("docstring")
cmf::upslope::ET::timeseriesETpot::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::upslope::ET::timeseriesETpot::get_layer "SoilLayer::ptr get_layer() const ";

%feature("docstring")  cmf::upslope::ET::timeseriesETpot::get_ptr "ptr get_ptr() const ";

%feature("docstring")  cmf::upslope::ET::timeseriesETpot::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::ET::timeseriesETpot::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::ET::timeseriesETpot::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::timeseriesETpot::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::ET::timeseriesETpot::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::upslope::ET::timeseriesETpot::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::ET::timeseriesETpot::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::ET::timeseriesETpot::refresh "void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::upslope::ET::timeseriesETpot::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::ET::timeseriesETpot::set_stressfunction "void
set_stressfunction(const RootUptakeStessFunction &stressfunction)

Sets the stress function to limit water uptake. ";

%feature("docstring")
cmf::upslope::ET::timeseriesETpot::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::ET::timeseriesETpot::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf::upslope::ET::timeseriesETpot::short_string
"virtual std::string short_string() const ";

%feature("docstring")  cmf::upslope::ET::timeseriesETpot::to_string "std::string to_string() const ";


// File: classcmf__core_1_1timeseries_e_tpot.xml
%feature("docstring") cmf_core::timeseriesETpot "

A timeseries driven evapotranspiration.  Uses a timeseries of measured
or elsewhere modelled ETpot. Actual Evapotranspiration is calculated
from rootdepth and actual matrix potential in the layers using Tact.
The value of ETpot can be changed during runtime  C++ includes: ET.h
";

%feature("docstring")  cmf_core::timeseriesETpot::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::ET::timeseriesETpot self,
cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr
ET_target, timeseries ETpot_values) -> timeseriesETpot
timeseriesETpot(cmf::upslope::SoilLayer::ptr source,
cmf::water::flux_node::ptr ET_target, cmf::math::timeseries
ETpot_values) ";

%feature("docstring")  cmf_core::timeseriesETpot::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::timeseriesETpot::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::timeseriesETpot::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::timeseriesETpot::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::timeseriesETpot::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::timeseriesETpot::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::timeseriesETpot::ETpot "def
ETpot(self, args, kwargs)

ETpot(stressedET self, Time t) -> real  virtual real
ETpot(cmf::math::Time t) const ";

%feature("docstring")  cmf_core::timeseriesETpot::exchange_target "def exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::timeseriesETpot::get_layer "def
get_layer(self, args, kwargs)

get_layer(stressedET self) -> cmf::upslope::SoilLayer::ptr
SoilLayer::ptr get_layer() const ";

%feature("docstring")  cmf_core::timeseriesETpot::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::timeseriesETpot::get_tracer_filter "def get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::timeseriesETpot::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::timeseriesETpot::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::timeseriesETpot::q "def q(self,
args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::timeseriesETpot::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::timeseriesETpot::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::timeseriesETpot::set_stressfunction "def set_stressfunction(self, args, kwargs)

set_stressfunction(stressedET self, RootUptakeStessFunction
stressfunction)  void set_stressfunction(const RootUptakeStessFunction
&stressfunction)  Sets the stress function to limit water uptake. ";

%feature("docstring")  cmf_core::timeseriesETpot::set_tracer_filter "def set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::timeseriesETpot::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::timeseriesETpot::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf__core_1_1_timeseries_rain_source.xml
%feature("docstring") cmf_core::TimeseriesRainSource "

A rainsource with a timeseries.  Simpler to use than a rainfall
station if there are only few cells in the project  C++ includes:
precipitation.h ";

%feature("docstring")  cmf_core::TimeseriesRainSource::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::TimeseriesRainSource::__call__ "def
__call__(self, args, kwargs)

__call__(RainSource self, Time t) -> real ";

%feature("docstring")  cmf_core::TimeseriesRainSource::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_node self, flux_node other) -> bool ";

%feature("docstring")  cmf_core::TimeseriesRainSource::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::TimeseriesRainSource::conc "def
conc(self, args, kwargs)

conc(flux_node self, Time t, solute Solute) -> real  virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const
Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf_core::TimeseriesRainSource::connected_nodes
"def connected_nodes(self) ";

%feature("docstring")  cmf_core::TimeseriesRainSource::connection_to "def connection_to(self, args, kwargs)

connection_to(flux_node self, flux_node target) -> flux_connection
cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)  Returns the connection between this and target. ";

%feature("docstring")  cmf_core::TimeseriesRainSource::flux3d_to "def
flux3d_to(self, args, kwargs)

flux3d_to(flux_node self, flux_node target, Time t) -> point
cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf_core::TimeseriesRainSource::flux_to "def
flux_to(self, args, kwargs)

flux_to(flux_node self, flux_node target, Time t) -> real  real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)
Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf_core::TimeseriesRainSource::fluxes "def
fluxes(self, t) ";

%feature("docstring")  cmf_core::TimeseriesRainSource::get_3d_flux "def get_3d_flux(self, args, kwargs)

get_3d_flux(flux_node self, Time t) -> point  cmf::geometry::point
get_3d_flux(cmf::math::Time t)  Returns the sum of all flux vectors.
";

%feature("docstring")  cmf_core::TimeseriesRainSource::get_intensity "def get_intensity(self, args, kwargs)

get_intensity(RainSource self, Time t) -> real  virtual real
get_intensity(cmf::math::Time t) const =0  Returns the actual rainfall
intensity in mm/day. ";

%feature("docstring")  cmf_core::TimeseriesRainSource::is_empty "def
is_empty(self, args, kwargs)

is_empty(flux_node self) -> double  virtual double is_empty() const
Returns true if the node has no water. ";

%feature("docstring")  cmf_core::TimeseriesRainSource::is_storage "def is_storage(self, args, kwargs)

is_storage(flux_node self) -> bool  virtual bool is_storage() const
true, if this is a waterstorage ";

%feature("docstring")  cmf_core::TimeseriesRainSource::RecalcFluxes "def RecalcFluxes(self, args, kwargs)

RecalcFluxes(flux_node self, Time t) -> bool  virtual bool
RecalcFluxes(cmf::math::Time t)  Pure flux_nodes do not influence
fluxes, therefore no recalculation of fluxes is required by flux_node.
WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")
cmf_core::TimeseriesRainSource::remove_connection "def
remove_connection(self, args, kwargs)

remove_connection(flux_node self, cmf::water::flux_node::ptr To) ->
bool  bool remove_connection(cmf::water::flux_node::ptr To)  Remove
the connection. ";

%feature("docstring")  cmf_core::TimeseriesRainSource::to_string "def
to_string(self, args, kwargs)

to_string(flux_node self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::TimeseriesRainSource::waterbalance "def waterbalance(self, args, kwargs)

waterbalance(flux_node self, Time t, flux_connection Without=None) ->
real  real waterbalance(cmf::math::Time t, const flux_connection
*Without=0) const  Returns the sum of all fluxes (positive and
negative) at time t.  Single fluxes can be excluded from the
calculation  Parameters: -----------  t:  Time of the query  Without:
A flux_connection that is excluded from the waterbalance (e.g. to
prevent closed circuits) ";


// File: classcmf_1_1atmosphere_1_1_timeseries_rain_source.xml
%feature("docstring") cmf::atmosphere::TimeseriesRainSource "

A rainsource with a timeseries.

Simpler to use than a rainfall station if there are only few cells in
the project

C++ includes: precipitation.h ";

%feature("docstring")  cmf::atmosphere::TimeseriesRainSource::conc "virtual real conc(cmf::math::Time t, const cmf::water::solute &Solute)
const

Returns the concentration of a solute in the rainfall at time t. ";

%feature("docstring")
cmf::atmosphere::TimeseriesRainSource::connection_to "cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)

Returns the connection between this and target. ";

%feature("docstring")
cmf::atmosphere::TimeseriesRainSource::flux3d_to "cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf::atmosphere::TimeseriesRainSource::flux_to
"real flux_to(const cmf::water::flux_node &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")
cmf::atmosphere::TimeseriesRainSource::get_3d_flux "cmf::geometry::point get_3d_flux(cmf::math::Time t)

Returns the sum of all flux vectors. ";

%feature("docstring")
cmf::atmosphere::TimeseriesRainSource::get_connections "cmf::water::connection_list get_connections() const ";

%feature("docstring")
cmf::atmosphere::TimeseriesRainSource::get_intensity "real
get_intensity(cmf::math::Time t) const

Returns the actual rainfall intensity in mm/day. ";

%feature("docstring")
cmf::atmosphere::TimeseriesRainSource::get_potential "virtual real
get_potential() const

Returns the water potential of the node in m waterhead.

The base class water storage always returns the height of the location
";

%feature("docstring")
cmf::atmosphere::TimeseriesRainSource::get_project "cmf::project&
get_project() const

Returns the project, this node is part of. ";

%feature("docstring")  cmf::atmosphere::TimeseriesRainSource::is_empty
"virtual double is_empty() const

Returns false. ";

%feature("docstring")
cmf::atmosphere::TimeseriesRainSource::is_storage "virtual bool
is_storage() const

true, if this is a waterstorage ";

%feature("docstring")
cmf::atmosphere::TimeseriesRainSource::RecalcFluxes "virtual bool
RecalcFluxes(cmf::math::Time t)

Pure flux_nodes do not influence fluxes, therefore no recalculation of
fluxes is required by flux_node.

WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")
cmf::atmosphere::TimeseriesRainSource::remove_connection "bool
remove_connection(cmf::water::flux_node::ptr To)

Remove the connection. ";

%feature("docstring")
cmf::atmosphere::TimeseriesRainSource::set_potential "virtual void
set_potential(real new_potential)

Sets the potential of this flux node. ";

%feature("docstring")
cmf::atmosphere::TimeseriesRainSource::to_string "virtual std::string
to_string() const ";

%feature("docstring")
cmf::atmosphere::TimeseriesRainSource::waterbalance "real
waterbalance(cmf::math::Time t, const flux_connection *Without=0)
const

Returns the sum of all fluxes (positive and negative) at time t.

Single fluxes can be excluded from the calculation

Parameters:
-----------

t:  Time of the query

Without:  A flux_connection that is excluded from the waterbalance
(e.g. to prevent closed circuits) ";


// File: classcmf__core_1_1_t_o_p_model_flow.xml
%feature("docstring") cmf_core::TOPModelFlow "

Calculates a flux from a soil layer using TOPMODELs (Beven & Kirkby
1979) exponential transmissivity concept.    .. math::       T = T_0
\\\\\\\\exp(-D_i/m)   where:  :math:`T` is the actual transmissivity
of the profile in :math:`m^2/day`  :math:`T0` is the transmissivity of
the profile at saturation  :math:`D_i` is the drained depth in m,
calculated as :math:`(C-V)/A`, the capacity of the layer - volume per
area  :math:`m` a scaling factor in m  By using the transmissivity in
Darcy's law and assuming the GW gradient to be parallel to the
topographic slope we get for the flow:   .. math::       q = T_0
\\\\\\\\exp(-D_i/m) w s  where:  :math:`q` is the flux in
:math:`m^3/day`  :math:`w` is the flow width (unit contour length)
:math:`s` is the topographic slope between layer and outlet  TOPMODEL
is based on the concept of drained depth, not, as cmf on the concept
of stored volume. Hence, negative volumes can occur if  C++ includes:
subsurfacefluxes.h ";

%feature("docstring")  cmf_core::TOPModelFlow::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::connections::TOPModelFlow self,
cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right,
real T0, real m, real flowwidth, real distance=0) -> TOPModelFlow
TOPModelFlow(cmf::upslope::SoilLayer::ptr left,
cmf::water::flux_node::ptr right, real T0, real m, real flowwidth,
real distance=0) ";

%feature("docstring")  cmf_core::TOPModelFlow::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::TOPModelFlow::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::TOPModelFlow::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::TOPModelFlow::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::TOPModelFlow::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::TOPModelFlow::conc "def conc(self,
args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::TOPModelFlow::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::TOPModelFlow::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::TOPModelFlow::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::TOPModelFlow::kill_me "def
kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::TOPModelFlow::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::TOPModelFlow::q "def q(self, args,
kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::TOPModelFlow::refresh "def
refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::TOPModelFlow::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::TOPModelFlow::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::TOPModelFlow::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::TOPModelFlow::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1connections_1_1_t_o_p_model_flow.xml
%feature("docstring") cmf::upslope::connections::TOPModelFlow "

Calculates a flux from a soil layer using TOPMODELs (Beven & Kirkby
1979) exponential transmissivity concept.



.. math::

     T = T_0 \\\\exp(-D_i/m) 

where:  :math:`T` is the actual
transmissivity of the profile in :math:`m^2/day`

:math:`T0` is the transmissivity of the profile at saturation

:math:`D_i` is the drained depth in m, calculated as :math:`(C-V)/A`, the capacity
of the layer - volume per area

:math:`m` a scaling factor in m

By using the transmissivity in Darcy's law and assuming the GW
gradient to be parallel to the topographic slope we get for the flow:


.. math::

     q = T_0 \\\\exp(-D_i/m) w s

where:  :math:`q` is the flux in
:math:`m^3/day`

:math:`w` is the flow width (unit contour length)

:math:`s` is the topographic slope between layer and outlet

TOPMODEL is based on the concept of drained depth, not, as cmf on the
concept of stored volume. Hence, negative volumes can occur if

C++ includes: subsurfacefluxes.h ";

%feature("docstring")
cmf::upslope::connections::TOPModelFlow::TOPModelFlow "TOPModelFlow(cmf::upslope::SoilLayer::ptr left,
cmf::water::flux_node::ptr right, real T0, real m, real flowwidth,
real distance=0) ";

%feature("docstring")  cmf::upslope::connections::TOPModelFlow::conc "real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::TOPModelFlow::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")
cmf::upslope::connections::TOPModelFlow::get_ptr "ptr get_ptr() const
";

%feature("docstring")
cmf::upslope::connections::TOPModelFlow::get_target "flux_node::ptr
get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::TOPModelFlow::get_target "flux_node::ptr
get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::TOPModelFlow::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::TOPModelFlow::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::TOPModelFlow::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::TOPModelFlow::left_node "flux_node::ptr
left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::connections::TOPModelFlow::q "real q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::TOPModelFlow::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::TOPModelFlow::right_node "flux_node::ptr
right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::TOPModelFlow::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::TOPModelFlow::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::TOPModelFlow::short_string "virtual
std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::TOPModelFlow::to_string "virtual
std::string to_string() const ";


// File: classcmf__core_1_1_topographic_gradient_darcy.xml
%feature("docstring") cmf_core::TopographicGradientDarcy "

Calculates the lateral flow using the topographic gradient.    ..
math::       q_{lat} = \\\\\\\\frac{z_1 -
z_2}{\\\\\\\\|C_1-C_2\\\\\\\\|} \\\\\\\\frac 12     (T(C_1)+T(C_2)) w
where  :math:`z_1 - z_2` is the topographic height difference
:math:`\\\\\\\\|C_1-C_2\\\\\\\\|` is the distance from Cell 1 to Cell
2  :math:`T(C)` is the transmissivity of cell C, calculated by
SoilType::Transmissivity  :math:`w` is the width of the connection of
the cells  C++ includes: subsurfacefluxes.h ";

%feature("docstring")  cmf_core::TopographicGradientDarcy::__init__ "def __init__(self, args, kwargs)

__init__(cmf::upslope::connections::TopographicGradientDarcy self,
cmf::upslope::SoilLayer::ptr left, cmf::water::flux_node::ptr right,
real FlowWidth, real Distance=0) -> TopographicGradientDarcy
TopographicGradientDarcy(cmf::upslope::SoilLayer::ptr left,
cmf::water::flux_node::ptr right, real FlowWidth, real Distance=0)
Creates the connection.  Parameters: -----------  left:  Left node of
the connection (needs to be soil water storage)  right:  Right node of
the connection (can be any node)  FlowWidth:  the width of the
connection - is multiplied by layer thickness to get the interface
area  Distance:  the length of the connection. If 0, the distance is
calculated from the position of the nodes ";

%feature("docstring")
cmf_core::TopographicGradientDarcy::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::TopographicGradientDarcy::__eq__ "def __eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::TopographicGradientDarcy::__getitem__
"def __getitem__(self, index) ";

%feature("docstring")  cmf_core::TopographicGradientDarcy::__iter__ "def __iter__(self) ";

%feature("docstring")  cmf_core::TopographicGradientDarcy::__repr__ "def __repr__(self) ";

%feature("docstring")  cmf_core::TopographicGradientDarcy::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::TopographicGradientDarcy::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::TopographicGradientDarcy::get_target
"def get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::TopographicGradientDarcy::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::TopographicGradientDarcy::kill_me "def kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::TopographicGradientDarcy::left_node "def left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::TopographicGradientDarcy::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::TopographicGradientDarcy::refresh "def refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::TopographicGradientDarcy::right_node
"def right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::TopographicGradientDarcy::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf_core::TopographicGradientDarcy::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::TopographicGradientDarcy::to_string "def to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1upslope_1_1connections_1_1_topographic_gradient_darcy.xml
%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy "

Calculates the lateral flow using the topographic gradient.



.. math::

     q_{lat} = \\\\frac{z_1 - z_2}{\\\\|C_1-C_2\\\\|} \\\\frac 12
    (T(C_1)+T(C_2)) w 

where  :math:`z_1 - z_2` is the topographic height
difference

:math:`\\\\|C_1-C_2\\\\|` is the distance from Cell 1 to Cell 2

:math:`T(C)` is the transmissivity of cell C, calculated by
SoilType::Transmissivity

:math:`w` is the width of the connection of the cells

C++ includes: subsurfacefluxes.h ";

%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy::TopographicGradientDarcy
"TopographicGradientDarcy(cmf::upslope::SoilLayer::ptr left,
cmf::water::flux_node::ptr right, real FlowWidth, real Distance=0)

Creates the connection.

Parameters:
-----------

left:  Left node of the connection (needs to be soil water storage)

right:  Right node of the connection (can be any node)

FlowWidth:  the width of the connection - is multiplied by layer
thickness to get the interface area

Distance:  the length of the connection. If 0, the distance is
calculated from the position of the nodes ";

%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy::exchange_target "void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy::get_ptr "ptr
get_ptr() const ";

%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy::get_tracer_filter
"real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy::get_tracer_filter
"real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy::set_tracer_filter
"void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy::set_tracer_filter
"void set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy::short_string "virtual std::string short_string() const ";

%feature("docstring")
cmf::upslope::connections::TopographicGradientDarcy::to_string "virtual std::string to_string() const ";


// File: classcmf__core_1_1_topology.xml
%feature("docstring") cmf_core::Topology "

represents the connectivity of cells to each other  C++ includes:
Topology.h ";

%feature("docstring")  cmf_core::Topology::__init__ "def
__init__(self, args, kwargs) ";

%feature("docstring")  cmf_core::Topology::__eq__ "def __eq__(self,
args, kwargs)

__eq__(Topology self, Topology cmp) -> bool ";

%feature("docstring")  cmf_core::Topology::AddNeighbor "def
AddNeighbor(self, args)

AddNeighbor(Topology self, Cell target, double flowwidth)
AddNeighbor(Topology self, Topology target, double flowwidth)  void
AddNeighbor(Topology &target, double flowwidth) ";

%feature("docstring")  cmf_core::Topology::calculate_contributing_area
"def calculate_contributing_area(args, kwargs)

calculate_contributing_area(cell_vector arg1) ";

%feature("docstring")  cmf_core::Topology::ContributingArea "def
ContributingArea(self, args, kwargs)

ContributingArea(Topology self) -> double  double ContributingArea()
const  Get the contributing area (steepest path upwards) ";

%feature("docstring")  cmf_core::Topology::flowwidth "def
flowwidth(self, args)

flowwidth(Topology self, Cell target) -> double flowwidth(Topology
self, Topology target) -> double  double flowwidth(Topology &target)
";

%feature("docstring")  cmf_core::Topology::get_position "def
get_position(self, args, kwargs)

get_position(Topology self) -> point  cmf::geometry::point
get_position() const  Returns the center of the cell. ";

%feature("docstring")  cmf_core::Topology::MainOutlet "def
MainOutlet(self, args, kwargs)

MainOutlet(Topology self, bool forceRecalc=False) -> Cell  Cell*
MainOutlet(bool forceRecalc=false)  Returns the mainoutlet (steepest
lower neighbor) ";

%feature("docstring")  cmf_core::Topology::neighbor_count "def
neighbor_count(self, args, kwargs)

neighbor_count(Topology self) -> size_t  size_t neighbor_count() const
Returns the number of neighbors. ";

%feature("docstring")  cmf_core::Topology::RemoveNeighbor "def
RemoveNeighbor(self, args, kwargs)

RemoveNeighbor(Topology self, Topology target)  void
RemoveNeighbor(Topology &target)  Removes the topological relation to
the given cell. ";


// File: classcmf_1_1upslope_1_1_topology.xml
%feature("docstring") cmf::upslope::Topology "

represents the connectivity of cells to each other

C++ includes: Topology.h ";

%feature("docstring")  cmf::upslope::Topology::AddNeighbor "void
AddNeighbor(Cell &target, double flowwidth)

Adds a neighbor cell to the topology with flowwidth. ";

%feature("docstring")  cmf::upslope::Topology::AddNeighbor "void
AddNeighbor(Topology &target, double flowwidth) ";

%feature("docstring")  cmf::upslope::Topology::ContributingArea "double ContributingArea() const

Get the contributing area (steepest path upwards) ";

%feature("docstring")  cmf::upslope::Topology::flowwidth "double
flowwidth(Cell &target)

returns the flow width between this cell and the target cell. Returns
0 if no topology is defined ";

%feature("docstring")  cmf::upslope::Topology::flowwidth "double
flowwidth(Topology &target) ";

%feature("docstring")  cmf::upslope::Topology::get_position "cmf::geometry::point get_position() const

Returns the center of the cell. ";

%feature("docstring")  cmf::upslope::Topology::MainOutlet "Cell*
MainOutlet(bool forceRecalc=false)

Returns the mainoutlet (steepest lower neighbor) ";

%feature("docstring")  cmf::upslope::Topology::neighbor_count "size_t
neighbor_count() const

Returns the number of neighbors. ";

%feature("docstring")  cmf::upslope::Topology::RemoveNeighbor "void
RemoveNeighbor(Topology &target)

Removes the topological relation to the given cell. ";


// File: classcmf_1_1river_1_1_triangular_reach.xml
%feature("docstring") cmf::river::TriangularReach "

Structure for the description of reaches with a triangular cross
section.

Although double triangular cross section reach are rarely met, a
triangular reach does scale with its water load, and is therefore
preferable in case where nothing about IChannel geometry is known

C++ includes: ReachType.h ";

%feature("docstring")  cmf::river::TriangularReach::TriangularReach "TriangularReach(double l, double bankSlope=2)

Creates a new triangular reach type. ";

%feature("docstring")  cmf::river::TriangularReach::TriangularReach "TriangularReach(const TriangularReach &copy) ";

%feature("docstring")  cmf::river::TriangularReach::~TriangularReach "virtual ~TriangularReach() ";

%feature("docstring")  cmf::river::TriangularReach::A "virtual double
A(double V) const

Returns the area of the surface for a given volume. ";

%feature("docstring")  cmf::river::TriangularReach::copy "TriangularReach* copy() const ";

%feature("docstring")  cmf::river::TriangularReach::get_channel_width
"virtual double get_channel_width(double depth) const

Returns the width of the stream at a given depth 

.. math::

    
    w &=& 2 \\\\Delta\\\\ d 

. ";

%feature("docstring")  cmf::river::TriangularReach::get_depth "virtual double get_depth(double area) const

Returns the depth at a given crossection area 

.. math::

     d
    &=& \\\\sqrt{\\\\frac{A}{\\\\Delta}} 

. ";

%feature("docstring")
cmf::river::TriangularReach::get_flux_crossection "virtual double
get_flux_crossection(double depth) const

Returns the crossection area at a given depth 

.. math::

     A
    &=& d^2 \\\\Delta 

. ";

%feature("docstring")  cmf::river::TriangularReach::get_length "double get_length() const

Length of the reach. ";

%feature("docstring")  cmf::river::TriangularReach::get_nManning "virtual double get_nManning() const ";

%feature("docstring")
cmf::river::TriangularReach::get_wetted_perimeter "virtual double
get_wetted_perimeter(double depth) const

Returns the wetted perimeter at a given depth 

.. math::

     P
    &=& 2 d \\\\sqrt{1+\\\\Delta^2} 

. ";

%feature("docstring")  cmf::river::TriangularReach::h "virtual double
h(double V) const

Returns the depth of a given volume. ";

%feature("docstring")  cmf::river::TriangularReach::q "virtual double
q(double h, double slope) const ";

%feature("docstring")  cmf::river::TriangularReach::qManning "virtual
double qManning(double A, double slope) const

Calculates the flow rate from a given water volume in the reach


.. math::

     q_{Manning}&=& A R^{\\\\frac 2 3}
    \\\\sqrt{\\\\frac {\\\\Delta_z} n} \\\\\\\\ A &=& \\\\frac V l
    \\\\mbox{, (Crosssectional area of the wetted crossection, Volume per
    length)} \\\\\\\\ R &=& \\\\frac A {P(d)} \\\\\\\\ P(d) &=& \\\\mbox{
    the perimeter of the wetted crosssection, a function of reach depth}
    \\\\\\\\ d(V) &=& \\\\mbox{ the depth of the reach a function of the
    volume} \\\\\\\\ \\\\Delta_z &=& \\\\frac{z_{max} - z_{min}}{l}
    \\\\mbox{ Slope of the reach} 

.

Flow rate [m3/s]

Parameters:
-----------

A:  The area of the cross section [m2]

slope:  The slope of the reach [m/m] ";

%feature("docstring")  cmf::river::TriangularReach::set_nManning "virtual void set_nManning(double nManning) ";

%feature("docstring")  cmf::river::TriangularReach::typecode "char
typecode() const ";

%feature("docstring")  cmf::river::TriangularReach::V "virtual double
V(double h) const ";


// File: classcmf__core_1_1_triangular_reach.xml
%feature("docstring") cmf_core::TriangularReach "

Structure for the description of reaches with a triangular cross
section.  Although double triangular cross section reach are rarely
met, a triangular reach does scale with its water load, and is
therefore preferable in case where nothing about IChannel geometry is
known  C++ includes: ReachType.h ";

%feature("docstring")  cmf_core::TriangularReach::__init__ "def
__init__(self, args)

__init__(cmf::river::TriangularReach self, double l, double
bankSlope=2) -> TriangularReach __init__(cmf::river::TriangularReach
self, TriangularReach copy) -> TriangularReach  TriangularReach(const
TriangularReach &copy) ";

%feature("docstring")  cmf_core::TriangularReach::A "def A(self,
args, kwargs)

A(IVolumeHeightFunction self, double V) -> double  virtual double
A(double V) const =0  Returns the area of the surface for a given
volume. ";

%feature("docstring")  cmf_core::TriangularReach::copy "def
copy(self, args, kwargs)

copy(TriangularReach self) -> TriangularReach  TriangularReach* copy()
const ";

%feature("docstring")  cmf_core::TriangularReach::get_channel_width "def get_channel_width(self, args, kwargs)

get_channel_width(IChannel self, double depth) -> double  virtual
double get_channel_width(double depth) const =0  Calculates the flow
width from a given actual depth [m] using the actual IChannel
geometry. ";

%feature("docstring")  cmf_core::TriangularReach::get_depth "def
get_depth(self, args, kwargs)

get_depth(IChannel self, double area) -> double  virtual double
get_depth(double area) const =0  Calculates the actual depth of the
reach using the IChannel geometry.  get_depth of the reach [m]
Parameters: -----------  area:  Wetted area of a river cross section
[m2], can be obtained by V/l, where V is the stored volume and l is
the reach length ";

%feature("docstring")  cmf_core::TriangularReach::get_flux_crossection
"def get_flux_crossection(self, args, kwargs)

get_flux_crossection(IChannel self, double depth) -> double  virtual
double get_flux_crossection(double depth) const =0  Calculates the
wetted area from a given depth using the IChannel geometry.  In most
cases use get_flux_crossection=V/l, where V is the stored volume and l
is the reach length Wetted area of a river cross section [m2]
Parameters: -----------  depth:  depth of the reach [m] ";

%feature("docstring")  cmf_core::TriangularReach::get_length "def
get_length(self, args, kwargs)

get_length(IChannel self) -> double  virtual double get_length() const
=0  Length of the reach. ";

%feature("docstring")  cmf_core::TriangularReach::get_nManning "def
get_nManning(self, args, kwargs)

get_nManning(IChannel self) -> double  virtual double get_nManning()
const =0 ";

%feature("docstring")  cmf_core::TriangularReach::get_wetted_perimeter
"def get_wetted_perimeter(self, args, kwargs)

get_wetted_perimeter(IChannel self, double depth) -> double  virtual
double get_wetted_perimeter(double depth) const =0  Calculates the
wetted perimeter from a given actual depth [m] using the actual
IChannel geometry. ";

%feature("docstring")  cmf_core::TriangularReach::h "def h(self,
args, kwargs)

h(IVolumeHeightFunction self, double V) -> double  virtual double
h(double V) const =0  Returns the depth of a given volume. ";

%feature("docstring")  cmf_core::TriangularReach::q "def q(self,
args, kwargs)

q(IVolumeHeightFunction self, double h, double slope) -> double
virtual double q(double h, double slope) const ";

%feature("docstring")  cmf_core::TriangularReach::qManning "def
qManning(self, args, kwargs)

qManning(IChannel self, double A, double slope) -> double  virtual
double qManning(double A, double slope) const  Calculates the flow
rate from a given water volume in the reach   .. math:: q_{Manning}&=&
A R^{\\\\\\\\frac 2 3}     \\\\\\\\sqrt{\\\\\\\\frac {\\\\\\\\Delta_z}
n} \\\\\\\\\\\\\\\\ A &=& \\\\\\\\frac V l \\\\\\\\mbox{,
(Crosssectional area of the wetted crossection, Volume per
length)} \\\\\\\\\\\\\\\\ R &=& \\\\\\\\frac A {P(d)} \\\\\\\\\\\\\\\\
P(d) &=& \\\\\\\\mbox{     the perimeter of the wetted crosssection, a
function of reach depth}     \\\\\\\\\\\\\\\\ d(V) &=& \\\\\\\\mbox{
the depth of the reach a function of the volume} \\\\\\\\\\\\\\\\
\\\\\\\\Delta_z &=& \\\\\\\\frac{z_{max} - z_{min}}{l}
\\\\\\\\mbox{ Slope of the reach}   .  Flow rate [m3/s]  Parameters:
-----------  A:  The area of the cross section [m2]  slope:  The slope
of the reach [m/m] ";

%feature("docstring")  cmf_core::TriangularReach::set_nManning "def
set_nManning(self, args, kwargs)

set_nManning(IChannel self, double val)  virtual void
set_nManning(double val)=0 ";

%feature("docstring")  cmf_core::TriangularReach::typecode "def
typecode(self, args, kwargs)

typecode(IChannel self) -> char  virtual char typecode() const =0 ";

%feature("docstring")  cmf_core::TriangularReach::V "def V(self,
args, kwargs)

V(IVolumeHeightFunction self, double h) -> double  virtual double
V(double h) const =0 ";


// File: classcmf_1_1upslope_1_1_e_t_1_1_turc_e_t.xml
%feature("docstring") cmf::upslope::ET::TurcET "

Calculates ETpot after Turc (DVWK).

:math:`ET_{act}` is calculated using a WaterStressFunction



.. math::

     ET_{pot,Turc} = 0.0031 C(rH) (R_G + 209) \\\\frac{T}{T + 15}
    

where:  :math:`T` is the mean daily temperature

:math:`C(rH) = \\\\begin{cases} 1 + \\\\frac{50\\\\% - rH}{70\\\\%}, & rH < 50\\\\% \\\\\\\\ 1 & rH > 50\\\\% \\\\end{cases}`, a modification
parameter for low humidity

:math:`rH` relative Humidity in %

:math:`R_G` global radiation in :math:`J/cm^2`

C++ includes: ET.h ";

%feature("docstring")  cmf::upslope::ET::TurcET::TurcET "TurcET(cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr
ET_target) ";

%feature("docstring")  cmf::upslope::ET::TurcET::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")  cmf::upslope::ET::TurcET::ETpot "real
ETpot(cmf::math::Time t) const ";

%feature("docstring")  cmf::upslope::ET::TurcET::exchange_target "void exchange_target(flux_node::ptr oldtarget, flux_node::ptr
newTarget) ";

%feature("docstring")  cmf::upslope::ET::TurcET::get_layer "SoilLayer::ptr get_layer() const ";

%feature("docstring")  cmf::upslope::ET::TurcET::get_ptr "ptr
get_ptr() const ";

%feature("docstring")  cmf::upslope::ET::TurcET::get_target "flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::upslope::ET::TurcET::get_target "flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")  cmf::upslope::ET::TurcET::get_tracer_filter "real get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")  cmf::upslope::ET::TurcET::get_tracer_filter "real get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::upslope::ET::TurcET::kill_me "bool
kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::upslope::ET::TurcET::left_node "flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::upslope::ET::TurcET::q "real q(const
flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::upslope::ET::TurcET::refresh "void
refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::upslope::ET::TurcET::right_node "flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")  cmf::upslope::ET::TurcET::set_stressfunction "void set_stressfunction(const RootUptakeStessFunction &stressfunction)

Sets the stress function to limit water uptake. ";

%feature("docstring")  cmf::upslope::ET::TurcET::set_tracer_filter "void set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")  cmf::upslope::ET::TurcET::set_tracer_filter "void set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf::upslope::ET::TurcET::short_string "virtual std::string short_string() const ";

%feature("docstring")  cmf::upslope::ET::TurcET::to_string "std::string to_string() const ";


// File: classcmf__core_1_1_turc_e_t.xml
%feature("docstring") cmf_core::TurcET "

Calculates ETpot after Turc (DVWK).  ETact is calculated using a
WaterStressFunction  :math:`ET_{pot,Turc} = 0.0031 C (R_G + 209)
\\\\\\\\frac{T}{T + 15}`  C++ includes: ET.h ";

%feature("docstring")  cmf_core::TurcET::__init__ "def __init__(self,
args, kwargs)

__init__(cmf::upslope::ET::TurcET self, cmf::upslope::SoilLayer::ptr
source, cmf::water::flux_node::ptr ET_target) -> TurcET
TurcET(cmf::upslope::SoilLayer::ptr source, cmf::water::flux_node::ptr
ET_target) ";

%feature("docstring")  cmf_core::TurcET::__contains__ "def
__contains__(self, cmp) ";

%feature("docstring")  cmf_core::TurcET::__eq__ "def __eq__(self,
args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::TurcET::__getitem__ "def
__getitem__(self, index) ";

%feature("docstring")  cmf_core::TurcET::__iter__ "def __iter__(self)
";

%feature("docstring")  cmf_core::TurcET::__repr__ "def __repr__(self)
";

%feature("docstring")  cmf_core::TurcET::conc "def conc(self, args,
kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")  cmf_core::TurcET::ETpot "def ETpot(self, args,
kwargs)

ETpot(stressedET self, Time t) -> real  virtual real
ETpot(cmf::math::Time t) const ";

%feature("docstring")  cmf_core::TurcET::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::TurcET::get_layer "def
get_layer(self, args, kwargs)

get_layer(stressedET self) -> cmf::upslope::SoilLayer::ptr
SoilLayer::ptr get_layer() const ";

%feature("docstring")  cmf_core::TurcET::get_target "def
get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")  cmf_core::TurcET::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::TurcET::kill_me "def kill_me(self,
args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::TurcET::left_node "def
left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::TurcET::q "def q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::TurcET::refresh "def refresh(self,
args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::TurcET::right_node "def
right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")  cmf_core::TurcET::set_stressfunction "def
set_stressfunction(self, args, kwargs)

set_stressfunction(stressedET self, RootUptakeStessFunction
stressfunction)  void set_stressfunction(const RootUptakeStessFunction
&stressfunction)  Sets the stress function to limit water uptake. ";

%feature("docstring")  cmf_core::TurcET::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::TurcET::short_string "def
short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::TurcET::to_string "def
to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::TurcET::use_for_cell "def
use_for_cell(args, kwargs)

use_for_cell(Cell cell) ";


// File: classcmf__core_1_1_van_genuchten_mualem.xml
%feature("docstring") cmf_core::VanGenuchtenMualem "

Provides the use of the Van Genuchten - Mualem retention curve (Van
Genuchten 1980)  Head - moisture relationship:   .. math::
W(\\\\\\\\theta) &=&     \\\\\\\\frac{\\\\\\\\theta -
\\\\\\\\theta_r}{\\\\\\\\theta_s - \\\\\\\\theta_r} \\\\\\\\\\\\\\\\
K(W) &=& K_{sat} \\\\\\\\sqrt{W}
\\\\\\\\left(1-\\\\\\\\left(1-W^{1/m}\\\\\\\\right)^m\\\\\\\\right)^2
\\\\\\\\\\\\\\\\ m &=&     1-\\\\\\\\frac 1 n \\\\\\\\\\\\\\\\
\\\\\\\\Psi(W) &=& 0.01 \\\\\\\\frac{m}{cm}
\\\\\\\\frac{{\\\\\\\\left(1-{W}^{\\\\\\\\frac{1}{m}}\\\\\\\\right)
}^{\\\\\\\\frac{1}{n}}}{\\\\\\\\alpha\\\\\\\\,{W}^{\\\\\\\\frac{1}{m\\\\\\\\,n}}}
\\\\\\\\\\\\\\\\     W(\\\\\\\\Psi) &=&
\\\\\\\\left(1+\\\\\\\\left(\\\\\\\\alpha\\\\\\\\,100\\\\\\\\frac{cm}{m}\\\\\\\\Psi\\\\\\\\right)^n\\\\\\\\right)^{-m}
where:  :math:`K` is the conductivity in :math:`\\\\\\\\frac m{day}`
:math:`W` is the wetness (Volume of soil water per volume of pores)
:math:`n` is a shape parameter of the retention curve
:math:`\\\\\\\\alpha` is inverse of the air entry potential in
:math:`cm^{-1}`  :math:`\\\\\\\\Psi(W)` is the matric potential in
:math:`m H_2O` at wetness W  C++ includes: RetentionCurve.h ";

%feature("docstring")  cmf_core::VanGenuchtenMualem::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::VanGenuchtenMualem self, real Ksat=15, real
phi=0.5, real alpha=0.2178, real n=1.211, real m=-1, real theta_r=0.0,
real w0=0.99) -> VanGenuchtenMualem  VanGenuchtenMualem(real Ksat=15,
real phi=0.5, real alpha=0.2178, real n=1.211, real m=-1, real
theta_r=0.0, real w0=0.99)  Creates a van Genuchten-Mualem retention
curve.  Parameters: -----------  Ksat:  Saturated conductivity in
:math:`\\\\\\\\frac m{day}`  phi:  Porosity in :math:`\\\\\\\\frac{m^3
Pores}{m^3 Soil}`  alpha:  Van Genuchten :math:`\\\\\\\\alpha` in
:math:`\\\\\\\\frac 1{cm}`  n:  Van Genuchten n  m:  Van Genuchten m
parameter, if negative m is calculated as :math:`1-\\\\\\\\frac 1 n`
theta_r:  Water content for
:math:`\\\\\\\\lim\\\\\\\\limits_{\\\\\\\\Psi_M \\\\\\\\rightarrow
-\\\\\\\\infty}{\\\\\\\\theta(\\\\\\\\Psi_M)}`  w0:  Wetness above the
parabolic extrapolation is used instead of the Van Genuchten curve
(usually calculated with fit_w0) ";

%feature("docstring")  cmf_core::VanGenuchtenMualem::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::VanGenuchtenMualem::__str__ "def
__str__(self) ";

%feature("docstring")  cmf_core::VanGenuchtenMualem::copy "def
copy(self, args, kwargs)

copy(VanGenuchtenMualem self) -> VanGenuchtenMualem
VanGenuchtenMualem* copy() const ";

%feature("docstring")  cmf_core::VanGenuchtenMualem::Diffusivity "def
Diffusivity(self, args)

Diffusivity(RetentionCurve self, real wetness) -> real
Diffusivity(RetentionCurve self, cmf::math::num_array & wetness) ->
cmf::math::num_array  cmf::math::num_array
Diffusivity(cmf::math::num_array &wetness) ";

%feature("docstring")  cmf_core::VanGenuchtenMualem::dPsiM_dW "def
dPsiM_dW(self, args)

dPsiM_dW(RetentionCurve self, real wetness) -> real
dPsiM_dW(RetentionCurve self, cmf::math::num_array const & wetness) ->
cmf::math::num_array  cmf::math::num_array dPsiM_dW(const
cmf::math::num_array &wetness) const ";

%feature("docstring")  cmf_core::VanGenuchtenMualem::FillHeight "def
FillHeight(self, args, kwargs)

FillHeight(RetentionCurve self, real lowerDepth, real Area, real
Volume) -> real  virtual real FillHeight(real lowerDepth, real Area,
real Volume) const  Returns the thickness of a soil column with a
certain pore volume. ";

%feature("docstring")  cmf_core::VanGenuchtenMualem::fit_w0 "def
fit_w0(self, args, kwargs)

fit_w0(VanGenuchtenMualem self, real w1=1.01, real Psi_p=1.0, real
tolerance=0.05) -> real  real fit_w0(real w1=1.01, real Psi_p=1.0,
real tolerance=0.05)  Fits the break point wetness w0, to ensure a
specific oversaturation at a given hydrostatic potential.  Parameters:
-----------  w1:  The oversaturation wetness to archieve (>1), default
= 1.01  Psi_p:  the hydrostatic potential for w1, default = +1.0 m
tolerance: ";

%feature("docstring")  cmf_core::VanGenuchtenMualem::K "def K(self,
args)

K(RetentionCurve self, real wetness) -> real K(RetentionCurve self,
cmf::math::num_array const & wetness) -> cmf::math::num_array
cmf::math::num_array K(const cmf::math::num_array &wetness) const ";

%feature("docstring")  cmf_core::VanGenuchtenMualem::MatricPotential "def MatricPotential(self, args)

MatricPotential(RetentionCurve self, real wetness) -> real
MatricPotential(RetentionCurve self, cmf::math::num_array const &
wetness) -> cmf::math::num_array  cmf::math::num_array
MatricPotential(const cmf::math::num_array &wetness) const ";

%feature("docstring")  cmf_core::VanGenuchtenMualem::Porosity "def
Porosity(self, args, kwargs)

Porosity(RetentionCurve self, real depth=0.0) -> real  virtual real
Porosity(real depth=0.0) const =0  Returns the porosity at a certain
depth. ";

%feature("docstring")  cmf_core::VanGenuchtenMualem::theta "def
theta(self, args)

theta(RetentionCurve self, real wetness) -> real theta(RetentionCurve
self, cmf::math::num_array const & wetness) -> cmf::math::num_array
cmf::math::num_array theta(const cmf::math::num_array &wetness) const
";

%feature("docstring")  cmf_core::VanGenuchtenMualem::Transmissivity "def Transmissivity(self, args, kwargs)

Transmissivity(VanGenuchtenMualem self, real upperDepth, real
lowerDepth, real wetness) -> real  virtual real Transmissivity(real
upperDepth, real lowerDepth, real wetness) const ";

%feature("docstring")  cmf_core::VanGenuchtenMualem::VoidVolume "def
VoidVolume(self, args, kwargs)

VoidVolume(RetentionCurve self, real upperDepth, real lowerDepth, real
Area) -> real  virtual real VoidVolume(real upperDepth, real
lowerDepth, real Area) const  Returns the void volume of a soil
column. ";

%feature("docstring")  cmf_core::VanGenuchtenMualem::Wetness "def
Wetness(self, args)

Wetness(RetentionCurve self, real suction) -> real
Wetness(RetentionCurve self, cmf::math::num_array const & suction) ->
cmf::math::num_array  cmf::math::num_array Wetness(const
cmf::math::num_array &suction) const ";

%feature("docstring")  cmf_core::VanGenuchtenMualem::Wetness_eff "def
Wetness_eff(self, args, kwargs)

Wetness_eff(RetentionCurve self, real wetness, real pF_r=4.2) -> real
virtual real Wetness_eff(real wetness, real pF_r=4.2) const  Returns
the effective wetness, using a residual pF value   .. math:: w_{eff}
=
\\\\\\\\frac{w_{act}-w\\\\\\\\left(pF_r\\\\\\\\right)}{1-w\\\\\\\\left(pF_r\\\\\\\\right)}
. ";

%feature("docstring")  cmf_core::VanGenuchtenMualem::Wetness_pF "def
Wetness_pF(self, args)

Wetness_pF(RetentionCurve self, real pF) -> real
Wetness_pF(RetentionCurve self, cmf::math::num_array const & pF) ->
cmf::math::num_array  cmf::math::num_array Wetness_pF(const
cmf::math::num_array &pF) const ";


// File: classcmf_1_1upslope_1_1_van_genuchten_mualem.xml
%feature("docstring") cmf::upslope::VanGenuchtenMualem "

Provides the use of the Van Genuchten - Mualem retention curve (Van
Genuchten 1980)

Head - moisture relationship: 

.. math::

     W(\\\\theta) &=&
    \\\\frac{\\\\theta - \\\\theta_r}{\\\\theta_s - \\\\theta_r} \\\\\\\\
    K(W) &=& K_{sat} \\\\sqrt{W}
    \\\\left(1-\\\\left(1-W^{1/m}\\\\right)^m\\\\right)^2 \\\\\\\\ m &=&
    1-\\\\frac 1 n \\\\\\\\ \\\\Psi(W) &=& 0.01 \\\\frac{m}{cm}
    \\\\frac{{\\\\left(1-{W}^{\\\\frac{1}{m}}\\\\right)
    }^{\\\\frac{1}{n}}}{\\\\alpha\\\\,{W}^{\\\\frac{1}{m\\\\,n}}} \\\\\\\\
    W(\\\\Psi) &=&
    \\\\left(1+\\\\left(\\\\alpha\\\\,100\\\\frac{cm}{m}\\\\Psi\\\\right)^n\\\\right)^{-m}
    

 where:  :math:`K` is the conductivity in :math:`\\\\frac m{day}`

:math:`W` is the wetness (Volume of soil water per volume of pores)

:math:`n` is a shape parameter of the retention curve

:math:`\\\\alpha` is inverse of the air entry potential in :math:`cm^{-1}`

:math:`\\\\Psi(W)` is the matric potential in :math:`m H_2O` at wetness W

C++ includes: RetentionCurve.h ";

%feature("docstring")
cmf::upslope::VanGenuchtenMualem::VanGenuchtenMualem "VanGenuchtenMualem(real Ksat=15, real phi=0.5, real alpha=0.2178, real
n=1.211, real m=-1, real theta_r=0.0, real w0=0.99)

Creates a van Genuchten-Mualem retention curve.

Parameters:
-----------

Ksat:  Saturated conductivity in :math:`\\\\frac m{day}`

phi:  Porosity in :math:`\\\\frac{m^3 Pores}{m^3 Soil}`

alpha:  Van Genuchten :math:`\\\\alpha` in :math:`\\\\frac 1{cm}`

n:  Van Genuchten n

m:  Van Genuchten m parameter, if negative m is calculated as :math:`1-\\\\frac 1 n`

theta_r:  Water content for :math:`\\\\lim\\\\limits_{\\\\Psi_M \\\\rightarrow -\\\\infty}{\\\\theta(\\\\Psi_M)}`

w0:  Wetness above the parabolic extrapolation is used instead of the
Van Genuchten curve (usually calculated with fit_w0) ";

%feature("docstring")
cmf::upslope::VanGenuchtenMualem::~VanGenuchtenMualem "virtual
~VanGenuchtenMualem() ";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::copy "VanGenuchtenMualem* copy() const ";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::Diffusivity "cmf::math::num_array Diffusivity(cmf::math::num_array &wetness) ";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::Diffusivity "virtual real Diffusivity(real wetness) const

Returns the diffusivity of the soil according to its wetness as given
by VanGenuchten 1980.

Deprecated The current implementation goes to infinity at saturation,
as noted by VanGenuchten. Diffusivity is therefore currently not
usable in any model.



.. math::

    D(W) = K(W)\\\\left|\\\\frac{d\\\\Psi}{d\\\\theta}\\\\right|\\\\
    eq. 10

where:  :math:`D(W)` Diffusivity in :math:`m^2/day`

:math:`K(W)` Conductivity as a function of saturation W in m/day

:math:`\\\\Psi` Pressure head

:math:`\\\\theta` water content of the soil

Applying Van Genuchten theory (Van Genuchten 1980) yields to:


.. math::

    D(W) = \\\\frac{(1-m)K_{sat}}{\\\\alpha m \\\\Phi}
    W^{l-1/m}\\\\left(\\\\left(1-W^{1/m}\\\\right)^{-m} +
    \\\\left(1-W^{1/m}\\\\right)^{m} -2\\\\right)

where:  :math:`m = 1 - \\\\frac 1 n` acc. Mualem theory

:math:`K_{sat}` saturated conductivity in m/day

:math:`\\\\alpha` inverse water entry potential in 1/m. Note :math:`\\\\alpha` is
given in cmf in 1/cm

:math:`\\\\Phi` porosity

:math:`W = \\\\frac{\\\\theta - \\\\theta_r}{\\\\Phi - \\\\theta_r}`
saturation of the soil ";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::dPsiM_dW "cmf::math::num_array dPsiM_dW(const cmf::math::num_array &wetness)
const ";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::dPsiM_dW "virtual real dPsiM_dW(real wetness) const

returns :math:`\\\\tfrac{d\\\\Psi_M}{dW}`



.. math::

    \\\\frac{0.01 w^{\\\\frac{1}{m}} w^{- \\\\frac{1}{m n}}
    \\\\left(- w^{\\\\frac{1}{m}} +
    1\\\\right)^{\\\\frac{1}{n}}}{\\\\alpha m n w \\\\left(-
    w^{\\\\frac{1}{m}} + 1\\\\right)} + \\\\frac{0.01 w^{- \\\\frac{1}{m
    n}} \\\\left(- w^{\\\\frac{1}{m}} +
    1\\\\right)^{\\\\frac{1}{n}}}{\\\\alpha m n w}

";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::FillHeight "virtual real FillHeight(real lowerDepth, real Area, real Volume) const

Returns the thickness of a soil column with a certain pore volume. ";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::fit_w0 "real
fit_w0(real w1=1.01, real Psi_p=1.0, real tolerance=0.05)

Fits the break point wetness w0, to ensure a specific oversaturation
at a given hydrostatic potential.

Parameters:
-----------

w1:  The oversaturation wetness to archieve (>1), default = 1.01

Psi_p:  the hydrostatic potential for w1, default = +1.0 m

tolerance:  ";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::K "cmf::math::num_array K(const cmf::math::num_array &wetness) const ";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::K "virtual
real K(real wetness) const

returns the conductivity of the soil at a given saturation



.. math::

    K(W) = K_{sat} \\\\sqrt{W}
    \\\\left(1-\\\\left(1-W^{1/m}\\\\right)^m\\\\right)^2 

";

%feature("docstring")
cmf::upslope::VanGenuchtenMualem::MatricPotential "cmf::math::num_array MatricPotential(const cmf::math::num_array
&wetness) const ";

%feature("docstring")
cmf::upslope::VanGenuchtenMualem::MatricPotential "virtual real
MatricPotential(real wetness) const

returns the matrix potential at a given saturation



.. math::

    \\\\Psi(W) = 0.01 \\\\frac{m}{cm}
    \\\\frac{{\\\\left(1-{W}^{\\\\frac{1}{m}}\\\\right)
    }^{\\\\frac{1}{n}}}{\\\\alpha\\\\,{W}^{\\\\frac{1}{m\\\\,n}}} 

";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::Porosity "virtual real Porosity(real depth) const

Returns the porosity at a certain depth. ";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::theta "cmf::math::num_array theta(const cmf::math::num_array &wetness) const
";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::theta "virtual real theta(real wetness) const

returns the water content :math:`theta` for a given wetness ";

%feature("docstring")
cmf::upslope::VanGenuchtenMualem::Transmissivity "virtual real
Transmissivity(real upperDepth, real lowerDepth, real wetness) const
";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::VoidVolume "virtual real VoidVolume(real upperDepth, real lowerDepth, real Area)
const

Returns the void volume of a soil column. ";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::Wetness "cmf::math::num_array Wetness(const cmf::math::num_array &suction)
const ";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::Wetness "virtual real Wetness(real suction) const

returns the saturation at a given suction (matrix potential).



.. math::

     W(\\\\Psi) =
    \\\\left(1+\\\\left(\\\\alpha\\\\,100\\\\frac{cm}{m}\\\\Psi\\\\right)^n\\\\right)^{-m}
    

";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::Wetness_eff "virtual real Wetness_eff(real wetness, real pF_r=4.2) const

Returns the effective wetness, using a residual pF value 

.. math::

    w_{eff}
    =
    \\\\frac{w_{act}-w\\\\left(pF_r\\\\right)}{1-w\\\\left(pF_r\\\\right)}

.
";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::Wetness_pF "real Wetness_pF(real pF) const

returns the volumetric water content at a given pF value ";

%feature("docstring")  cmf::upslope::VanGenuchtenMualem::Wetness_pF "cmf::math::num_array Wetness_pF(const cmf::math::num_array &pF) const
";


// File: classcmf__core_1_1vector__double.xml
%feature("docstring") cmf_core::vector_double "

Proxy of C++ std::vector<(double)> class. ";

%feature("docstring")  cmf_core::vector_double::__init__ "def
__init__(self, args)

__init__(std::vector<(double)> self) -> vector_double
__init__(std::vector<(double)> self, vector_double arg2) ->
vector_double __init__(std::vector<(double)> self, std::vector< double
>::size_type size) -> vector_double __init__(std::vector<(double)>
self, std::vector< double >::size_type size, std::vector< double
>::value_type const & value) -> vector_double ";

%feature("docstring")  cmf_core::vector_double::__bool__ "def
__bool__(self, args, kwargs)

__bool__(vector_double self) -> bool ";

%feature("docstring")  cmf_core::vector_double::__delitem__ "def
__delitem__(self, args)

__delitem__(vector_double self, std::vector< double >::difference_type
i) __delitem__(vector_double self, PySliceObject * slice) ";

%feature("docstring")  cmf_core::vector_double::__delslice__ "def
__delslice__(self, args, kwargs)

__delslice__(vector_double self, std::vector< double
>::difference_type i, std::vector< double >::difference_type j) ";

%feature("docstring")  cmf_core::vector_double::__getitem__ "def
__getitem__(self, args)

__getitem__(vector_double self, PySliceObject * slice) ->
vector_double __getitem__(vector_double self, std::vector< double
>::difference_type i) -> std::vector< double >::value_type const & ";

%feature("docstring")  cmf_core::vector_double::__getslice__ "def
__getslice__(self, args, kwargs)

__getslice__(vector_double self, std::vector< double
>::difference_type i, std::vector< double >::difference_type j) ->
vector_double ";

%feature("docstring")  cmf_core::vector_double::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::vector_double::__len__ "def
__len__(self, args, kwargs)

__len__(vector_double self) -> std::vector< double >::size_type ";

%feature("docstring")  cmf_core::vector_double::__nonzero__ "def
__nonzero__(self, args, kwargs)

__nonzero__(vector_double self) -> bool ";

%feature("docstring")  cmf_core::vector_double::__setitem__ "def
__setitem__(self, args)

__setitem__(vector_double self, PySliceObject * slice, vector_double
v) __setitem__(vector_double self, PySliceObject * slice)
__setitem__(vector_double self, std::vector< double >::difference_type
i, std::vector< double >::value_type const & x) ";

%feature("docstring")  cmf_core::vector_double::__setslice__ "def
__setslice__(self, args)

__setslice__(vector_double self, std::vector< double
>::difference_type i, std::vector< double >::difference_type j)
__setslice__(vector_double self, std::vector< double
>::difference_type i, std::vector< double >::difference_type j,
vector_double v) ";

%feature("docstring")  cmf_core::vector_double::append "def
append(self, args, kwargs)

append(vector_double self, std::vector< double >::value_type const &
x) ";

%feature("docstring")  cmf_core::vector_double::assign "def
assign(self, args, kwargs)

assign(vector_double self, std::vector< double >::size_type n,
std::vector< double >::value_type const & x) ";

%feature("docstring")  cmf_core::vector_double::back "def back(self,
args, kwargs)

back(vector_double self) -> std::vector< double >::value_type const &
";

%feature("docstring")  cmf_core::vector_double::begin "def
begin(self, args, kwargs)

begin(vector_double self) -> std::vector< double >::iterator ";

%feature("docstring")  cmf_core::vector_double::capacity "def
capacity(self, args, kwargs)

capacity(vector_double self) -> std::vector< double >::size_type ";

%feature("docstring")  cmf_core::vector_double::clear "def
clear(self, args, kwargs)

clear(vector_double self) ";

%feature("docstring")  cmf_core::vector_double::empty "def
empty(self, args, kwargs)

empty(vector_double self) -> bool ";

%feature("docstring")  cmf_core::vector_double::end "def end(self,
args, kwargs)

end(vector_double self) -> std::vector< double >::iterator ";

%feature("docstring")  cmf_core::vector_double::erase "def
erase(self, args)

erase(vector_double self, std::vector< double >::iterator pos) ->
std::vector< double >::iterator erase(vector_double self, std::vector<
double >::iterator first, std::vector< double >::iterator last) ->
std::vector< double >::iterator ";

%feature("docstring")  cmf_core::vector_double::front "def
front(self, args, kwargs)

front(vector_double self) -> std::vector< double >::value_type const &
";

%feature("docstring")  cmf_core::vector_double::get_allocator "def
get_allocator(self, args, kwargs)

get_allocator(vector_double self) -> std::vector< double
>::allocator_type ";

%feature("docstring")  cmf_core::vector_double::insert "def
insert(self, args)

insert(vector_double self, std::vector< double >::iterator pos,
std::vector< double >::value_type const & x) -> std::vector< double
>::iterator insert(vector_double self, std::vector< double >::iterator
pos, std::vector< double >::size_type n, std::vector< double
>::value_type const & x) ";

%feature("docstring")  cmf_core::vector_double::iterator "def
iterator(self, args, kwargs)

iterator(vector_double self) -> SwigPyIterator ";

%feature("docstring")  cmf_core::vector_double::pop "def pop(self,
args, kwargs)

pop(vector_double self) -> std::vector< double >::value_type ";

%feature("docstring")  cmf_core::vector_double::pop_back "def
pop_back(self, args, kwargs)

pop_back(vector_double self) ";

%feature("docstring")  cmf_core::vector_double::push_back "def
push_back(self, args, kwargs)

push_back(vector_double self, std::vector< double >::value_type const
& x) ";

%feature("docstring")  cmf_core::vector_double::rbegin "def
rbegin(self, args, kwargs)

rbegin(vector_double self) -> std::vector< double >::reverse_iterator
";

%feature("docstring")  cmf_core::vector_double::rend "def rend(self,
args, kwargs)

rend(vector_double self) -> std::vector< double >::reverse_iterator ";

%feature("docstring")  cmf_core::vector_double::reserve "def
reserve(self, args, kwargs)

reserve(vector_double self, std::vector< double >::size_type n) ";

%feature("docstring")  cmf_core::vector_double::resize "def
resize(self, args)

resize(vector_double self, std::vector< double >::size_type new_size)
resize(vector_double self, std::vector< double >::size_type new_size,
std::vector< double >::value_type const & x) ";

%feature("docstring")  cmf_core::vector_double::size "def size(self,
args, kwargs)

size(vector_double self) -> std::vector< double >::size_type ";

%feature("docstring")  cmf_core::vector_double::swap "def swap(self,
args, kwargs)

swap(vector_double self, vector_double v) ";


// File: classcmf__core_1_1vector__int.xml
%feature("docstring") cmf_core::vector_int "

Proxy of C++ std::vector<(int)> class. ";

%feature("docstring")  cmf_core::vector_int::__init__ "def
__init__(self, args)

__init__(std::vector<(int)> self) -> vector_int
__init__(std::vector<(int)> self, vector_int arg2) -> vector_int
__init__(std::vector<(int)> self, std::vector< int >::size_type size)
-> vector_int __init__(std::vector<(int)> self, std::vector< int
>::size_type size, std::vector< int >::value_type const & value) ->
vector_int ";

%feature("docstring")  cmf_core::vector_int::__bool__ "def
__bool__(self, args, kwargs)

__bool__(vector_int self) -> bool ";

%feature("docstring")  cmf_core::vector_int::__delitem__ "def
__delitem__(self, args)

__delitem__(vector_int self, std::vector< int >::difference_type i)
__delitem__(vector_int self, PySliceObject * slice) ";

%feature("docstring")  cmf_core::vector_int::__delslice__ "def
__delslice__(self, args, kwargs)

__delslice__(vector_int self, std::vector< int >::difference_type i,
std::vector< int >::difference_type j) ";

%feature("docstring")  cmf_core::vector_int::__getitem__ "def
__getitem__(self, args)

__getitem__(vector_int self, PySliceObject * slice) -> vector_int
__getitem__(vector_int self, std::vector< int >::difference_type i) ->
std::vector< int >::value_type const & ";

%feature("docstring")  cmf_core::vector_int::__getslice__ "def
__getslice__(self, args, kwargs)

__getslice__(vector_int self, std::vector< int >::difference_type i,
std::vector< int >::difference_type j) -> vector_int ";

%feature("docstring")  cmf_core::vector_int::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::vector_int::__len__ "def
__len__(self, args, kwargs)

__len__(vector_int self) -> std::vector< int >::size_type ";

%feature("docstring")  cmf_core::vector_int::__nonzero__ "def
__nonzero__(self, args, kwargs)

__nonzero__(vector_int self) -> bool ";

%feature("docstring")  cmf_core::vector_int::__setitem__ "def
__setitem__(self, args)

__setitem__(vector_int self, PySliceObject * slice, vector_int v)
__setitem__(vector_int self, PySliceObject * slice)
__setitem__(vector_int self, std::vector< int >::difference_type i,
std::vector< int >::value_type const & x) ";

%feature("docstring")  cmf_core::vector_int::__setslice__ "def
__setslice__(self, args)

__setslice__(vector_int self, std::vector< int >::difference_type i,
std::vector< int >::difference_type j) __setslice__(vector_int self,
std::vector< int >::difference_type i, std::vector< int
>::difference_type j, vector_int v) ";

%feature("docstring")  cmf_core::vector_int::append "def append(self,
args, kwargs)

append(vector_int self, std::vector< int >::value_type const & x) ";

%feature("docstring")  cmf_core::vector_int::assign "def assign(self,
args, kwargs)

assign(vector_int self, std::vector< int >::size_type n, std::vector<
int >::value_type const & x) ";

%feature("docstring")  cmf_core::vector_int::back "def back(self,
args, kwargs)

back(vector_int self) -> std::vector< int >::value_type const & ";

%feature("docstring")  cmf_core::vector_int::begin "def begin(self,
args, kwargs)

begin(vector_int self) -> std::vector< int >::iterator ";

%feature("docstring")  cmf_core::vector_int::capacity "def
capacity(self, args, kwargs)

capacity(vector_int self) -> std::vector< int >::size_type ";

%feature("docstring")  cmf_core::vector_int::clear "def clear(self,
args, kwargs)

clear(vector_int self) ";

%feature("docstring")  cmf_core::vector_int::empty "def empty(self,
args, kwargs)

empty(vector_int self) -> bool ";

%feature("docstring")  cmf_core::vector_int::end "def end(self, args,
kwargs)

end(vector_int self) -> std::vector< int >::iterator ";

%feature("docstring")  cmf_core::vector_int::erase "def erase(self,
args)

erase(vector_int self, std::vector< int >::iterator pos) ->
std::vector< int >::iterator erase(vector_int self, std::vector< int
>::iterator first, std::vector< int >::iterator last) -> std::vector<
int >::iterator ";

%feature("docstring")  cmf_core::vector_int::front "def front(self,
args, kwargs)

front(vector_int self) -> std::vector< int >::value_type const & ";

%feature("docstring")  cmf_core::vector_int::get_allocator "def
get_allocator(self, args, kwargs)

get_allocator(vector_int self) -> std::vector< int >::allocator_type
";

%feature("docstring")  cmf_core::vector_int::insert "def insert(self,
args)

insert(vector_int self, std::vector< int >::iterator pos, std::vector<
int >::value_type const & x) -> std::vector< int >::iterator
insert(vector_int self, std::vector< int >::iterator pos, std::vector<
int >::size_type n, std::vector< int >::value_type const & x) ";

%feature("docstring")  cmf_core::vector_int::iterator "def
iterator(self, args, kwargs)

iterator(vector_int self) -> SwigPyIterator ";

%feature("docstring")  cmf_core::vector_int::pop "def pop(self, args,
kwargs)

pop(vector_int self) -> std::vector< int >::value_type ";

%feature("docstring")  cmf_core::vector_int::pop_back "def
pop_back(self, args, kwargs)

pop_back(vector_int self) ";

%feature("docstring")  cmf_core::vector_int::push_back "def
push_back(self, args, kwargs)

push_back(vector_int self, std::vector< int >::value_type const & x)
";

%feature("docstring")  cmf_core::vector_int::rbegin "def rbegin(self,
args, kwargs)

rbegin(vector_int self) -> std::vector< int >::reverse_iterator ";

%feature("docstring")  cmf_core::vector_int::rend "def rend(self,
args, kwargs)

rend(vector_int self) -> std::vector< int >::reverse_iterator ";

%feature("docstring")  cmf_core::vector_int::reserve "def
reserve(self, args, kwargs)

reserve(vector_int self, std::vector< int >::size_type n) ";

%feature("docstring")  cmf_core::vector_int::resize "def resize(self,
args)

resize(vector_int self, std::vector< int >::size_type new_size)
resize(vector_int self, std::vector< int >::size_type new_size,
std::vector< int >::value_type const & x) ";

%feature("docstring")  cmf_core::vector_int::size "def size(self,
args, kwargs)

size(vector_int self) -> std::vector< int >::size_type ";

%feature("docstring")  cmf_core::vector_int::swap "def swap(self,
args, kwargs)

swap(vector_int self, vector_int v) ";


// File: classcmf__core_1_1vector__size__t.xml
%feature("docstring") cmf_core::vector_size_t "

Proxy of C++ std::vector<(size_t)> class. ";

%feature("docstring")  cmf_core::vector_size_t::__init__ "def
__init__(self, args)

__init__(std::vector<(size_t)> self) -> vector_size_t
__init__(std::vector<(size_t)> self, vector_size_t arg2) ->
vector_size_t __init__(std::vector<(size_t)> self, std::vector< size_t
>::size_type size) -> vector_size_t __init__(std::vector<(size_t)>
self, std::vector< size_t >::size_type size, std::vector< size_t
>::value_type const & value) -> vector_size_t ";

%feature("docstring")  cmf_core::vector_size_t::__bool__ "def
__bool__(self, args, kwargs)

__bool__(vector_size_t self) -> bool ";

%feature("docstring")  cmf_core::vector_size_t::__delitem__ "def
__delitem__(self, args)

__delitem__(vector_size_t self, std::vector< size_t >::difference_type
i) __delitem__(vector_size_t self, PySliceObject * slice) ";

%feature("docstring")  cmf_core::vector_size_t::__delslice__ "def
__delslice__(self, args, kwargs)

__delslice__(vector_size_t self, std::vector< size_t
>::difference_type i, std::vector< size_t >::difference_type j) ";

%feature("docstring")  cmf_core::vector_size_t::__getitem__ "def
__getitem__(self, args)

__getitem__(vector_size_t self, PySliceObject * slice) ->
vector_size_t __getitem__(vector_size_t self, std::vector< size_t
>::difference_type i) -> std::vector< size_t >::value_type const & ";

%feature("docstring")  cmf_core::vector_size_t::__getslice__ "def
__getslice__(self, args, kwargs)

__getslice__(vector_size_t self, std::vector< size_t
>::difference_type i, std::vector< size_t >::difference_type j) ->
vector_size_t ";

%feature("docstring")  cmf_core::vector_size_t::__iter__ "def
__iter__(self) ";

%feature("docstring")  cmf_core::vector_size_t::__len__ "def
__len__(self, args, kwargs)

__len__(vector_size_t self) -> std::vector< size_t >::size_type ";

%feature("docstring")  cmf_core::vector_size_t::__nonzero__ "def
__nonzero__(self, args, kwargs)

__nonzero__(vector_size_t self) -> bool ";

%feature("docstring")  cmf_core::vector_size_t::__setitem__ "def
__setitem__(self, args)

__setitem__(vector_size_t self, PySliceObject * slice, vector_size_t
v) __setitem__(vector_size_t self, PySliceObject * slice)
__setitem__(vector_size_t self, std::vector< size_t >::difference_type
i, std::vector< size_t >::value_type const & x) ";

%feature("docstring")  cmf_core::vector_size_t::__setslice__ "def
__setslice__(self, args)

__setslice__(vector_size_t self, std::vector< size_t
>::difference_type i, std::vector< size_t >::difference_type j)
__setslice__(vector_size_t self, std::vector< size_t
>::difference_type i, std::vector< size_t >::difference_type j,
vector_size_t v) ";

%feature("docstring")  cmf_core::vector_size_t::append "def
append(self, args, kwargs)

append(vector_size_t self, std::vector< size_t >::value_type const &
x) ";

%feature("docstring")  cmf_core::vector_size_t::assign "def
assign(self, args, kwargs)

assign(vector_size_t self, std::vector< size_t >::size_type n,
std::vector< size_t >::value_type const & x) ";

%feature("docstring")  cmf_core::vector_size_t::back "def back(self,
args, kwargs)

back(vector_size_t self) -> std::vector< size_t >::value_type const &
";

%feature("docstring")  cmf_core::vector_size_t::begin "def
begin(self, args, kwargs)

begin(vector_size_t self) -> std::vector< size_t >::iterator ";

%feature("docstring")  cmf_core::vector_size_t::capacity "def
capacity(self, args, kwargs)

capacity(vector_size_t self) -> std::vector< size_t >::size_type ";

%feature("docstring")  cmf_core::vector_size_t::clear "def
clear(self, args, kwargs)

clear(vector_size_t self) ";

%feature("docstring")  cmf_core::vector_size_t::empty "def
empty(self, args, kwargs)

empty(vector_size_t self) -> bool ";

%feature("docstring")  cmf_core::vector_size_t::end "def end(self,
args, kwargs)

end(vector_size_t self) -> std::vector< size_t >::iterator ";

%feature("docstring")  cmf_core::vector_size_t::erase "def
erase(self, args)

erase(vector_size_t self, std::vector< size_t >::iterator pos) ->
std::vector< size_t >::iterator erase(vector_size_t self, std::vector<
size_t >::iterator first, std::vector< size_t >::iterator last) ->
std::vector< size_t >::iterator ";

%feature("docstring")  cmf_core::vector_size_t::front "def
front(self, args, kwargs)

front(vector_size_t self) -> std::vector< size_t >::value_type const &
";

%feature("docstring")  cmf_core::vector_size_t::get_allocator "def
get_allocator(self, args, kwargs)

get_allocator(vector_size_t self) -> std::vector< size_t
>::allocator_type ";

%feature("docstring")  cmf_core::vector_size_t::insert "def
insert(self, args)

insert(vector_size_t self, std::vector< size_t >::iterator pos,
std::vector< size_t >::value_type const & x) -> std::vector< size_t
>::iterator insert(vector_size_t self, std::vector< size_t >::iterator
pos, std::vector< size_t >::size_type n, std::vector< size_t
>::value_type const & x) ";

%feature("docstring")  cmf_core::vector_size_t::iterator "def
iterator(self, args, kwargs)

iterator(vector_size_t self) -> SwigPyIterator ";

%feature("docstring")  cmf_core::vector_size_t::pop "def pop(self,
args, kwargs)

pop(vector_size_t self) -> std::vector< size_t >::value_type ";

%feature("docstring")  cmf_core::vector_size_t::pop_back "def
pop_back(self, args, kwargs)

pop_back(vector_size_t self) ";

%feature("docstring")  cmf_core::vector_size_t::push_back "def
push_back(self, args, kwargs)

push_back(vector_size_t self, std::vector< size_t >::value_type const
& x) ";

%feature("docstring")  cmf_core::vector_size_t::rbegin "def
rbegin(self, args, kwargs)

rbegin(vector_size_t self) -> std::vector< size_t >::reverse_iterator
";

%feature("docstring")  cmf_core::vector_size_t::rend "def rend(self,
args, kwargs)

rend(vector_size_t self) -> std::vector< size_t >::reverse_iterator ";

%feature("docstring")  cmf_core::vector_size_t::reserve "def
reserve(self, args, kwargs)

reserve(vector_size_t self, std::vector< size_t >::size_type n) ";

%feature("docstring")  cmf_core::vector_size_t::resize "def
resize(self, args)

resize(vector_size_t self, std::vector< size_t >::size_type new_size)
resize(vector_size_t self, std::vector< size_t >::size_type new_size,
std::vector< size_t >::value_type const & x) ";

%feature("docstring")  cmf_core::vector_size_t::size "def size(self,
args, kwargs)

size(vector_size_t self) -> std::vector< size_t >::size_type ";

%feature("docstring")  cmf_core::vector_size_t::swap "def swap(self,
args, kwargs)

swap(vector_size_t self, vector_size_t v) ";


// File: classcmf_1_1upslope_1_1vegetation_1_1_vegetation.xml
%feature("docstring") cmf::upslope::vegetation::Vegetation "

Holds the vegetation parameters for the calculation of ET and
fractionating rainfall. Not every ET method uses all parameters.

C++ includes: StructVegetation.h ";

%feature("docstring")
cmf::upslope::vegetation::Vegetation::Vegetation "Vegetation(double
_LAI=2.88, double _Height=0.12, double _RootDepth=0.25, double
_StomatalResistance=100, double _albedo=0.23, double _CanopyClosure=1,
double _CanopyCapacityPerLAI=0.1, double _fraction_at_rootdepth=1.0)
";

%feature("docstring")
cmf::upslope::vegetation::Vegetation::RootFraction "double
RootFraction(double upperBoundary, double lowerBoundary) const

Returns the fraction of root mass in a segment of the soil column per
total root mass.

Parameters:
-----------

upperBoundary:  lowerBoundary:  Upper and lower depth below ground of
the segment The method to claculate the distribution of roots in the
soil depends on the fraction_at_rootdepth :math:`f_{r0}` parameter. If
:math:`f_{r0}=1`, a uniform distribution from the ground to the root depth
is assumed. If :math:`f_{r0}<1`, an exponential decline of root density with
depth is assumed, that :math:`f_{r0}` of the roots are above the root depth
r0. 

.. math::

    f_{r}(z_u,z_l) = (\\\\frac 1 {1-f_{r0}})^{z_l-r0} - (\\\\frac
    1 {1-f_{r0}})^{z_u-r0}

";

%feature("docstring")
cmf::upslope::vegetation::Vegetation::RootFraction "cmf::math::num_array RootFraction(const cmf::math::num_array
&thickness) const ";

%feature("docstring")
cmf::upslope::vegetation::Vegetation::RootLength "double RootLength()
const

Returns the average root length in m/m2. ";


// File: classcmf__core_1_1_vegetation.xml
%feature("docstring") cmf_core::Vegetation "

Holds the vegetation parameters for the calculation of ET and
fractionating rainfall. Not every ET method uses all parameters.  C++
includes: StructVegetation.h ";

%feature("docstring")  cmf_core::Vegetation::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::upslope::vegetation::Vegetation self, double _LAI=2.88,
double _Height=0.12, double _RootDepth=0.25, double
_StomatalResistance=100, double _albedo=0.23, double _CanopyClosure=1,
double _CanopyCapacityPerLAI=0.1, double _fraction_at_rootdepth=1.0)
-> Vegetation  Vegetation(double _LAI=2.88, double _Height=0.12,
double _RootDepth=0.25, double _StomatalResistance=100, double
_albedo=0.23, double _CanopyClosure=1, double
_CanopyCapacityPerLAI=0.1, double _fraction_at_rootdepth=1.0) ";

%feature("docstring")  cmf_core::Vegetation::__repr__ "def
__repr__(self, args, kwargs)

__repr__(Vegetation self) -> std::string ";

%feature("docstring")  cmf_core::Vegetation::RootFraction "def
RootFraction(self, args)

RootFraction(Vegetation self, double upperBoundary, double
lowerBoundary) -> double RootFraction(Vegetation self,
cmf::math::num_array const & thickness) -> cmf::math::num_array
cmf::math::num_array RootFraction(const cmf::math::num_array
&thickness) const ";

%feature("docstring")  cmf_core::Vegetation::RootLength "def
RootLength(self, args, kwargs)

RootLength(Vegetation self) -> double  double RootLength() const
Returns the average root length in m/m2. ";


// File: classcmf__core_1_1volume__height__function.xml
%feature("docstring") cmf_core::volume_height_function "

A wrapper class for volume / height functional relations.  C++
includes: ReachType.h ";

%feature("docstring")  cmf_core::volume_height_function::__init__ "def __init__(self, args)

__init__(cmf::river::volume_height_function self,
volume_height_function for_copy) -> volume_height_function
__init__(cmf::river::volume_height_function self,
IVolumeHeightFunction for_copy) -> volume_height_function
volume_height_function(const IVolumeHeightFunction &for_copy)  Wrapper
for any IVolumeHeightFunction. ";

%feature("docstring")  cmf_core::volume_height_function::A "def
A(self, args, kwargs)

A(IVolumeHeightFunction self, double V) -> double  virtual double
A(double V) const =0  Returns the area of the surface for a given
volume. ";

%feature("docstring")  cmf_core::volume_height_function::copy "def
copy(self, args, kwargs)

copy(volume_height_function self) -> volume_height_function
volume_height_function* copy() const ";

%feature("docstring")  cmf_core::volume_height_function::h "def
h(self, args, kwargs)

h(IVolumeHeightFunction self, double V) -> double  virtual double
h(double V) const =0  Returns the depth of a given volume. ";

%feature("docstring")  cmf_core::volume_height_function::q "def
q(self, args, kwargs)

q(IVolumeHeightFunction self, double h, double slope) -> double
virtual double q(double h, double slope) const ";

%feature("docstring")  cmf_core::volume_height_function::V "def
V(self, args, kwargs)

V(IVolumeHeightFunction self, double h) -> double  virtual double
V(double h) const =0 ";


// File: classcmf_1_1river_1_1volume__height__function.xml
%feature("docstring") cmf::river::volume_height_function "

A wrapper class for volume / height functional relations.

C++ includes: ReachType.h ";

%feature("docstring")
cmf::river::volume_height_function::volume_height_function "volume_height_function(const volume_height_function &for_copy)

Copy constructable. ";

%feature("docstring")
cmf::river::volume_height_function::volume_height_function "volume_height_function(const IVolumeHeightFunction &for_copy)

Wrapper for any IVolumeHeightFunction. ";

%feature("docstring")
cmf::river::volume_height_function::~volume_height_function "virtual
~volume_height_function() ";

%feature("docstring")  cmf::river::volume_height_function::A "double
A(double V) const

Returns the area of the surface for a given volume. ";

%feature("docstring")  cmf::river::volume_height_function::copy "volume_height_function* copy() const ";

%feature("docstring")  cmf::river::volume_height_function::h "double
h(double V) const

Returns the depth of a given volume. ";

%feature("docstring")  cmf::river::volume_height_function::q "double
q(double h, double slope) const ";

%feature("docstring")  cmf::river::volume_height_function::V "double
V(double h) const ";


// File: classcmf_1_1upslope_1_1_e_t_1_1_volume_stress.xml
%feature("docstring") cmf::upslope::ET::VolumeStress "

A WaterStressFunction based on the stored water volume of a layer.

If the layer contains more water than V1, ET is not limited (
ET=ETpot). Below V1 ET goes linear to 0.0 at V0

C++ includes: waterstress.h ";

%feature("docstring")  cmf::upslope::ET::VolumeStress::VolumeStress "VolumeStress(real V1, real V0)

Creates a new water stress function for water volume.

Parameters:
-----------

V1:  Water content in :math:`m^3` without stress ( ET=ETpot)

V0:  Water content in :math:`m^3` with full stress ( ET=0.0) ";

%feature("docstring")  cmf::upslope::ET::VolumeStress::VolumeStress "VolumeStress(const VolumeStress &other) ";

%feature("docstring")  cmf::upslope::ET::VolumeStress::~VolumeStress "virtual ~VolumeStress() ";

%feature("docstring")  cmf::upslope::ET::VolumeStress::copy "cmf::upslope::ET::VolumeStress* copy() const

Creates a new copy of this wetness. ";

%feature("docstring")  cmf::upslope::ET::VolumeStress::Tact "real
Tact(const stressedET *connection, real Tpot) const

Calculates the water stress for a layer.

Parameters:
-----------

connection:  The stressedET connection this stress function belongs to

Tpot:  Potential Transpiration in mm/day (for the full profile)

Actual flux from layer in m3/day ";

%feature("docstring")  cmf::upslope::ET::VolumeStress::to_string "std::string to_string() const ";


// File: classcmf__core_1_1_volume_stress.xml
%feature("docstring") cmf_core::VolumeStress "

A WaterStressFunction based on the stored water volume of a layer.  If
the layer contains more water than V1, ET is not limited ( ET=ETpot).
Below V1 ET goes linear to 0.0 at V0  C++ includes: waterstress.h ";

%feature("docstring")  cmf_core::VolumeStress::__init__ "def
__init__(self, args)

__init__(cmf::upslope::ET::VolumeStress self, real V1, real V0) ->
VolumeStress __init__(cmf::upslope::ET::VolumeStress self,
VolumeStress other) -> VolumeStress  VolumeStress(const VolumeStress
&other) ";

%feature("docstring")  cmf_core::VolumeStress::copy "def copy(self,
args, kwargs)

copy(VolumeStress self) -> VolumeStress
cmf::upslope::ET::VolumeStress* copy() const  Creates a new copy of
this wetness. ";

%feature("docstring")  cmf_core::VolumeStress::Tact "def Tact(self,
args, kwargs)

Tact(RootUptakeStessFunction self, stressedET connection, real Tpot)
-> real  virtual real Tact(const stressedET *connection, real Tpot)
const =0  Calculates the water stress for a layer.  Parameters:
-----------  connection:  The stressedET connection this stress
function belongs to  Tpot:  Potential Transpiration in mm/day (for the
full profile)  Actual flux from layer in m3/day ";

%feature("docstring")  cmf_core::VolumeStress::to_string "def
to_string(self, args, kwargs)

to_string(RootUptakeStessFunction self) -> std::string  virtual
std::string to_string() const =0 ";


// File: classcmf_1_1water_1_1waterbalance__connection.xml
%feature("docstring") cmf::water::waterbalance_connection "

Routes the sum of all other fluxes to a target.



.. math::

     q_{1,0} = \\\\sum_{i=2}^N{q_{1,i}(V_1,V_i,t)}

where:
:math:`q_{i,j}` is the flux between the two node i and j. Subscript 0 is the
right node, subscript 1 is the left node and 2..N are the nodes
connected to the left node, except for the right node

C++ includes: simple_connections.h ";

%feature("docstring")
cmf::water::waterbalance_connection::waterbalance_connection "waterbalance_connection(flux_node::ptr source, flux_node::ptr target)
";

%feature("docstring")  cmf::water::waterbalance_connection::conc "real conc(cmf::math::Time t, const cmf::water::solute &_Solute)

Returns the concentration of the flux.

If not overridden, it returns the concentration of the source of the
flux (direction depending) ";

%feature("docstring")
cmf::water::waterbalance_connection::exchange_target "void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf::water::waterbalance_connection::get_ptr "ptr get_ptr() const ";

%feature("docstring")  cmf::water::waterbalance_connection::get_target
"flux_node::ptr get_target(const flux_node &inquirer)

Returns the other end of a connection than the asking end. ";

%feature("docstring")  cmf::water::waterbalance_connection::get_target
"flux_node::ptr get_target(int index) const

With index 0, the left node is returned, with index 1 the right node
of the connection. ";

%feature("docstring")
cmf::water::waterbalance_connection::get_tracer_filter "real
get_tracer_filter()

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::waterbalance_connection::get_tracer_filter "real
get_tracer_filter(solute S)

A value ranging from 0 to 1 to filter tracers out of the water flux.
";

%feature("docstring")  cmf::water::waterbalance_connection::kill_me "bool kill_me()

Deregisters this connection from its nodes. Returns true if only one
reference is left. ";

%feature("docstring")  cmf::water::waterbalance_connection::left_node
"flux_node::ptr left_node() const

Returns the left node of this connection. ";

%feature("docstring")  cmf::water::waterbalance_connection::q "real
q(const flux_node &inquirer, cmf::math::Time t)

Returns the current flux through a connection. Negative signs mean out
of the inquirer, positive are inflows to the inquirer. ";

%feature("docstring")  cmf::water::waterbalance_connection::refresh "void refresh(cmf::math::Time t)

Performes a new calculation of the flux. ";

%feature("docstring")  cmf::water::waterbalance_connection::right_node
"flux_node::ptr right_node() const

returns the right node of this connection ";

%feature("docstring")
cmf::water::waterbalance_connection::set_tracer_filter "void
set_tracer_filter(real value)

A value ranging from 0 to 1 to filter tracers out of the water flux.

1.0 is no filter and 0.0 means no solute is crossing this connection
";

%feature("docstring")
cmf::water::waterbalance_connection::set_tracer_filter "void
set_tracer_filter(solute S, real value) ";

%feature("docstring")
cmf::water::waterbalance_connection::short_string "virtual
std::string short_string() const ";

%feature("docstring")  cmf::water::waterbalance_connection::to_string
"virtual std::string to_string() const ";


// File: classcmf__core_1_1waterbalance__connection.xml
%feature("docstring") cmf_core::waterbalance_connection "

Routes the sum of all other fluxes to a target.    .. math:: q_{1,0} =
\\\\\\\\sum_{i=2}^N{q_{1,i}(V_1,V_i,t)}  where: :math:`q_{i,j}` is the
flux between the two node i and j. Subscript 0 is the right node,
subscript 1 is the left node and 2..N are the nodes connected to the
left node, except for the right node  C++ includes:
simple_connections.h ";

%feature("docstring")  cmf_core::waterbalance_connection::__init__ "def __init__(self, args, kwargs)

__init__(cmf::water::waterbalance_connection self,
cmf::water::flux_node::ptr source, cmf::water::flux_node::ptr target)
-> waterbalance_connection  waterbalance_connection(flux_node::ptr
source, flux_node::ptr target) ";

%feature("docstring")  cmf_core::waterbalance_connection::__contains__
"def __contains__(self, cmp) ";

%feature("docstring")  cmf_core::waterbalance_connection::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_connection self, flux_connection other) -> bool ";

%feature("docstring")  cmf_core::waterbalance_connection::__getitem__
"def __getitem__(self, index) ";

%feature("docstring")  cmf_core::waterbalance_connection::__iter__ "def __iter__(self) ";

%feature("docstring")  cmf_core::waterbalance_connection::__repr__ "def __repr__(self) ";

%feature("docstring")  cmf_core::waterbalance_connection::conc "def
conc(self, args, kwargs)

conc(flux_connection self, Time t, solute _Solute) -> real  real
conc(cmf::math::Time t, const cmf::water::solute &_Solute)  Returns
the concentration of the flux.  If not overridden, it returns the
concentration of the source of the flux (direction depending) ";

%feature("docstring")
cmf_core::waterbalance_connection::exchange_target "def
exchange_target(self, args, kwargs)

exchange_target(flux_connection self, cmf::water::flux_node::ptr
oldtarget, cmf::water::flux_node::ptr newTarget)  void
exchange_target(flux_node::ptr oldtarget, flux_node::ptr newTarget) ";

%feature("docstring")  cmf_core::waterbalance_connection::get_target "def get_target(self, args)

get_target(flux_connection self, flux_node inquirer) ->
cmf::water::flux_node::ptr get_target(flux_connection self, int index)
-> cmf::water::flux_node::ptr  flux_node::ptr get_target(int index)
const  With index 0, the left node is returned, with index 1 the right
node of the connection. ";

%feature("docstring")
cmf_core::waterbalance_connection::get_tracer_filter "def
get_tracer_filter(self, args)

get_tracer_filter(flux_connection self) -> real
get_tracer_filter(flux_connection self, solute S) -> real  real
get_tracer_filter(solute S)  A value ranging from 0 to 1 to filter
tracers out of the water flux. ";

%feature("docstring")  cmf_core::waterbalance_connection::kill_me "def kill_me(self, args, kwargs)

kill_me(flux_connection self) -> bool  bool kill_me()  Deregisters
this connection from its nodes. Returns true if only one reference is
left. ";

%feature("docstring")  cmf_core::waterbalance_connection::left_node "def left_node(self, args, kwargs)

left_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr left_node() const  Returns the left node of this
connection. ";

%feature("docstring")  cmf_core::waterbalance_connection::q "def
q(self, args, kwargs)

q(flux_connection self, flux_node inquirer, Time t) -> real  real
q(const flux_node &inquirer, cmf::math::Time t)  Returns the current
flux through a connection. Negative signs mean out of the inquirer,
positive are inflows to the inquirer. ";

%feature("docstring")  cmf_core::waterbalance_connection::refresh "def refresh(self, args, kwargs)

refresh(flux_connection self, Time t)  void refresh(cmf::math::Time t)
Performes a new calculation of the flux. ";

%feature("docstring")  cmf_core::waterbalance_connection::right_node "def right_node(self, args, kwargs)

right_node(flux_connection self) -> cmf::water::flux_node::ptr
flux_node::ptr right_node() const  returns the right node of this
connection ";

%feature("docstring")
cmf_core::waterbalance_connection::set_tracer_filter "def
set_tracer_filter(self, args)

set_tracer_filter(flux_connection self, real value)
set_tracer_filter(flux_connection self, solute S, real value)  void
set_tracer_filter(solute S, real value) ";

%feature("docstring")  cmf_core::waterbalance_connection::short_string
"def short_string(self, args, kwargs)

short_string(flux_connection self) -> std::string  virtual std::string
short_string() const ";

%feature("docstring")  cmf_core::waterbalance_connection::to_string "def to_string(self, args, kwargs)

to_string(flux_connection self) -> std::string  virtual std::string
to_string() const ";


// File: classcmf_1_1water_1_1waterbalance__integrator.xml
%feature("docstring") cmf::water::waterbalance_integrator "

The waterbalance_integrator is an integratable for precise output of
the average water balance of a flux_node over time.

It can be added to a solver (any cmf::math::Integrator), which is than
calling the integrate method at each substep.

C++ includes: flux_node.h ";

%feature("docstring")
cmf::water::waterbalance_integrator::waterbalance_integrator "waterbalance_integrator(cmf::water::flux_node::ptr node) ";

%feature("docstring")  cmf::water::waterbalance_integrator::avg "double avg() const

Returns the average flux over the integration time in m3/day. ";

%feature("docstring")  cmf::water::waterbalance_integrator::get_node "flux_node::ptr get_node() const

Returns the node of this integrator. ";

%feature("docstring")  cmf::water::waterbalance_integrator::integrate
"void integrate(cmf::math::Time until)

Integrates the flux a timestep further. Note: until is an absolut
time. If until is before t0, the integration is initilized again. ";

%feature("docstring")
cmf::water::waterbalance_integrator::integration_t "cmf::math::Time
integration_t() const

Returns the duration of the integration. ";

%feature("docstring")  cmf::water::waterbalance_integrator::reset "void reset(cmf::math::Time t)

Initializes the integration. ";

%feature("docstring")  cmf::water::waterbalance_integrator::set_node "void set_node(cmf::water::flux_node::ptr node) ";

%feature("docstring")  cmf::water::waterbalance_integrator::sum "double sum() const

Returns the total absolute waterbalance of the node in integration
time [m3]. ";

%feature("docstring")  cmf::water::waterbalance_integrator::t0 "cmf::math::Time t0() const

Returns the start time of the integration. ";


// File: classcmf__core_1_1waterbalance__integrator.xml
%feature("docstring") cmf_core::waterbalance_integrator "

The waterbalance_integrator is an integratable for precise output of
the average water balance of a flux_node over time.  It can be added
to a solver (any cmf::math::Integrator), which is than calling the
integrate method at each substep.  C++ includes: flux_node.h ";

%feature("docstring")  cmf_core::waterbalance_integrator::__init__ "def __init__(self, args, kwargs)

__init__(cmf::water::waterbalance_integrator self,
cmf::water::flux_node::ptr node) -> waterbalance_integrator
waterbalance_integrator(cmf::water::flux_node::ptr node) ";

%feature("docstring")  cmf_core::waterbalance_integrator::avg "def
avg(self, args, kwargs)

avg(integratable self) -> double  virtual double avg() const =0
Returns average of the integrated variable (eg. flux) from the last
reset until the last call of integrate. ";

%feature("docstring")  cmf_core::waterbalance_integrator::integrate "def integrate(self, args, kwargs)

integrate(integratable self, Time t)  virtual void integrate(Time t)=0
Integrates the variable until time t. ";

%feature("docstring")
cmf_core::waterbalance_integrator::integration_t "def
integration_t(self, args, kwargs)

integration_t(waterbalance_integrator self) -> Time  cmf::math::Time
integration_t() const  Returns the duration of the integration. ";

%feature("docstring")  cmf_core::waterbalance_integrator::reset "def
reset(self, args, kwargs)

reset(integratable self, Time t)  virtual void reset(Time t)=0  Sets
the start time of the integral. ";

%feature("docstring")  cmf_core::waterbalance_integrator::sum "def
sum(self, args, kwargs)

sum(integratable self) -> double  virtual double sum() const =0  Get
the integral from the last reset until the last call of integrate. ";

%feature("docstring")  cmf_core::waterbalance_integrator::t0 "def
t0(self, args, kwargs)

t0(waterbalance_integrator self) -> Time  cmf::math::Time t0() const
Returns the start time of the integration. ";


// File: classcmf_1_1water_1_1_water_storage.xml
%feature("docstring") cmf::water::WaterStorage "

A state variable for the storage of water.

A class for the storage of water. The state is the volume of water
stored in :math:`m^3` The derivative function is given by:


.. math::

     \\\\frac{dV}{dt}&=&\\\\sum_{f=1}^{F} q_f \\\\\\\\
    F&=& \\\\mbox{Number of fluxes in water storage} \\\\\\\\ q_f&=&
    \\\\mbox{Water flux in } \\\\frac{m^3}{day} \\\\\\\\
    



Todo Check the head based state mode

C++ includes: WaterStorage.h ";

/*  Overrides of flux_node  */

%feature("docstring")  cmf::water::WaterStorage::RecalcFluxes "virtual bool RecalcFluxes(cmf::math::Time t)

Pure flux_nodes do not influence fluxes, therefore no recalculation of
fluxes is required by flux_node.

WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf::water::WaterStorage::is_empty "virtual
double is_empty() const

Returns true if the node has no water. ";

%feature("docstring")  cmf::water::WaterStorage::to_string "virtual
std::string to_string() const ";

%feature("docstring")  cmf::water::WaterStorage::WaterStorage "WaterStorage(cmf::project &project, const std::string &Name=\"\",
double InitialState=0, double scale=1)

creates a water storage (abstract class)

Parameters:
-----------

project:  The project the waterstorage belongs to

Name:  Name of the water storage

InitialState:  Initial water content in m3

scale:  A kind of \"standard size\" in m3 of the water storage to
scale tolerances, default 1m3 ";

%feature("docstring")  cmf::water::WaterStorage::add_connected_states
"virtual void add_connected_states(cmf::math::StateVariable::list
&states) ";

%feature("docstring")  cmf::water::WaterStorage::conc "real
conc(const cmf::water::solute &_Solute) const

Returns the concentration of the given solute. ";

%feature("docstring")  cmf::water::WaterStorage::conc "real
conc(cmf::math::Time t, const cmf::water::solute &_Solute) const

Returns the current WaterQuality (concentration of all solutes) ";

%feature("docstring")  cmf::water::WaterStorage::conc "void
conc(const cmf::water::solute &_Solute, real NewConcetration)

Sets a new concentration. ";

%feature("docstring")  cmf::water::WaterStorage::connection_to "cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)

Returns the connection between this and target. ";

%feature("docstring")  cmf::water::WaterStorage::dxdt "virtual real
dxdt(const cmf::math::Time &time) ";

%feature("docstring")  cmf::water::WaterStorage::flux3d_to "cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf::water::WaterStorage::flux_to "real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)

Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf::water::WaterStorage::get_3d_flux "cmf::geometry::point get_3d_flux(cmf::math::Time t)

Returns the sum of all flux vectors. ";

%feature("docstring")  cmf::water::WaterStorage::get_abs_errtol "virtual real get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf::water::WaterStorage::get_connections "cmf::water::connection_list get_connections() const ";

%feature("docstring")  cmf::water::WaterStorage::get_potential "virtual real get_potential() const

Returns the water potential of the node in m waterhead.

The base class water storage always returns the height of the location
";

%feature("docstring")  cmf::water::WaterStorage::get_project "cmf::project& get_project() const

Returns the project, this node is part of. ";

%feature("docstring")  cmf::water::WaterStorage::get_state "real
get_state() const ";

%feature("docstring")
cmf::water::WaterStorage::get_state_variable_content "char
get_state_variable_content() const

A character indicating the integrated variable (either 'V' for Volume
or 'h' for head) ";

%feature("docstring")  cmf::water::WaterStorage::get_states "cmf::math::StateVariableList get_states()

Add the state variables, owned by an object derived from
StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf::water::WaterStorage::get_volume "virtual
real get_volume() const

Returns the volume of water in this storage in m3 ";

%feature("docstring")  cmf::water::WaterStorage::is_connected "virtual bool is_connected(const cmf::math::StateVariable &other) const

Returns True if this waterstorage is effected by another state. ";

%feature("docstring")  cmf::water::WaterStorage::is_storage "virtual
bool is_storage() const

Returns true, since this is a storage. ";

%feature("docstring")  cmf::water::WaterStorage::remove_connection "bool remove_connection(cmf::water::flux_node::ptr To)

Remove the connection. ";

%feature("docstring")  cmf::water::WaterStorage::set_potential "virtual void set_potential(real newpotential)

Sets the potential of this flux node. ";

%feature("docstring")  cmf::water::WaterStorage::set_state "void
set_state(real newState) ";

%feature("docstring")
cmf::water::WaterStorage::set_state_variable_content "void
set_state_variable_content(char content)

A character indicating the integrated variable (either 'V' for Volume
or 'h' for head) ";

%feature("docstring")  cmf::water::WaterStorage::set_volume "virtual
void set_volume(real newwatercontent)

Sets the volume of water in this storage in m3 ";

%feature("docstring")  cmf::water::WaterStorage::Solute "SoluteStorage& Solute(const cmf::water::solute _Solute)

Returns the water quality of the water storage. ";

%feature("docstring")  cmf::water::WaterStorage::Solute "const
SoluteStorage& Solute(const cmf::water::solute _Solute) const ";

%feature("docstring")  cmf::water::WaterStorage::waterbalance "real
waterbalance(cmf::math::Time t, const flux_connection *Without=0)
const

Returns the sum of all fluxes (positive and negative) at time t.

Single fluxes can be excluded from the calculation

Parameters:
-----------

t:  Time of the query

Without:  A flux_connection that is excluded from the waterbalance
(e.g. to prevent closed circuits) ";


// File: classcmf__core_1_1_water_storage.xml
%feature("docstring") cmf_core::WaterStorage "

A state variable for the storage of water.  A class for the storage of
water. The state is the volume of water stored in :math:`m^3` The
derivative function is given by:   .. math::
\\\\\\\\frac{dV}{dt}&=&\\\\\\\\sum_{f=1}^{F} q_f \\\\\\\\\\\\\\\\ F&=&
\\\\\\\\mbox{Number of fluxes in water storage} \\\\\\\\\\\\\\\\
q_f&=&     \\\\\\\\mbox{Water flux in } \\\\\\\\frac{m^3}{day}
\\\\\\\\\\\\\\\\     Todo Check the head based state mode  C++
includes: WaterStorage.h ";

%feature("docstring")  cmf_core::WaterStorage::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::water::WaterStorage self, project project, std::string
const & Name, double InitialState=0, double scale=1) -> WaterStorage
WaterStorage(cmf::project &project, const std::string &Name=\"\",
double InitialState=0, double scale=1)  creates a water storage
(abstract class)  Parameters: -----------  project:  The project the
waterstorage belongs to  Name:  Name of the water storage
InitialState:  Initial water content in m3  scale:  A kind of
\"standard size\" in m3 of the water storage to scale tolerances,
default 1m3 ";

%feature("docstring")  cmf_core::WaterStorage::__call__ "def
__call__(self, args, kwargs)

__call__(flux_node self, Time t) -> real ";

%feature("docstring")  cmf_core::WaterStorage::__eq__ "def
__eq__(self, args, kwargs)

__eq__(flux_node self, flux_node other) -> bool ";

%feature("docstring")  cmf_core::WaterStorage::__getitem__ "def
__getitem__(self, args, kwargs)

__getitem__(WaterStorage self, solute X) -> SoluteStorage ";

%feature("docstring")  cmf_core::WaterStorage::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::WaterStorage::cast "def cast(args,
kwargs)

cast(std::shared_ptr< cmf::water::flux_node > node) ->
std::shared_ptr< cmf::water::WaterStorage > ";

%feature("docstring")  cmf_core::WaterStorage::conc "def conc(self,
args, kwargs)

conc(flux_node self, Time t, solute Solute) -> real  virtual real
conc(cmf::math::Time t, const cmf::water::solute &Solute) const
Returns the water quality of the flux_node, if it is not overridden
this is the mix of the incoming fluxes. ";

%feature("docstring")  cmf_core::WaterStorage::conc "def conc(self,
args)

conc(WaterStorage self, solute _Solute) -> real conc(WaterStorage
self, Time t, solute _Solute) -> real conc(WaterStorage self, solute
_Solute, real NewConcetration)  void conc(const cmf::water::solute
&_Solute, real NewConcetration)  Sets a new concentration. ";

%feature("docstring")  cmf_core::WaterStorage::connected_nodes "def
connected_nodes(self) ";

%feature("docstring")  cmf_core::WaterStorage::connection_to "def
connection_to(self, args, kwargs)

connection_to(flux_node self, flux_node target) -> flux_connection
cmf::water::flux_connection* connection_to(const cmf::water::flux_node
&target)  Returns the connection between this and target. ";

%feature("docstring")  cmf_core::WaterStorage::create "def
create(args, kwargs)

create(project _project, real initial_state=0.0, real scale=1.0) ->
std::shared_ptr< cmf::water::WaterStorage > ";

%feature("docstring")  cmf_core::WaterStorage::dxdt "def dxdt(self,
args, kwargs)

dxdt(StateVariable self, Time time) -> real  virtual real dxdt(const
cmf::math::Time &time)=0  Returns the derivate of the state variable
at time time. ";

%feature("docstring")  cmf_core::WaterStorage::flux3d_to "def
flux3d_to(self, args, kwargs)

flux3d_to(flux_node self, flux_node target, Time t) -> point
cmf::geometry::point flux3d_to(const cmf::water::flux_node &target,
cmf::math::Time t) ";

%feature("docstring")  cmf_core::WaterStorage::flux_to "def
flux_to(self, args, kwargs)

flux_to(flux_node self, flux_node target, Time t) -> real  real
flux_to(const cmf::water::flux_node &target, cmf::math::Time t)
Returns the actual flux between this and target (positive sign means
\"from this into target\") ";

%feature("docstring")  cmf_core::WaterStorage::fluxes "def
fluxes(self, t) ";

%feature("docstring")  cmf_core::WaterStorage::from_node "def
from_node(args, kwargs)

from_node(cmf::water::flux_node::ptr node) -> std::shared_ptr<
cmf::water::WaterStorage > ";

%feature("docstring")  cmf_core::WaterStorage::get_3d_flux "def
get_3d_flux(self, args, kwargs)

get_3d_flux(flux_node self, Time t) -> point  cmf::geometry::point
get_3d_flux(cmf::math::Time t)  Returns the sum of all flux vectors.
";

%feature("docstring")  cmf_core::WaterStorage::get_abs_errtol "def
get_abs_errtol(self, args, kwargs)

get_abs_errtol(StateVariable self, real rel_errtol) -> real  virtual
real get_abs_errtol(real rel_errtol) const ";

%feature("docstring")  cmf_core::WaterStorage::get_states "def
get_states(self, args, kwargs)

get_states(StateVariableOwner self) -> StateVariableList  virtual
StateVariableList get_states()=0  Add the state variables, owned by an
object derived from StateVariableOwner, to the given vector. ";

%feature("docstring")  cmf_core::WaterStorage::is_connected "def
is_connected(self, args, kwargs)

is_connected(StateVariable self, StateVariable other) -> bool  virtual
bool is_connected(const cmf::math::StateVariable &other) const ";

%feature("docstring")  cmf_core::WaterStorage::is_empty "def
is_empty(self, args, kwargs)

is_empty(flux_node self) -> double  virtual double is_empty() const
Returns true if the node has no water. ";

%feature("docstring")  cmf_core::WaterStorage::is_storage "def
is_storage(self, args, kwargs)

is_storage(flux_node self) -> bool  virtual bool is_storage() const
true, if this is a waterstorage ";

%feature("docstring")  cmf_core::WaterStorage::RecalcFluxes "def
RecalcFluxes(self, args, kwargs)

RecalcFluxes(flux_node self, Time t) -> bool  virtual bool
RecalcFluxes(cmf::math::Time t)  Pure flux_nodes do not influence
fluxes, therefore no recalculation of fluxes is required by flux_node.
WaterStorage overrides this, since state changes require an update of
the fluxes ";

%feature("docstring")  cmf_core::WaterStorage::remove_connection "def
remove_connection(self, args, kwargs)

remove_connection(flux_node self, cmf::water::flux_node::ptr To) ->
bool  bool remove_connection(cmf::water::flux_node::ptr To)  Remove
the connection. ";

%feature("docstring")  cmf_core::WaterStorage::Solute "def
Solute(self, args)

Solute(WaterStorage self, solute _Solute) -> SoluteStorage
Solute(WaterStorage self, solute _Solute) -> SoluteStorage  const
SoluteStorage& Solute(const cmf::water::solute _Solute) const ";

%feature("docstring")  cmf_core::WaterStorage::to_string "def
to_string(self, args, kwargs)

to_string(StateVariable self) -> std::string  virtual std::string
to_string() const =0 ";

%feature("docstring")  cmf_core::WaterStorage::to_string "def
to_string(self, args, kwargs)

to_string(flux_node self) -> std::string  virtual std::string
to_string() const ";

%feature("docstring")  cmf_core::WaterStorage::waterbalance "def
waterbalance(self, args, kwargs)

waterbalance(flux_node self, Time t, flux_connection Without=None) ->
real  real waterbalance(cmf::math::Time t, const flux_connection
*Without=0) const  Returns the sum of all fluxes (positive and
negative) at time t.  Single fluxes can be excluded from the
calculation  Parameters: -----------  t:  Time of the query  Without:
A flux_connection that is excluded from the waterbalance (e.g. to
prevent closed circuits) ";


// File: classcmf__core_1_1_weather.xml
%feature("docstring") cmf_core::Weather "

A structure holding meteorological information, excluding
precipitation  C++ includes: Weather.h ";

%feature("docstring")  cmf_core::Weather::__init__ "def
__init__(self, args, kwargs)

__init__(cmf::atmosphere::Weather self, double T=15.0, double
Tmax=17.0, double Tmin=13.0, double rH=70.0, double wind=2.0, double
sunshine=0.5, double Rs=15, double Ra=30, double daylength=12) ->
Weather  Weather(double T=15.0, double Tmax=17.0, double Tmin=13.0,
double rH=70.0, double wind=2.0, double sunshine=0.5, double Rs=15,
double daylength=12)  Creates a \"weather\" from given data.
Parameters: -----------  T:  actual Temperature in deg C  Tmax:  daily
maximum Temperature in deg C  Tmin:  daily minimum Temperature in deg
C  rH:  actual relative humidity in % [0..100]  wind:  actual wind
speed in m/s  sunshine:  actual fraction of sunshine duration per
potential sunshine duration in h/h  Rs:  actual incoming shortwave
global radiation in MJ/(m2 day)  daylength:  length of the day in h ";

%feature("docstring")  cmf_core::Weather::__add__ "def __add__(self,
args, kwargs)

__add__(Weather self, Weather w) -> Weather ";

%feature("docstring")  cmf_core::Weather::__iadd__ "def
__iadd__(self, args, kwargs)

__iadd__(Weather self, Weather w) -> Weather ";

%feature("docstring")  cmf_core::Weather::__imul__ "def
__imul__(self, args, kwargs)

__imul__(Weather self, double factor) -> Weather ";

%feature("docstring")  cmf_core::Weather::__mul__ "def __mul__(self,
args, kwargs)

__mul__(Weather self, double factor) -> Weather ";

%feature("docstring")  cmf_core::Weather::__repr__ "def
__repr__(self) ";

%feature("docstring")  cmf_core::Weather::__str__ "def __str__(self)
";

%feature("docstring")  cmf_core::Weather::get_snow_threshold "def
get_snow_threshold(args, kwargs)

get_snow_threshold() -> double ";

%feature("docstring")  cmf_core::Weather::Rn "def Rn(self, args,
kwargs)

Rn(Weather self, double albedo, bool daily=False) -> double  double
Rn(double albedo, bool daily=false) const  Calculates the net
radiation flux :math:`R_n \\\\\\\\left[\\\\\\\\frac{MJ}{m^2
day}\\\\\\\\right]`.    .. math::       R_{n} &=& R_{ns} - R_{nl}
\\\\\\\\\\\\\\\\ \\\\\\\\mbox{ Net     short wave radiation: }R_{ns}
&=& (1-\\\\\\\\alpha) R_s \\\\\\\\\\\\\\\\ \\\\\\\\mbox{     Net long
wave radiation: }R_{nl} &=& R_{black}\\\\\\\\ \\\\\\\\beta_{v}\\\\\\\\
\\\\\\\\beta_{c} \\\\\\\\\\\\\\\\ \\\\\\\\mbox{Black body radiation: }
R_{black} &=&     \\\\\\\\left\\\\\\\\{\\\\\\\\begin{array}{cl}
\\\\\\\\sigma T^4 & \\\\\\\\mbox{for less     than daily time steps}
\\\\\\\\\\\\\\\\ \\\\\\\\sigma \\\\\\\\frac {T_{max}^4 + T_{min}^4} 2
& \\\\\\\\mbox{for daily time steps} \\\\\\\\end{array} \\\\\\\\right.
\\\\\\\\\\\\\\\\ T &=& \\\\\\\\mbox{Temperature }[K] \\\\\\\\\\\\\\\\
\\\\\\\\sigma     &=& 4.903\\\\\\\\ 10^{-9} \\\\\\\\frac{MJ}{K^4 m^2
day} \\\\\\\\mbox{ Stefan-     Boltzmann constant } \\\\\\\\\\\\\\\\
\\\\\\\\mbox{Long wave reflectance: } \\\\\\\\\\\\\\\\ \\\\\\\\mbox{by
water vapor: }\\\\\\\\beta_{v} &=& 0.34 - 0.14     \\\\\\\\sqrt{e_a}
\\\\\\\\\\\\\\\\ \\\\\\\\mbox{ by clouds: }\\\\\\\\beta_{c} &=& 0.1 +
0.9 \\\\\\\\frac n N Parameters: -----------  albedo:  the albedo
:math:`\\\\\\\\alpha` of the surface  daily:  If true, the net
radiation for daily averages will be calculated ";

%feature("docstring")  cmf_core::Weather::set_snow_threshold "def
set_snow_threshold(args, kwargs)

set_snow_threshold(double new_threshold) ";

%feature("docstring")  cmf_core::Weather::to_string "def
to_string(self, args, kwargs)

to_string(Weather self) -> std::string  std::string to_string() const
Returns a string representation. ";


// File: structcmf_1_1atmosphere_1_1_weather.xml
%feature("docstring") cmf::atmosphere::Weather "

A structure holding meteorological information, excluding
precipitation

C++ includes: Weather.h ";

%feature("docstring")  cmf::atmosphere::Weather::Weather "Weather(double T=15.0, double Tmax=17.0, double Tmin=13.0, double
rH=70.0, double wind=2.0, double sunshine=0.5, double Rs=15, double
Ra=30, double daylength=12)

Creates a \"weather\" from given data.

Parameters:
-----------

T:  actual Temperature in deg C

Tmax:  daily maximum Temperature in deg C

Tmin:  daily minimum Temperature in deg C

rH:  actual relative humidity in % [0..100]

wind:  actual wind speed in m/s

sunshine:  actual fraction of sunshine duration per potential sunshine
duration in h/h

Rs:  actual incoming shortwave global radiation in MJ/(m2 day)

Ra:  actual extraterrestrial shortwave global radiation in MJ/(m2 day)

daylength:  length of the day in h ";

%feature("docstring")  cmf::atmosphere::Weather::Rn "double Rn(double
albedo, bool daily=false) const

Calculates the net radiation flux :math:`R_n \\\\left[\\\\frac{MJ}{m^2 day}\\\\right]`.



.. math::

     R_{n} = R_{ns} - R_{nl} \\\\\\\\ \\\\mbox{ Net
    short wave radiation: }R_{ns} = (1-\\\\alpha) R_s \\\\\\\\ \\\\mbox{
    Net long wave radiation: }R_{nl} = R_{black}\\\\ \\\\beta_{v}\\\\
    \\\\beta_{c} \\\\\\\\ \\\\mbox{Black body radiation: } R_{black} =
    \\\\left\\\\{\\\\begin{array}{cl} \\\\sigma T^4 & \\\\mbox{for less
    than daily time steps} \\\\\\\\ \\\\sigma \\\\frac {T_{max}^4 +
    T_{min}^4} 2 & \\\\mbox{for daily time steps} \\\\end{array}
    \\\\right. \\\\\\\\ T = \\\\mbox{Temperature }[K] \\\\\\\\ \\\\sigma =
    4.903\\\\ 10^{-9} \\\\frac{MJ}{K^4 m^2 day} \\\\mbox{ Stefan-Boltzmann
    constant } \\\\\\\\ \\\\mbox{Long wave reflectance: } \\\\\\\\
    \\\\mbox{by water vapor: }\\\\beta_{v} = 0.34 - 0.14 \\\\sqrt{e_a}
    \\\\\\\\ \\\\mbox{ by clouds: }\\\\beta_{c} = 0.1 + 0.9 \\\\frac n N
    



Parameters:
-----------

albedo:  the albedo :math:`\\\\alpha` of the surface

daily:  If true, the net radiation for daily averages will be
calculated ";

%feature("docstring")  cmf::atmosphere::Weather::to_string "std::string to_string() const

Returns a string representation. ";


// File: structcmf_1_1upslope_1_1_soil_layer_1_1wet.xml


// File: namespacecmf.xml
%feature("docstring")  cmf::apps::connect_cells_with_flux "def
cmf.connect_cells_with_flux(cells, connection, start_at_layer=0)

Connects all cells in cells (sequence or generator) with a flux
connection connection is an subclass of cmf.FluxConnection which
exposes the cell_connector callable                 (e.g. lateral
subsurface fluxes and surface manning flux) start_at_layer : if the
flux connection should only be used for deeper layers ";


// File: namespacecmf_1_1apps.xml
%feature("docstring")  cmf::apps::run_nash_cascade "int
cmf::apps::run_nash_cascade(int size) ";

%feature("docstring")  cmf::apps::run_reaches "int
cmf::apps::run_reaches(int levels, SolverType solver, int steps=0) ";


// File: namespacecmf_1_1atmosphere.xml
%feature("docstring")  cmf::atmosphere::extraterrestrial_radiation "double cmf::atmosphere::extraterrestrial_radiation(cmf::math::Time t,
double longitude=8, double latitude=51, double time_zone=1, bool
daily=0)

Calculates the global radiation in MJ/(m2 day) from the sun position
and the sunshine fraction.

Parameters:
-----------

t:  actual time step

longitude:  latitude:  Geographical position in degree. Latitude is
only taken into acount for subdaily calculation

time_zone:  Offset by timezone from GMT, eg. central Europe=1 US west
coast = -8

daily:  If true, the average radiation for the whole day is given
(therefore latitude and time zone ignored), otherwise the average of
the current hour is returned

The calculation of the global radiation
followshttp://www.fao.org/docrep/X0490E/x0490e07.htm#radiation.

The following formula is used:  :math:`\\\\phi` Latitude in :math:`rad`

:math:`\\\\delta = 0.409 \\\\sin\\\\left(\\\\frac{2\\\\pi}{365}DOY - 1.39\\\\right)` Declination, DOY is day of year

:math:`\\\\omega_s = \\\\arccos(-\\\\tan\\\\phi\\\\tan\\\\delta)` Sunset
angle

:math:`G_{sc} = 0.0802 \\\\frac{MJ}{m^2min}` Solar constant

:math:`d_r = 1+0.033 \\\\cos\\\\left(\\\\frac{2\\\\pi}{365}DOY\\\\right)`
Inverse relative distance Earth-Sun

:math:`b = \\\\frac{2\\\\pi(DOY-81)}{364}`

:math:`S_c = 0.1645\\\\sin(2b)-0.1255\\\\cos(b)-0.025\\\\sin(b)` Seasonal
correction for solar time

:math:`\\\\omega = \\\\frac{\\\\pi}{12} \\\\left(t_h+\\\\frac{(\\\\mbox{geogr. Longitude})^\\\\circ}{15^\\\\circ}-\\\\mbox{Timezone}+S_c-12\\\\right)` solar time in :math:`rad`

If daily: :math:`R_a = \\\\frac{24\\\\ 60}{\\\\pi}G_{sc}\\\\ d_r \\\\left(\\\\omega_s \\\\sin\\\\phi \\\\sin\\\\delta + \\\\cos\\\\phi \\\\cos\\\\delta \\\\sin\\\\omega_s\\\\right)`

If sub daily: :math:`R_a = \\\\frac{12\\\\ 24\\\\ 60}{\\\\pi}G_{sc}\\\\ d_r \\\\left(\\\\left(\\\\omega^+ -\\\\omega^-\\\\right) \\\\sin\\\\phi \\\\sin\\\\delta + \\\\cos\\\\phi \\\\cos\\\\delta \\\\left(\\\\sin\\\\omega^+ - \\\\sin\\\\omega^-\\\\right)\\\\right)`

:math:`\\\\omega^+,\\\\omega^- = \\\\omega \\\\pm\\\\frac{\\\\pi}{24}` ";

%feature("docstring")  cmf::atmosphere::global_radiation "double
cmf::atmosphere::global_radiation(double Ra, double height, double
sunshine_fraction)

Calculates the global radiation in MJ/(m2 day) from the sun position
and the sunshine fraction.

Parameters:
-----------

Ra:  extra terrestrial radiation

height:  Height above sea level

sunshine_fraction:  Fraction of sunshine hours per potential sunshine
duration in h/h

The calculation of the global radiation
followshttp://www.fao.org/docrep/X0490E/x0490e07.htm#radiation.

The following formula is used:  :math:`R_a(t, \\\\phi, \\\\lambda)`
Extraterrestrial radiation (
cmf::atmosphere::extraterrestrial_radiation) :math:`\\\\frac{MJ}{m^2 day}`

:math:`\\\\frac n N` Fractional sunshine duration

:math:`R_s = \\\\left(0.25+\\\\left(0.5+2\\\\ 10^{-5}z\\\\right)\\\\frac{n}{N}\\\\right)R_a` Global radiation in
:math:`\\\\frac{MJ}{m^2 day}`

:math:`z`: Height a.s.l. in m ";

%feature("docstring")  cmf::atmosphere::MJ_to_watts "double
cmf::atmosphere::MJ_to_watts(double MJ)

Transforms an energy flux from MJ/day to W. ";

%feature("docstring")  cmf::atmosphere::Pressure "double
cmf::atmosphere::Pressure(double height)

Returns the average air pressure for a height (m a.s.l.) ";

%feature("docstring")  cmf::atmosphere::rH_from_vpd "double
cmf::atmosphere::rH_from_vpd(double T, double vpd)

Returns the rel.

humidity in % for temperature T [degC] and vapor pressure deficit vpd
[Pa]

the rel. humidity is calculated from the vapor pressure deficit :math:`vpd = e_s - e_a` as: 

.. math::

    rH = 100 * \\\\frac{e_a}{e_s(T)}, e_a = e_s(T) -
    vpd

The definition is
fromhttp://www.fao.org/docrep/X0490E/x0490e07.htm#concepts

Parameters:
-----------

T:  Air temperature in degC

vpd:  Vapor pressure deficit in Pa

:math:`e_s(T)` is calculated using cmf::atmosphere::vapor_pressure(double)
";

%feature("docstring")  cmf::atmosphere::vapour_pressure "double
cmf::atmosphere::vapour_pressure(double T)

Returns the saturated vapor pressure in Pa for temperature T [degC].

The saturated vapor pressure :math:`e_s` is calculated follwing the
following formula 

.. math::

    e_s = 0.6108 \\\\exp{\\\\frac{17.27
    T}{T+237.3}}

The definition is
fromhttp://www.fao.org/docrep/X0490E/x0490e07.htm#concepts ";

%feature("docstring")  cmf::atmosphere::vpd_from_rH "double
cmf::atmosphere::vpd_from_rH(double T, double rH)

Returns the vapor pressure deficit in Pa for temperature T [degC] and
rel.

humidity rH [%]

The vapor pressure deficit :math:`e_s - e_a` is calculated from rel.
humidity as: 

.. math::

    e_s - e_a = (1-rH/100) * e_s(T)

The definition
is fromhttp://www.fao.org/docrep/X0490E/x0490e07.htm#concepts

Parameters:
-----------

T:  Air temperature in degC

rH:  Rel. humidity in %

:math:`e_s(T)` is calculated using cmf::atmosphere::vapor_pressure(double)
";

%feature("docstring")  cmf::atmosphere::watts_to_MJ "double
cmf::atmosphere::watts_to_MJ(double Watts)

Transforms an energy flux from W to MJ/day. ";


// File: namespacecmf_1_1describe.xml
%feature("docstring")  cmf::describe::describe "def
cmf.describe.describe(cmfobject, out=None)

Describes a cmf object in a file like object or returns the
description.  If no special description method for the class of
cmfobject is available, the function writes the string representation
:param cmfobject: any cmf object eg. project, Cell, timeseries :param
out: filelike object, if None function returns the description as
string :return: If out is None it returns the description as string,
else no return ";


// File: namespacecmf_1_1draw.xml


// File: namespacecmf_1_1draw_1_1cellmap.xml


// File: namespacecmf_1_1draw_1_1draw__misc.xml
%feature("docstring")  cmf::draw::draw_misc::bar_timeseries "def
cmf.draw.draw_misc.bar_timeseries(data, kwargs)

Makes a bar graph from a cmf.timeseries using pylab.bar :param data:
cmf.timeseries :param kwargs: Keyword arguments of pylab.bar :return:
as pylab.bar ";

%feature("docstring")  cmf::draw::draw_misc::plot_image "def
cmf.draw.draw_misc.plot_image(filename, kwargs)

Plots an image with an ESRI Worldfile as a map background. Uses
matplotlib.pylab.imshow :param filename: Filename of the image. :param
kwargs: Keyword arguments to imshow :return: Image from imshow ";

%feature("docstring")  cmf::draw::draw_misc::plot_timeseries "def
cmf.draw.draw_misc.plot_timeseries(data, style='-', kwargs)

Plots a cmf.timeseries as a line using pylab.plot :param data:
cmf.timeseries :param style: Style code for pylab.plot :param kwargs:
Keyword arguments for pylab.plot :return: matplotlib line object ";


// File: namespacecmf_1_1draw_1_1hillplot.xml


// File: namespacecmf_1_1draw_1_1shapemap.xml


// File: namespacecmf_1_1fit__retention__curve.xml
%feature("docstring")  cmf::fit_retention_curve::fit_bc "def
cmf.fit_retention_curve.fit_bc(pF, theta, count=1, verbose=False)

Fits the vanGenuchten Mualem retention curve into measured soilphysics
values :param pF: A sequence of pF values :param theta: A sequence of
the volumetric water content in l water/l soil at the respective pF
value :param count: Times to repeat the minimization to avoid local
minima :param verbose: If True: Print the values in between :return:
(Retentioncurve, RMSE) ";

%feature("docstring")  cmf::fit_retention_curve::fit_vgm "def
cmf.fit_retention_curve.fit_vgm(pF, theta, fit_m=False,
fit_theta_r=False, count=1, verbose=False)

Fits the vanGenuchten Mualem retention curve into measured soilphysics
values :param pF: A sequence of pF values :param theta: A sequence of
the volumetric water content in l water/l soil at the respective pF
value :param fit_m: If True, the retention curve is fitted with a
variable m (deprecated by vanGenuchten) :param fit_theta_r:  If True,
the retention curve is fitted using a theta_r (kind of deprecated by
vanGenuchten) :param count: Times to repeat the minimization to avoid
local minima :param verbose: If True: Print the values in between
:return: (Retentioncurve, RMSE) ";


// File: namespacecmf_1_1geometry.xml
%feature("docstring")  cmf::geometry::geocell::distance "double
cmf::geometry::distance(const point &p1, const point &p2) ";

%feature("docstring")  cmf::geometry::geocell::dot "double
cmf::geometry::dot(const point &p1, const point &p2) ";


// File: namespacecmf_1_1geometry_1_1geocell.xml
%feature("docstring")  cmf::geometry::geocell::add_geometry_property "def cmf.geometry.geocell.add_geometry_property()

Extends the Cell class with a geometry attribute :return: ";

%feature("docstring")  cmf::geometry::geocell::create_cell "def
cmf.geometry.geocell.create_cell(project, polygon, height, id=None,
with_surfacewater=True)

Creates a cell from a shapely polygon and stores the geometry in
cell.geometry  :param project: the cmf project of the cell :param
polygon: the shapely Polygon :param height: the height of the cell
:param id: the id of the cell, only set if not None :param
with_surfacewater: True, if a surfacewater storage will be created
:return: The new cell ";

%feature("docstring")  cmf::geometry::geocell::mesh_project "def
cmf.geometry.geocell.mesh_project(project, min_intersection=0,
verbose=False)

Get the topologcial information from the geometry This may take some
time :param project: The cmf project. The cells of the project need to
have geometry :param min_intersection: Minimum intersection length in
m :param verbose: Set True for report of action and additional
warnings :return: ";


// File: namespacecmf_1_1geometry_1_1qtree.xml


// File: namespacecmf_1_1jacobian.xml
%feature("docstring")  cmf::jacobian::connected_states "def
cmf.jacobian.connected_states(states)

Get a set of all connected nodes, indicated by the node_id's  :param
states: An iterable of states :return: a set of node_id tuples ";

%feature("docstring")  cmf::jacobian::connector_matrix "def
cmf.jacobian.connector_matrix(states, compression_factor=1)

Returns a matrix that shows the connectivity between the given states
:param states: A sequence of states to create the matrix :param
compression_factor: Large matrices can compressed with a factor.
:return: A symmetric 2d matrix with 1 for connected states and 0 for
unconnected states. Compressed matrices contain larger numbers for the
count of connection in the compressed field ";


// File: namespacecmf_1_1maps.xml
%feature("docstring")  cmf::maps::distance "def cmf.maps.distance(p1,
p2) ";


// File: namespacecmf_1_1math.xml
%feature("docstring")  cmf::math::root_finding::get_parallel_threads "int cmf::math::get_parallel_threads()

Returns the max number of threads used by OpenMP in parallel sections
of the code. ";

%feature("docstring")  cmf::math::root_finding::nash_sutcliffe "double cmf::math::nash_sutcliffe(const cmf::math::timeseries &model,
const cmf::math::timeseries &observation)

Calculates the Nash-Sutcliffe efficiency of a modeled timeseries in
comparison with an observed timeseries.

The Nash-Sutcliffe efficiancy is defined as: 

.. math::

     E = 1 -
    \\\\frac{\\\\sum_{t=1}^{T}(M_t - O_t)^2}{\\\\sum_{t=1}^{T}(O_t -
    \\\\overline{O})^2}

where  :math:`T` is the number of observation time
steps

:math:`M` is the timeseries of model results matchinig O

:math:`O` is the timeseries containing observations

:math:`\\\\overline{O}` is the arithmetic mean of observations ";

%feature("docstring")  cmf::math::root_finding::set_parallel_threads "int cmf::math::set_parallel_threads(int numthreads)

Set the number of threads used by OpenMP in parallel sections of the
code. ";

%feature("docstring")  cmf::math::root_finding::timespan "Time
cmf::math::timespan(long long ms) ";


// File: namespacecmf_1_1math_1_1root__finding.xml


// File: namespacecmf_1_1river.xml
%feature("docstring")  cmf::river::make_river_gap "double
cmf::river::make_river_gap(Reach::ptr root_reach)

Ensures that rivers have a monotone downward flow direction.

Reaches with a bottom higher than any upstream reach are lowered to
the minimum height of any (possibly distant) upstream reach. ";


// File: namespacecmf_1_1stopwatch.xml


// File: namespacecmf_1_1upslope.xml
%feature("docstring")  cmf::upslope::connections::cell2cellflux "cmf::math::num_array cmf::upslope::cell2cellflux(cmf::upslope::Cell
&source, cmf::upslope::Cell &target, cmf::math::Time t, bool
subsurface_only=false)

Calculates the flux in m3/day that flows from a source cell to a
target cell.

Parameters:
-----------

source:  the cell to investigate

target:  - the cell where the water is flowing

t:  Time of query

subsurface_only:  if true, fluxes from the surfacewater to the
surfacewater are ignored. Default is false

A num_array of size source.layer_count() containing all fluxes from
the layers of source to the layers of target. If subsurface_only is
false the array has the size source.layer_count()+1 and contains the
surfacewater flux in position 0 ";

%feature("docstring")  cmf::upslope::connections::cell_distance "double cmf::upslope::cell_distance(cmf::upslope::Cell &c1,
cmf::upslope::Cell &c2) ";

%feature("docstring")  cmf::upslope::connections::cell_flux_directions
"cmf::geometry::point_vector
cmf::upslope::cell_flux_directions(cmf::upslope::cells_ref cells,
cmf::math::Time) ";

%feature("docstring")  cmf::upslope::connections::cell_positions "cmf::geometry::point_vector
cmf::upslope::cell_positions(cmf::upslope::cells_ref cells) ";

%feature("docstring")
cmf::upslope::connections::connect_cells_with_flux "void
cmf::upslope::connect_cells_with_flux(cells_ref cells, const
cmf::upslope::CellConnector &connect, int start_at_layer=0)

Connects all adjacent cells with a flux connection, implementing the
CellConnector protocol. ";

%feature("docstring")  cmf::upslope::connections::fill_sinks "int
cmf::upslope::fill_sinks(cells_ref cells, double min_difference=0.001)

Fills the sinks in a network. Unstable! Might create an infinite loop.
";

%feature("docstring")  cmf::upslope::connections::find_cell "cmf::upslope::Cell* cmf::upslope::find_cell(cells_ref,
cmf::geometry::point p, double max_dist=1e20)

Finds the nearest cell for a position. ";

%feature("docstring")  cmf::upslope::connections::get_area "double
cmf::upslope::get_area(cells_ref cells) ";

%feature("docstring")  cmf::upslope::connections::get_boundary_cells "cell_vector cmf::upslope::get_boundary_cells(cells_ref cells)

Gets the outer cells of a network. Unstable! Might create an infinite
loop. ";

%feature("docstring")  cmf::upslope::connections::get_center "cmf::geometry::point cmf::upslope::get_center(cells_ref cells) ";

%feature("docstring")  cmf::upslope::connections::get_connections "cmf::water::connection_list cmf::upslope::get_connections(cells_ref
cells)

Gets all connections of a bunch of cells. ";

%feature("docstring")  cmf::upslope::connections::pF_to_waterhead "double cmf::upslope::pF_to_waterhead(double pF)

Converts a pF value to a height of a water column in m. ";

%feature("docstring")
cmf::upslope::connections::pressure_to_waterhead "double
cmf::upslope::pressure_to_waterhead(double Pressure)

Converts a pressure in Pa to a length of a water column in m. ";

%feature("docstring")  cmf::upslope::connections::waterhead_to_pF "double cmf::upslope::waterhead_to_pF(double waterhead)

Converts a height of a water column to a pF value. ";

%feature("docstring")
cmf::upslope::connections::waterhead_to_pressure "double
cmf::upslope::waterhead_to_pressure(double waterhead)

Converts a height of a water column in m to a pressure in Pa. ";


// File: namespacecmf_1_1upslope_1_1connections.xml
%feature("docstring")  cmf::upslope::connections::snowfraction "real
cmf::upslope::connections::snowfraction(real T)

A function to calculate the snow fraction of the precipitation
according to the air temperature.

Returns 0.0 for T>+1 degC, 1.0 for T<-1degC and interpolates linear
between. Values between 0 and 1 can be interpreted as sleet ";


// File: namespacecmf_1_1upslope_1_1_e_t.xml
%feature("docstring")  cmf::upslope::ET::PenmanMonteith "real
cmf::upslope::ET::PenmanMonteith(real Rn, real ra, real rs, real T,
real vap_press_deficit)

Returns the potential ET after Penman-Monteith using some
simplifications for a given Radiation balance, aerodynamic and surface
resistances, and a vapor pressure deficit.



.. math::

     ET = \\\\frac{\\\\Delta R_n}{\\\\lambda \\\\Delta + \\\\gamma +
    \\\\gamma \\\\frac{r_s}{r_a}} + \\\\frac{c_p\\\\rho_a}{\\\\Delta +
    \\\\gamma + \\\\gamma \\\\frac{r_s}{r_a}} \\\\frac{e_s - e_a}{r_a}
    

where  :math:`ET` is the evapotranspiration in :math:`\\\\frac{kg}{m^2 day}\\\\approx \\\\frac{mm}{day}`

:math:`\\\\Delta \\\\left[\\\\frac{kPa}{k}\\\\right]= 4098\\\\ 0.618 \\\\exp\\\\left(\\\\frac{17.27 T}{T+237.3}\\\\right (T+237.3)^{-2}`
is the slope of vapor pressure

:math:`R_n \\\\left[\\\\frac{MJ}{m^2 day}\\\\right]` is the radiation
balance

:math:`r_s \\\\left[\\\\frac s m\\\\right]` is the surface resistance

:math:`r_a \\\\left[\\\\frac s m\\\\right]` is the aerodynamic resistance

:math:`\\\\gamma = 0.067 \\\\left[\\\\frac{kPa}{k}\\\\right]` is the
psychrometer constant

:math:`e_s - e_a \\\\left[kPa\\\\right]` is the vapor pressure deficit

Parameters:
-----------

Rn:  Radiation balance in :math:`\\\\frac{MJ}{m^2 day}`

ra:  Aerodynamic resistance in :math:`\\\\frac s m`

rs:  Surface resistance in :math:`\\\\frac s m`, is 0 for free water

T:  Actual Temperature in :math:`^\\\\circ C`

vap_press_deficit:  Deficit of vapor pressure :math:`kPa` ";

%feature("docstring")  cmf::upslope::ET::PenmanMonteith "real
cmf::upslope::ET::PenmanMonteith(cmf::atmosphere::Weather A, const
cmf::upslope::vegetation::Vegetation &veg, double h)

Returns the potential ET after Penman-Monteith using some
simplifications for a weather and a vegetation object.

aerodynamic and surface resistances, and a vapor pressure deficit

Parameters:
-----------

A:  Current weather

veg:  Vegetation data

h:  Height above sea level in m (for air pressure estimation) ";


// File: namespacecmf_1_1upslope_1_1vegetation.xml


// File: namespacecmf_1_1water.xml
%feature("docstring")  cmf::water::can_set_flux "bool
cmf::water::can_set_flux(flux_node::ptr source, flux_node::ptr target)

Checks if a constant flux between two nodes can be set.

Returns true if the nodes are connected by an
external_control_connection ";

%feature("docstring")  cmf::water::count_node_references "int
cmf::water::count_node_references(flux_node::ptr node) ";

%feature("docstring")  cmf::water::get_higher_node "flux_node::ptr
cmf::water::get_higher_node(flux_node::ptr node1, flux_node::ptr
node2) ";

%feature("docstring")  cmf::water::get_lower_node "flux_node::ptr
cmf::water::get_lower_node(flux_node::ptr node1, flux_node::ptr node2)
";

%feature("docstring")  cmf::water::replace_node "int
cmf::water::replace_node(cmf::water::flux_node::ptr oldnode,
cmf::water::flux_node::ptr newnode) ";

%feature("docstring")  cmf::water::set_flux "void
cmf::water::set_flux(flux_node::ptr source, flux_node::ptr target,
real flux_value)

Sets a constant flux between two nodes, if an
external_control_connection exists. ";

%feature("docstring")  cmf::water::system_bridge "SystemBridge::ptr
cmf::water::system_bridge(cmf::project &p, flux_node::ptr upper,
flux_node::ptr lower)

Creates a SystemBridge object.

This is an advanced feature for tuning of the calculation time.

A SystemBridge can be used to replace an existing connection between
nodes. After installation, the two nodes can more safely be added to
different integrator systems. One node (called upper) is connected
with the system bridge with the connection formerly connecting the
nodes, the second node (called lower) is connected to the system
bridge with as a Neumann boundary condition. The flux equals the
average flux of the connection upper <-> SystemBridge. Therefore, the
system bridge must become an integratable of the integrator system the
upper node belongs to. Use as an upper system (system upper node is
belonging to) the faster reacting system. For the connection between
upper and SystemBridge, the SystemBridge reacts as an Dirichlet
boundary condition, providing the potential of the lower node. ";


// File: namespacecmf__core.xml
%feature("docstring")  cmf_core::aquifer_cast "def
cmf_core.aquifer_cast(args, kwargs)

aquifer_cast(cmf::water::flux_node::ptr for_cast) ->
cmf::upslope::aquifer::ptr ";

%feature("docstring")  cmf_core::AsCMFtime "def
cmf_core.AsCMFtime(date)

Converts a python datetime to cmf.Time ";

%feature("docstring")  cmf_core::boltzmann "def
cmf_core.boltzmann(args, kwargs)

boltzmann(real x, real x_half, real tau) -> real ";

%feature("docstring")
cmf_core::BrooksCoreyRetentionCurve_CreateFrom2Points "def
cmf_core.BrooksCoreyRetentionCurve_CreateFrom2Points(args, kwargs)

BrooksCoreyRetentionCurve_CreateFrom2Points(real ksat, real porosity,
real theta1, real theta2, real psi_1, real psi_2) ->
BrooksCoreyRetentionCurve ";

%feature("docstring")  cmf_core::can_set_flux "def
cmf_core.can_set_flux(args, kwargs)

can_set_flux(cmf::water::flux_node::ptr source,
cmf::water::flux_node::ptr target) -> bool  bool
cmf::water::can_set_flux(flux_node::ptr source, flux_node::ptr target)
Checks if a constant flux between two nodes can be set.  Returns true
if the nodes are connected by an external_control_connection ";

%feature("docstring")  cmf_core::CanopyOverflow_use_for_cell "def
cmf_core.CanopyOverflow_use_for_cell(args, kwargs)

CanopyOverflow_use_for_cell(Cell cell) -> CanopyOverflow ";

%feature("docstring")  cmf_core::cell2cellflux "def
cmf_core.cell2cellflux(args, kwargs)

cell2cellflux(Cell source, Cell target, Time t, bool
subsurface_only=False) -> cmf::math::num_array ";

%feature("docstring")  cmf_core::cell_distance "def
cmf_core.cell_distance(args, kwargs)

cell_distance(Cell c1, Cell c2) -> double ";

%feature("docstring")  cmf_core::cell_flux_directions "def
cmf_core.cell_flux_directions(args, kwargs)

cell_flux_directions(cell_vector cells, Time arg2) -> point_vector ";

%feature("docstring")  cmf_core::cell_positions "def
cmf_core.cell_positions(args, kwargs)

cell_positions(cell_vector cells) -> point_vector ";

%feature("docstring")  cmf_core::connect_cells_with_flux "def
cmf_core.connect_cells_with_flux(args, kwargs)

connect_cells_with_flux(cell_vector cells, CellConnector connect, int
start_at_layer=0) ";

%feature("docstring")  cmf_core::count_node_references "def
cmf_core.count_node_references(args, kwargs)

count_node_references(cmf::water::flux_node::ptr node) -> int  int
cmf::water::count_node_references(flux_node::ptr node) ";

%feature("docstring")  cmf_core::CVodeIntegrator "def
cmf_core.CVodeIntegrator(project, tolerance=1e-9)

Backwards compatibility layer for the CVodeIntegrator.  Will return a
CVodeKrylov solver as in cmf 1.x.  Parameters ---------- project CMF
project tolerance:     Solver tolerance  Returns ------- CVodeKrylov
The integrator ";

%feature("docstring")
cmf_core::DiffusiveSurfaceRunoff_get_linear_slope "def
cmf_core.DiffusiveSurfaceRunoff_get_linear_slope(args)

DiffusiveSurfaceRunoff_get_linear_slope() -> real ";

%feature("docstring")
cmf_core::DiffusiveSurfaceRunoff_set_linear_slope "def
cmf_core.DiffusiveSurfaceRunoff_set_linear_slope(args, kwargs)

DiffusiveSurfaceRunoff_set_linear_slope(real width) ";

%feature("docstring")  cmf_core::distance "def
cmf_core.distance(args, kwargs)

distance(point p1, point p2) -> double ";

%feature("docstring")  cmf_core::dot "def cmf_core.dot(args, kwargs)

dot(point p1, point p2) -> double ";

%feature("docstring")  cmf_core::EnergyBudgetSnowMelt_use_for_cell "def cmf_core.EnergyBudgetSnowMelt_use_for_cell(args, kwargs)

EnergyBudgetSnowMelt_use_for_cell(Cell cell) ";

%feature("docstring")  cmf_core::extraterrestrial_radiation "def
cmf_core.extraterrestrial_radiation(args, kwargs)

extraterrestrial_radiation(Time t, double longitude=8, double
latitude=51, double time_zone=1, bool daily=False) -> double ";

%feature("docstring")  cmf_core::fill_sinks "def
cmf_core.fill_sinks(args, kwargs)

fill_sinks(cell_vector cells, double min_difference=0.001) -> int ";

%feature("docstring")  cmf_core::find_cell "def
cmf_core.find_cell(args, kwargs)

find_cell(cell_vector arg1, point p, double max_dist=1e20) -> Cell ";

%feature("docstring")  cmf_core::geo_mean "def
cmf_core.geo_mean(args, kwargs)

geo_mean(real a, real b) -> real ";

%feature("docstring")  cmf_core::get_area "def
cmf_core.get_area(args, kwargs)

get_area(cell_vector cells) -> double ";

%feature("docstring")  cmf_core::get_boundary_cells "def
cmf_core.get_boundary_cells(args, kwargs)

get_boundary_cells(cell_vector cells) -> cell_vector ";

%feature("docstring")  cmf_core::get_center "def
cmf_core.get_center(args, kwargs)

get_center(cell_vector cells) -> point ";

%feature("docstring")  cmf_core::get_connections "def
cmf_core.get_connections(args, kwargs)

get_connections(cell_vector cells) -> connection_list ";

%feature("docstring")  cmf_core::get_higher_node "def
cmf_core.get_higher_node(args, kwargs)

get_higher_node(cmf::water::flux_node::ptr node1,
cmf::water::flux_node::ptr node2) -> cmf::water::flux_node::ptr
flux_node::ptr cmf::water::get_higher_node(flux_node::ptr node1,
flux_node::ptr node2) ";

%feature("docstring")  cmf_core::get_lower_node "def
cmf_core.get_lower_node(args, kwargs)

get_lower_node(cmf::water::flux_node::ptr node1,
cmf::water::flux_node::ptr node2) -> cmf::water::flux_node::ptr
flux_node::ptr cmf::water::get_lower_node(flux_node::ptr node1,
flux_node::ptr node2) ";

%feature("docstring")  cmf_core::get_parallel_threads "def
cmf_core.get_parallel_threads(args)

get_parallel_threads() -> int ";

%feature("docstring")  cmf_core::global_radiation "def
cmf_core.global_radiation(args, kwargs)

global_radiation(double Ra, double height, double sunshine_fraction)
-> double  double cmf::atmosphere::global_radiation(cmf::math::Time t,
double height, double sunshine_fraction, double longitude=8, double
latitude=51, double time_zone=1, bool daily=0)  Calculates the global
radiation in MJ/(m2 day) from the sun position and the sunshine
fraction.  Parameters: -----------  t:  actual time step  height:
Height above sea level  sunshine_fraction:  Fraction of sunshine hours
per potential sunshine duration in h/h  longitude:  latitude:
Geographical position in degree. Latitude is only taken into acount
for subdaily calculation  time_zone:  Offset by timezone from GMT, eg.
central Europe=1 US west coast = -8  daily:  If true, the average
radiation for the whole day is given (therefore latitude and time zone
ignored), otherwise the average of the current hour is returned  The
calculation of the global radiation
followshttp://www.fao.org/docrep/X0490E/x0490e07.htm#radiation.  The
following formula is used:   .. math::       \\\\\\\\phi &=&
\\\\\\\\frac{(\\\\\\\\mbox{geogr. Latitude})^\\\\\\\\circ
\\\\\\\\pi}{180^\\\\\\\\circ}     \\\\\\\\mbox{ Latitude in }rad
\\\\\\\\\\\\\\\\ \\\\\\\\delta &=& 0.409
\\\\\\\\sin\\\\\\\\left(\\\\\\\\frac{2\\\\\\\\pi}{365}DOY -
1.39\\\\\\\\right) \\\\\\\\mbox{     Declination, DOY is day of
year}\\\\\\\\\\\\\\\\ \\\\\\\\omega_s &=&
\\\\\\\\arccos(-\\\\\\\\tan\\\\\\\\phi\\\\\\\\tan\\\\\\\\delta)
\\\\\\\\mbox{ Sunset angle}     \\\\\\\\\\\\\\\\ G_{sc} &=& 0.0802
\\\\\\\\frac{MJ}{m^2min} \\\\\\\\mbox{Solar     constant}
\\\\\\\\\\\\\\\\ d_r &=& 1+0.033
\\\\\\\\cos\\\\\\\\left(\\\\\\\\frac{2\\\\\\\\pi}{365}DOY\\\\\\\\right)
\\\\\\\\mbox{Inverse     relative distance Earth-Sun} \\\\\\\\\\\\\\\\
b &=&     \\\\\\\\frac{2\\\\\\\\pi(DOY-81)}{364}\\\\\\\\\\\\\\\\ S_c
&=&     0.1645\\\\\\\\sin(2b)-0.1255\\\\\\\\cos(b)-0.025\\\\\\\\sin(b)
\\\\\\\\mbox{ Seasonal     correction for solar time} \\\\\\\\\\\\\\\\
\\\\\\\\omega &=& \\\\\\\\frac {\\\\\\\\pi}     {12}
\\\\\\\\left(t_h+\\\\\\\\frac{(\\\\\\\\mbox{geogr.
Longitude})^\\\\\\\\circ}{15}-\\\\\\\\mbox{Timezone}+S_c-12\\\\\\\\right)
\\\\\\\\mbox{ solar time in }rad \\\\\\\\\\\\\\\\ \\\\\\\\mbox{If
daily} \\\\\\\\\\\\\\\\ R_a     &=& \\\\\\\\frac{24\\\\\\\\
60}{\\\\\\\\pi}G_{sc}\\\\\\\\ d_r \\\\\\\\left(\\\\\\\\omega_s
\\\\\\\\sin\\\\\\\\phi \\\\\\\\sin\\\\\\\\delta +
\\\\\\\\cos\\\\\\\\phi \\\\\\\\cos\\\\\\\\delta
\\\\\\\\sin\\\\\\\\omega_s\\\\\\\\right) \\\\\\\\mbox{Extraterrestrial
radiation }     \\\\\\\\frac{MJ}{m^2 day} \\\\\\\\\\\\\\\\
\\\\\\\\mbox{If hourly} \\\\\\\\\\\\\\\\ R_a &=&
\\\\\\\\frac{12\\\\\\\\ 24\\\\\\\\ 60}{\\\\\\\\pi}G_{sc}\\\\\\\\ d_r
\\\\\\\\left(\\\\\\\\left(\\\\\\\\omega^+
-\\\\\\\\omega^-\\\\\\\\right) \\\\\\\\sin\\\\\\\\phi
\\\\\\\\sin\\\\\\\\delta + \\\\\\\\cos\\\\\\\\phi
\\\\\\\\cos\\\\\\\\delta     \\\\\\\\left(\\\\\\\\sin\\\\\\\\omega^+ -
\\\\\\\\sin\\\\\\\\omega^-\\\\\\\\right)\\\\\\\\right)
\\\\\\\\\\\\\\\\ && \\\\\\\\omega^+,\\\\\\\\omega^- = \\\\\\\\omega
\\\\\\\\pm\\\\\\\\frac{\\\\\\\\pi}{24} \\\\\\\\\\\\\\\\ \\\\\\\\frac n
N &=&     \\\\\\\\mbox{Fractional sunshine duration} \\\\\\\\\\\\\\\\
R_s &=&     \\\\\\\\left(0.25+\\\\\\\\left(0.5+2\\\\\\\\
10^{-5}z\\\\\\\\right)\\\\\\\\frac{n}{N}\\\\\\\\right)R_a
\\\\\\\\mbox{Global     radiation in }\\\\\\\\frac{MJ}{m^2 day}
\\\\\\\\\\\\\\\\ && z=\\\\\\\\mbox{Height     a.s.l. in }m
\\\\\\\\\\\\\\\\ ";

%feature("docstring")  cmf_core::GreenAmptInfiltration_use_for_cell "def cmf_core.GreenAmptInfiltration_use_for_cell(args, kwargs)

GreenAmptInfiltration_use_for_cell(Cell c) ";

%feature("docstring")  cmf_core::HargreaveET_use_for_cell "def
cmf_core.HargreaveET_use_for_cell(args, kwargs)

HargreaveET_use_for_cell(Cell cell) ";

%feature("docstring")  cmf_core::harmonic_mean "def
cmf_core.harmonic_mean(args, kwargs)

harmonic_mean(real a, real b) -> real ";

%feature("docstring")  cmf_core::IDWRainfall_create "def
cmf_core.IDWRainfall_create(args, kwargs)

IDWRainfall_create(project project, point position, double z_weight,
double power) -> cmf::atmosphere::RainSource::ptr ";

%feature("docstring")  cmf_core::integrate_over "def
cmf_core.integrate_over(item, solver=None)

Returns a suitable cmf.integratable implementation for item, if
available. The created integratable is integrated by solver, if given
";

%feature("docstring")  cmf_core::MacroPore_cast "def
cmf_core.MacroPore_cast(args, kwargs)

MacroPore_cast(cmf::water::flux_node::ptr node) ->
cmf::upslope::MacroPore::ptr ";

%feature("docstring")  cmf_core::MacroPore_create "def
cmf_core.MacroPore_create(args, kwargs)

MacroPore_create(cmf::upslope::SoilLayer::ptr layer, real
porefraction=0.05, real Ksat=10, real density=0.05, real
porefraction_wilt=-1., real K_shape=0.0) ->
cmf::upslope::MacroPore::ptr ";

%feature("docstring")  cmf_core::make_river_gap "def
cmf_core.make_river_gap(args, kwargs)

make_river_gap(cmf::river::Reach::ptr root_reach) -> double  double
cmf::river::make_river_gap(Reach::ptr root_reach)  Ensures that rivers
have a monotone downward flow direction.  Reaches with a bottom higher
than any upstream reach are lowered to the minimum height of any
(possibly distant) upstream reach. ";

%feature("docstring")  cmf_core::MatrixInfiltration_use_for_cell "def
cmf_core.MatrixInfiltration_use_for_cell(args, kwargs)

MatrixInfiltration_use_for_cell(Cell c) ";

%feature("docstring")  cmf_core::maximum "def cmf_core.maximum(args,
kwargs)

maximum(real a, real b) -> real ";

%feature("docstring")  cmf_core::mean "def cmf_core.mean(args,
kwargs)

mean(real a, real b) -> real ";

%feature("docstring")  cmf_core::minimum "def cmf_core.minimum(args,
kwargs)

minimum(real a, real b) -> real ";

%feature("docstring")  cmf_core::minmax "def cmf_core.minmax(args,
kwargs)

minmax(real x, real min, real max) -> real ";

%feature("docstring")  cmf_core::MJ_to_watts "def
cmf_core.MJ_to_watts(args, kwargs)

MJ_to_watts(double MJ) -> double ";

%feature("docstring")  cmf_core::nash_sutcliffe "def
cmf_core.nash_sutcliffe(args, kwargs)

nash_sutcliffe(timeseries model, timeseries observation) -> double ";

%feature("docstring")  cmf_core::NeumannBoundary_create "def
cmf_core.NeumannBoundary_create(args, kwargs)

NeumannBoundary_create(cmf::water::flux_node::ptr target) ->
cmf::water::NeumannBoundary::ptr ";

%feature("docstring")  cmf_core::OpenWaterStorage_cast "def
cmf_core.OpenWaterStorage_cast(args, kwargs)

OpenWaterStorage_cast(cmf::water::flux_node::ptr node) ->
cmf::river::OpenWaterStorage::ptr ";

%feature("docstring")  cmf_core::OpenWaterStorage_create "def
cmf_core.OpenWaterStorage_create(args)

create(project _project, real Area) ->
cmf::river::OpenWaterStorage::ptr OpenWaterStorage_create(project
_project, IVolumeHeightFunction base_geo) ->
cmf::river::OpenWaterStorage::ptr ";

%feature("docstring")  cmf_core::PenmanMonteith "def
cmf_core.PenmanMonteith(args)

PenmanMonteith(real Rn, real ra, real rs, real T, real
vap_press_deficit) -> real PenmanMonteith(Weather A, Vegetation veg,
double h) -> real  real
cmf::upslope::ET::PenmanMonteith(cmf::atmosphere::Weather A, const
cmf::upslope::vegetation::Vegetation &veg, double h)  Returns the
potential ET after Penman-Monteith using some simplifications for a
weather and a vegetation object.  aerodynamic and surface resistances,
and a vapor pressure deficit  Parameters: -----------  A:  Current
weather  veg:  Vegetation data  h:  Height above sea level in m (for
air pressure estimation) ";

%feature("docstring")  cmf_core::PenmanMonteithET_r_a "def
cmf_core.PenmanMonteithET_r_a(args, kwargs)

PenmanMonteithET_r_a(Weather A, real veg_height) -> real ";

%feature("docstring")  cmf_core::PenmanMonteithET_r_s "def
cmf_core.PenmanMonteithET_r_s(args, kwargs)

PenmanMonteithET_r_s(Vegetation veg) -> real ";

%feature("docstring")  cmf_core::PenmanMonteithET_use_for_cell "def
cmf_core.PenmanMonteithET_use_for_cell(args, kwargs)

PenmanMonteithET_use_for_cell(Cell cell) ";

%feature("docstring")  cmf_core::pF_to_waterhead "def
cmf_core.pF_to_waterhead(args, kwargs)

pF_to_waterhead(double pF) -> double ";

%feature("docstring")  cmf_core::piecewise_linear "def
cmf_core.piecewise_linear(args, kwargs)

piecewise_linear(real x, real xmin, real xmax, real ymin=0, real
ymax=1) -> real ";

%feature("docstring")  cmf_core::point_distance "def
cmf_core.point_distance(args, kwargs)

point_distance(point p1, point p2) -> double ";

%feature("docstring")  cmf_core::Pressure "def
cmf_core.Pressure(args, kwargs)

Pressure(double height) -> double  double
cmf::atmosphere::Pressure(double height)  Returns the average air
pressure for a height (m a.s.l.) ";

%feature("docstring")  cmf_core::pressure_to_waterhead "def
cmf_core.pressure_to_waterhead(args, kwargs)

pressure_to_waterhead(double Pressure) -> double ";

%feature("docstring")  cmf_core::PriestleyTaylorET_use_for_cell "def
cmf_core.PriestleyTaylorET_use_for_cell(args, kwargs)

PriestleyTaylorET_use_for_cell(Cell cell) ";

%feature("docstring")  cmf_core::RainfallStation_create "def
cmf_core.RainfallStation_create(args, kwargs)

RainfallStation_create(size_t Id, std::string Name, timeseries Data,
point position) -> cmf::atmosphere::RainfallStation::ptr ";

%feature("docstring")
cmf_core::RainfallStationReference_from_nearest_station "def
cmf_core.RainfallStationReference_from_nearest_station(args, kwargs)

RainfallStationReference_from_nearest_station(project project, point
position, double z_weight) ->
cmf::atmosphere::RainfallStationReference::ptr ";

%feature("docstring")
cmf_core::RainfallStationReference_from_station_id "def
cmf_core.RainfallStationReference_from_station_id(args, kwargs)

RainfallStationReference_from_station_id(project project, point
position, size_t id) -> cmf::atmosphere::RainfallStationReference::ptr
";

%feature("docstring")  cmf_core::Reach_create "def
cmf_core.Reach_create(args, kwargs)

Reach_create(project project, IChannel shape, bool diffusive=False) ->
cmf::river::Reach::ptr ";

%feature("docstring")  cmf_core::replace_node "def
cmf_core.replace_node(args, kwargs)

replace_node(cmf::water::flux_node::ptr oldnode,
cmf::water::flux_node::ptr newnode) -> int  int
cmf::water::replace_node(cmf::water::flux_node::ptr oldnode,
cmf::water::flux_node::ptr newnode) ";

%feature("docstring")  cmf_core::rH_from_vpd "def
cmf_core.rH_from_vpd(args, kwargs)

rH_from_vpd(double T, double vpd) -> double  double
cmf::atmosphere::rH_from_vpd(double T, double vpd)  Returns the rel.
humidity in % for temperature T [degC] and vapor pressure deficit vpd
[Pa]  the rel. humidity is calculated from the vapor pressure deficit
:math:`vpd = e_s - e_a` as:   .. math::      rH = 100 *
\\\\\\\\frac{e_a}{e_s(T)}, e_a = e_s(T) -     vpd  The definition is
fromhttp://www.fao.org/docrep/X0490E/x0490e07.htm#concepts Parameters:
-----------  T:  Air temperature in degC  vpd:  Vapor pressure deficit
in Pa  :math:`e_s(T)` is calculated using
cmf::atmosphere::vapor_pressure(double) ";

%feature("docstring")  cmf_core::Richards_lateral_usebaseflow "def
cmf_core.Richards_lateral_usebaseflow(args, kwargs)

Richards_lateral_usebaseflow(bool use) ";

%feature("docstring")  cmf_core::Richards_use_for_cell "def
cmf_core.Richards_use_for_cell(args, kwargs)

Richards_use_for_cell(Cell cell, bool no_override=True) ";

%feature("docstring")  cmf_core::RutterInterception_use_for_cell "def
cmf_core.RutterInterception_use_for_cell(args, kwargs)

RutterInterception_use_for_cell(Cell cell) -> RutterInterception ";

%feature("docstring")  cmf_core::set_flux "def
cmf_core.set_flux(args, kwargs)

set_flux(cmf::water::flux_node::ptr source, cmf::water::flux_node::ptr
target, real flux_value)  void cmf::water::set_flux(flux_node::ptr
source, flux_node::ptr target, real flux_value)  Sets a constant flux
between two nodes, if an external_control_connection exists. ";

%feature("docstring")  cmf_core::set_parallel_threads "def
cmf_core.set_parallel_threads(args, kwargs)

set_parallel_threads(int numthreads) -> int ";

%feature("docstring")
cmf_core::ShuttleworthWallace_set_RSS_parameters "def
cmf_core.ShuttleworthWallace_set_RSS_parameters(args, kwargs)

ShuttleworthWallace_set_RSS_parameters(double _RSSa=500., double
_RSSb=1.0, double _RSSa_pot=-3.22) ";

%feature("docstring")  cmf_core::ShuttleworthWallace_use_for_cell "def cmf_core.ShuttleworthWallace_use_for_cell(args, kwargs)

ShuttleworthWallace_use_for_cell(Cell cell) ->
cmf::upslope::ET::ShuttleworthWallace::ptr ";

%feature("docstring")  cmf_core::sign "def cmf_core.sign(args,
kwargs)

sign(real x) -> real ";

%feature("docstring")  cmf_core::SimpleInfiltration_use_for_cell "def
cmf_core.SimpleInfiltration_use_for_cell(args, kwargs)

SimpleInfiltration_use_for_cell(Cell c) ";

%feature("docstring")  cmf_core::SimpleTindexSnowMelt_use_for_cell "def cmf_core.SimpleTindexSnowMelt_use_for_cell(args, kwargs)

SimpleTindexSnowMelt_use_for_cell(Cell cell) ";

%feature("docstring")  cmf_core::SimplRichards_use_for_cell "def
cmf_core.SimplRichards_use_for_cell(args, kwargs)

SimplRichards_use_for_cell(Cell cell, bool no_override=True) ";

%feature("docstring")  cmf_core::snowfraction "def
cmf_core.snowfraction(args, kwargs)

snowfraction(real T) -> real  real
cmf::upslope::connections::snowfraction(real T)  A function to
calculate the snow fraction of the precipitation according to the air
temperature.  Returns 0.0 for T>+1 degC, 1.0 for T<-1degC and
interpolates linear between. Values between 0 and 1 can be interpreted
as sleet ";

%feature("docstring")  cmf_core::SoilLayer_cast "def
cmf_core.SoilLayer_cast(args, kwargs)

SoilLayer_cast(cmf::water::flux_node::ptr node) ->
cmf::upslope::SoilLayer::ptr ";

%feature("docstring")  cmf_core::square "def cmf_core.square(args,
kwargs)

square(real x) -> real ";

%feature("docstring")  cmf_core::SurfaceWater_cast "def
cmf_core.SurfaceWater_cast(args, kwargs)

SurfaceWater_cast(cmf::water::flux_node::ptr node) ->
cmf::upslope::SurfaceWater::ptr ";

%feature("docstring")  cmf_core::SWATPercolation_use_for_cell "def
cmf_core.SWATPercolation_use_for_cell(args, kwargs)

SWATPercolation_use_for_cell(Cell cell, bool no_override=True) ";

%feature("docstring")  cmf_core::swig_import_helper "def
swig_import_helper() ";

%feature("docstring")  cmf_core::system_bridge "def
cmf_core.system_bridge(args, kwargs)

system_bridge(project p, cmf::water::flux_node::ptr upper,
cmf::water::flux_node::ptr lower) -> cmf::water::SystemBridge::ptr
SystemBridge::ptr cmf::water::system_bridge(cmf::project &p,
flux_node::ptr upper, flux_node::ptr lower)  Creates a SystemBridge
object.  This is an advanced feature for tuning of the calculation
time.  A SystemBridge can be used to replace an existing connection
between nodes. After installation, the two nodes can more safely be
added to different integrator systems. One node (called upper) is
connected with the system bridge with the connection formerly
connecting the nodes, the second node (called lower) is connected to
the system bridge with as a Neumann boundary condition. The flux
equals the average flux of the connection upper <-> SystemBridge.
Therefore, the system bridge must become an integratable of the
integrator system the upper node belongs to. Use as an upper system
(system upper node is belonging to) the faster reacting system. For
the connection between upper and SystemBridge, the SystemBridge reacts
as an Dirichlet boundary condition, providing the potential of the
lower node. ";

%feature("docstring")  cmf_core::timerange "def
cmf_core.timerange(start, end, step=day)

Creates a generator of cmf.Time, similar to the Python range function
";

%feature("docstring")  cmf_core::timeseries_from_array "def
cmf_core.timeseries_from_array(args, kwargs)

timeseries_from_array(Time begin, Time step, cmf::math::num_array
const & data) -> timeseries ";

%feature("docstring")  cmf_core::timeseries_from_file "def
cmf_core.timeseries_from_file(args, kwargs)

timeseries_from_file(std::string filename) -> timeseries ";

%feature("docstring")  cmf_core::timeseries_from_scalar "def
cmf_core.timeseries_from_scalar(args, kwargs)

timeseries_from_scalar(double scalar) -> timeseries ";

%feature("docstring")  cmf_core::Topology_calculate_contributing_area
"def cmf_core.Topology_calculate_contributing_area(args, kwargs)

Topology_calculate_contributing_area(cell_vector arg2) ";

%feature("docstring")  cmf_core::TurcET_use_for_cell "def
cmf_core.TurcET_use_for_cell(args, kwargs)

TurcET_use_for_cell(Cell cell) ";

%feature("docstring")  cmf_core::vapour_pressure "def
cmf_core.vapour_pressure(args, kwargs)

vapour_pressure(double T) -> double  double
cmf::atmosphere::vapour_pressure(double T)  Returns the saturated
vapor pressure in Pa for temperature T [degC].  The saturated vapor
pressure :math:`e_s` is calculated follwing the following formula   ..
math::      e_s = 0.6108 \\\\\\\\exp{\\\\\\\\frac{17.27 T}{T+237.3}}
The definition is
fromhttp://www.fao.org/docrep/X0490E/x0490e07.htm#concepts ";

%feature("docstring")  cmf_core::vpd_from_rH "def
cmf_core.vpd_from_rH(args, kwargs)

vpd_from_rH(double T, double rH) -> double  double
cmf::atmosphere::vpd_from_rH(double T, double rH)  Returns the vapor
pressure deficit in Pa for temperature T [degC] and rel.  humidity rH
[%]  The vapor pressure deficit :math:`e_s - e_a` is calculated from
rel. humidity as:   .. math::      e_s - e_a = (1-rH/100) * e_s(T) The
definition is
fromhttp://www.fao.org/docrep/X0490E/x0490e07.htm#concepts Parameters:
-----------  T:  Air temperature in degC  rH:  Rel. humidity in %
:math:`e_s(T)` is calculated using
cmf::atmosphere::vapor_pressure(double) ";

%feature("docstring")  cmf_core::waterhead_to_pF "def
cmf_core.waterhead_to_pF(args, kwargs)

waterhead_to_pF(double waterhead) -> double ";

%feature("docstring")  cmf_core::waterhead_to_pressure "def
cmf_core.waterhead_to_pressure(args, kwargs)

waterhead_to_pressure(double waterhead) -> double ";

%feature("docstring")  cmf_core::WaterStorage_cast "def
cmf_core.WaterStorage_cast(args, kwargs)

WaterStorage_cast(std::shared_ptr< cmf::water::flux_node > node) ->
std::shared_ptr< cmf::water::WaterStorage > ";

%feature("docstring")  cmf_core::WaterStorage_create "def
cmf_core.WaterStorage_create(args, kwargs)

WaterStorage_create(project _project, real initial_state=0.0, real
scale=1.0) -> std::shared_ptr< cmf::water::WaterStorage > ";

%feature("docstring")  cmf_core::WaterStorage_from_node "def
cmf_core.WaterStorage_from_node(args, kwargs)

WaterStorage_from_node(cmf::water::flux_node::ptr node) ->
std::shared_ptr< cmf::water::WaterStorage > ";

%feature("docstring")  cmf_core::watts_to_MJ "def
cmf_core.watts_to_MJ(args, kwargs)

watts_to_MJ(double Watts) -> double ";

%feature("docstring")  cmf_core::Weather_get_snow_threshold "def
cmf_core.Weather_get_snow_threshold(args)

Weather_get_snow_threshold() -> double ";

%feature("docstring")  cmf_core::Weather_set_snow_threshold "def
cmf_core.Weather_set_snow_threshold(args, kwargs)

Weather_set_snow_threshold(double new_threshold) ";


// File: namespacestd.xml
%feature("docstring")  std::isfinite "bool std::isfinite(double v) ";

%feature("docstring")  std::to_string "std::string std::to_string(T
val) ";


// File: ____init_____8py.xml


// File: draw_2____init_____8py.xml


// File: geometry_2____init_____8py.xml


// File: nash__cascade_8h.xml


// File: reach__network_8h.xml


// File: subsurface_8h.xml
%feature("docstring")  run_subsurface_app "int run_subsurface_app()
";


// File: meteorology_8h.xml


// File: precipitation_8h.xml


// File: _weather_8h.xml


// File: cmf__core_8py.xml


// File: cmfmemory_8h.xml


// File: geometry_8h.xml


// File: bdf2_8h.xml


// File: cvode_8h.xml


// File: explicit__euler_8h.xml


// File: implicit__euler_8h.xml


// File: integrator_8h.xml


// File: multiintegrator_8h.xml


// File: _r_k_fintegrator_8h.xml


// File: _water_solute_integrator_8h.xml


// File: irregular__timeseries_8h.xml


// File: num__array_8h.xml


// File: real_8h.xml
%feature("docstring")  cmf::boltzmann "real boltzmann(real x, real
x_half, real tau)

The boltzmann function, used in cmf at several places where a s-shaped
curve is needed.



.. math::

    f(x,x_{1/2},\\\\tau)=\\\\frac{1}{1+e^{-\\\\frac{x-x_{1/2}}{tau}}}

";

%feature("docstring")  cmf::geo_mean "real geo_mean(real a, real b)
";

%feature("docstring")  cmf::harmonic_mean "real harmonic_mean(real a,
real b) ";

%feature("docstring")  cmf::maximum "real maximum(real a, real b) ";

%feature("docstring")  cmf::mean "real mean(real a, real b) ";

%feature("docstring")  cmf::minimum "real minimum(real a, real b)

Returns the minimum of two values. ";

%feature("docstring")  cmf::minmax "real minmax(real x, real min,
real max) ";

%feature("docstring")  cmf::piecewise_linear "real
piecewise_linear(real x, real xmin, real xmax, real ymin=0, real
ymax=1) ";

%feature("docstring")  cmf::sign "real sign(real x) ";

%feature("docstring")  cmf::square "real square(real x) ";


// File: root__finding_8h.xml


// File: spline_8h.xml


// File: statevariable_8h.xml


// File: time_8h.xml


// File: timeseries_8h.xml


// File: project_8h.xml


// File: cross__section__reach_8h.xml


// File: _manning_connection_8h.xml


// File: _open_water_storage_8h.xml


// File: _reach_8h.xml


// File: _reach_type_8h.xml


// File: algorithm_8h.xml


// File: cell_8h.xml


// File: cell__vector_8h.xml


// File: conductable_8h.xml


// File: _atmospheric_fluxes_8h.xml


// File: infiltration_8h.xml


// File: _percolation_8h.xml


// File: subsurfacefluxes_8h.xml


// File: surfacefluxes_8h.xml


// File: groundwater_8h.xml


// File: layer__list_8h.xml


// File: macropore_8h.xml


// File: _retention_curve_8h.xml


// File: _soil_layer_8h.xml


// File: surfacewater_8h.xml


// File: _topology_8h.xml


// File: _e_t_8h.xml


// File: _shuttleworth_wallace_8h.xml


// File: _struct_vegetation_8h.xml


// File: waterstress_8h.xml


// File: adsorption_8h.xml


// File: boundary__condition_8h.xml


// File: collections_8h.xml


// File: flux__connection_8h.xml


// File: flux__node_8h.xml


// File: simple__connections_8h.xml


// File: _solute_8h.xml


// File: _solute_storage_8h.xml


// File: system__bridge_8h.xml


// File: _water_storage_8h.xml


// File: describe_8py.xml


// File: cellmap_8py.xml


// File: draw__misc_8py.xml


// File: hillplot_8py.xml


// File: shapemap_8py.xml


// File: fit__retention__curve_8py.xml


// File: geocell_8py.xml


// File: qtree_8py.xml


// File: jacobian_8py.xml


// File: maps_8py.xml


// File: stopwatch_8py.xml


// File: _cmf_introduction_8md.xml


// File: _cmf_recommended_software_environment_8md.xml


// File: contrib_cpp_8md.xml


// File: contrib_docs_8md.xml


// File: contrib_py_8md.xml


// File: overview_8md.xml


// File: _finite_volume_method_8md.xml


// File: index_8md.xml


// File: _cmf_install_8md.xml


// File: _cmf_install_hpc_8md.xml


// File: _cmf_install_ubuntu_8md.xml


// File: _cmf_install_windows_8md.xml


// File: _publication_list_8md.xml


// File: atmosphere_8md.xml


// File: _cmf_tut_e_t_8md.xml


// File: _cmf_tut_intercept_8md.xml


// File: _cmf_tut_meteostation_8md.xml


// File: _cmf_tut_shuttleworth_wallace_8md.xml


// File: _cmf_tut_snow_8md.xml


// File: _cmf_tut_test_data_8md.xml


// File: _cmf_tut_start_8md.xml


// File: _cmf__lumped__simple_8md.xml


// File: _c_m_f__lumped__without__spotpy_8md.xml


// File: _cmf_tut_abstract_fluxes_8md.xml


// File: _cmf_tut_kinematic_wave_8md.xml


// File: conceptual_8md.xml


// File: semi__distributed_8md.xml


// File: _simple___infiltration_8md.xml


// File: _cmf_tut_boundary_8md.xml


// File: _cmf_tut_cell_8md.xml


// File: _cmf_tut_first_model_8md.xml


// File: _cmf_tut_fluxes_8md.xml


// File: _cmf_tut_need_to_know_8md.xml


// File: _cmf_tut_project_8md.xml


// File: _cmf_tut_solver_8md.xml


// File: _cmf_tut_space_time_8md.xml


// File: cmf_tut_structure_8md.xml


// File: _cmf_tut_units_8md.xml


// File: gettingstarted_8md.xml


// File: _install_check_8md.xml


// File: _descriptor_8md.xml


// File: _cmf_tut1d_8md.xml


// File: _cmf_tut2d_8md.xml


// File: _cmf_tut3d_8md.xml


// File: _cmf_tut_boundary2_8md.xml


// File: _cmf_tut_channel_8md.xml


// File: _cmf_tut_darcian_lateral_flow_8md.xml


// File: _cmf_tut_e_tphys_8md.xml


// File: _cmf_tut_retentioncurve_8md.xml


// File: _cmf_tut_solute_transport1_d_8md.xml


// File: _cmf_tut_surface_runoff_8md.xml


// File: _cmf_tut_volume_height_8md.xml


// File: physical_8md.xml


// File: group__boundary.xml


// File: group__surfacefluxes.xml


// File: group___e_t.xml


// File: group__connections.xml


// File: group__infiltration.xml


// File: group___macro_pore.xml


// File: group__meteo.xml


// File: group__perc.xml


// File: group__storages.xml


// File: group__manning.xml


// File: group__nodes.xml


// File: group__latflux.xml


// File: cmf_introduction.xml


// File: cmf_recommended_software_environment.xml


// File: contrib_cpp.xml


// File: contrib_docs.xml


// File: contrib_py.xml


// File: contrib_overview.xml


// File: contrib_issues.xml


// File: finite_volume_method.xml


// File: cmf_install.xml


// File: cmf_install_hpc.xml


// File: cmf_install_ubuntu.xml


// File: cmf_install_windows.xml


// File: publication_list.xml


// File: atmosphere.xml


// File: cmf_tut_e_t.xml


// File: cmf_tut_intercept.xml


// File: cmf_tut_meteostation.xml


// File: cmf_tut_shuttleworth_wallace.xml


// File: cmf_tut_snow.xml


// File: cmf_tut_test_data.xml


// File: tutorial.xml


// File: cmf_lumped_simple.xml


// File: cmf_lumped_without_spotpy.xml


// File: cmf_tut_abstract_fluxes.xml


// File: cmf_tut_kinematic_wave.xml


// File: conceptual.xml


// File: semi_distributed.xml


// File: simple_infiltration.xml


// File: cmf_tut_boundary.xml


// File: cmf_tut_cell.xml


// File: cmf_tut_first_model.xml


// File: cmf_tut_fluxes.xml


// File: cmf_tut_need_to_know.xml


// File: cmf_tut_project.xml


// File: cmf_tut_solver.xml


// File: cmf_tut_space_time.xml


// File: cmf_tut_structure.xml


// File: cmf_tut_units.xml


// File: gettingstarted.xml


// File: install_check.xml


// File: descriptor.xml


// File: cmf_tut1d.xml


// File: cmf_tut2d.xml


// File: cmf_tut3d.xml


// File: cmf_tut_boundary2.xml


// File: cmf_tut_channel.xml


// File: cmf_tut_darcian_lateral_flow.xml


// File: cmf_tut_e_tphys.xml


// File: cmf_tut_retentioncurve.xml


// File: cmf_tut_solute_transport1_d.xml


// File: cmf_tut_surface_runoff.xml


// File: cmf_tut_volume_height.xml


// File: physical.xml


// File: todo.xml


// File: deprecated.xml


// File: dir_a1b960d7648f0175b5e7cfeede519b17.xml


// File: dir_a32c301defa8fda793cb40af11415647.xml


// File: dir_58e40ea5f41f41b625255f0e93c0210e.xml


// File: dir_899d2e127fb6f8de6dda9777a2d11fc4.xml


// File: dir_276c0bb4402aea34a5542f6741d7a1ee.xml


// File: dir_e99589850f294dbf4b725494ab1c642e.xml


// File: dir_12788de71013d9dcf17a564ce1b123ce.xml


// File: dir_3f1ba486f713b268e033cb12ab59a41b.xml


// File: dir_6e764f1be992d70f16adadc29c086796.xml


// File: dir_fb2b4d745793dfd5bb69790f90a5a545.xml


// File: dir_707fbb85f5f5a03168ae42ef8ba0d65d.xml


// File: dir_73a48ad96f7ed71bd28db957498e0435.xml


// File: dir_8d4c975dc4db6fbc37636ae91790b381.xml


// File: dir_1e82fb26092adfe48cd921c6b8a3056a.xml


// File: dir_77005acaedd4c0a991f05071f95b4942.xml


// File: indexpage.xml


